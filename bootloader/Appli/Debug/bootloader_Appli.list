
bootloader_Appli.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .fw_header    00000028  70000000  70000000  00001000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .isr_vector   000002b0  70000028  70000028  00001028  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .text         00009b00  700002e0  700002e0  000012e0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000e8  70009de0  70009de0  0000ade0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .ARM.extab    00000000  70009ec8  70009ec8  0000b090  2**0
                  CONTENTS, READONLY
  5 .ARM          00000008  70009ec8  70009ec8  0000aec8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .preinit_array 00000000  70009ed0  70009ed0  0000b090  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  7 .init_array   00000004  70009ed0  70009ed0  0000aed0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  8 .fini_array   00000004  70009ed4  70009ed4  0000aed4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  9 .data         00000090  24000000  70009ed8  0000b000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
 10 .bss          00000548  24000090  70009f68  0000b090  2**2
                  ALLOC
 11 ._user_heap_stack 00000600  20000000  20000000  00001000  2**0
                  ALLOC
 12 .ARM.attributes 0000002e  00000000  00000000  0000b090  2**0
                  CONTENTS, READONLY
 13 .debug_info   0001df77  00000000  00000000  0000b0be  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 14 .debug_abbrev 000036e3  00000000  00000000  00029035  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 15 .debug_aranges 00001258  00000000  00000000  0002c718  2**3
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 16 .debug_rnglists 00000deb  00000000  00000000  0002d970  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 17 .debug_macro  000333fb  00000000  00000000  0002e75b  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 18 .debug_line   000184e8  00000000  00000000  00061b56  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 19 .debug_str    0013e7cb  00000000  00000000  0007a03e  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 20 .comment      00000043  00000000  00000000  001b8809  2**0
                  CONTENTS, READONLY
 21 .debug_frame  0000530c  00000000  00000000  001b884c  2**2
                  CONTENTS, READONLY, DEBUGGING, OCTETS
 22 .debug_line_str 00000068  00000000  00000000  001bdb58  2**0
                  CONTENTS, READONLY, DEBUGGING, OCTETS

Disassembly of section .text:

700002e0 <__do_global_dtors_aux>:
700002e0:	b510      	push	{r4, lr}
700002e2:	4c05      	ldr	r4, [pc, #20]	@ (700002f8 <__do_global_dtors_aux+0x18>)
700002e4:	7823      	ldrb	r3, [r4, #0]
700002e6:	b933      	cbnz	r3, 700002f6 <__do_global_dtors_aux+0x16>
700002e8:	4b04      	ldr	r3, [pc, #16]	@ (700002fc <__do_global_dtors_aux+0x1c>)
700002ea:	b113      	cbz	r3, 700002f2 <__do_global_dtors_aux+0x12>
700002ec:	4804      	ldr	r0, [pc, #16]	@ (70000300 <__do_global_dtors_aux+0x20>)
700002ee:	f3af 8000 	nop.w
700002f2:	2301      	movs	r3, #1
700002f4:	7023      	strb	r3, [r4, #0]
700002f6:	bd10      	pop	{r4, pc}
700002f8:	24000090 	.word	0x24000090
700002fc:	00000000 	.word	0x00000000
70000300:	70009dc8 	.word	0x70009dc8

70000304 <frame_dummy>:
70000304:	b508      	push	{r3, lr}
70000306:	4b03      	ldr	r3, [pc, #12]	@ (70000314 <frame_dummy+0x10>)
70000308:	b11b      	cbz	r3, 70000312 <frame_dummy+0xe>
7000030a:	4903      	ldr	r1, [pc, #12]	@ (70000318 <frame_dummy+0x14>)
7000030c:	4803      	ldr	r0, [pc, #12]	@ (7000031c <frame_dummy+0x18>)
7000030e:	f3af 8000 	nop.w
70000312:	bd08      	pop	{r3, pc}
70000314:	00000000 	.word	0x00000000
70000318:	24000094 	.word	0x24000094
7000031c:	70009dc8 	.word	0x70009dc8

70000320 <memchr>:
70000320:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
70000324:	2a10      	cmp	r2, #16
70000326:	db2b      	blt.n	70000380 <memchr+0x60>
70000328:	f010 0f07 	tst.w	r0, #7
7000032c:	d008      	beq.n	70000340 <memchr+0x20>
7000032e:	f810 3b01 	ldrb.w	r3, [r0], #1
70000332:	3a01      	subs	r2, #1
70000334:	428b      	cmp	r3, r1
70000336:	d02d      	beq.n	70000394 <memchr+0x74>
70000338:	f010 0f07 	tst.w	r0, #7
7000033c:	b342      	cbz	r2, 70000390 <memchr+0x70>
7000033e:	d1f6      	bne.n	7000032e <memchr+0xe>
70000340:	b4f0      	push	{r4, r5, r6, r7}
70000342:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
70000346:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
7000034a:	f022 0407 	bic.w	r4, r2, #7
7000034e:	f07f 0700 	mvns.w	r7, #0
70000352:	2300      	movs	r3, #0
70000354:	e8f0 5602 	ldrd	r5, r6, [r0], #8
70000358:	3c08      	subs	r4, #8
7000035a:	ea85 0501 	eor.w	r5, r5, r1
7000035e:	ea86 0601 	eor.w	r6, r6, r1
70000362:	fa85 f547 	uadd8	r5, r5, r7
70000366:	faa3 f587 	sel	r5, r3, r7
7000036a:	fa86 f647 	uadd8	r6, r6, r7
7000036e:	faa5 f687 	sel	r6, r5, r7
70000372:	b98e      	cbnz	r6, 70000398 <memchr+0x78>
70000374:	d1ee      	bne.n	70000354 <memchr+0x34>
70000376:	bcf0      	pop	{r4, r5, r6, r7}
70000378:	f001 01ff 	and.w	r1, r1, #255	@ 0xff
7000037c:	f002 0207 	and.w	r2, r2, #7
70000380:	b132      	cbz	r2, 70000390 <memchr+0x70>
70000382:	f810 3b01 	ldrb.w	r3, [r0], #1
70000386:	3a01      	subs	r2, #1
70000388:	ea83 0301 	eor.w	r3, r3, r1
7000038c:	b113      	cbz	r3, 70000394 <memchr+0x74>
7000038e:	d1f8      	bne.n	70000382 <memchr+0x62>
70000390:	2000      	movs	r0, #0
70000392:	4770      	bx	lr
70000394:	3801      	subs	r0, #1
70000396:	4770      	bx	lr
70000398:	2d00      	cmp	r5, #0
7000039a:	bf06      	itte	eq
7000039c:	4635      	moveq	r5, r6
7000039e:	3803      	subeq	r0, #3
700003a0:	3807      	subne	r0, #7
700003a2:	f015 0f01 	tst.w	r5, #1
700003a6:	d107      	bne.n	700003b8 <memchr+0x98>
700003a8:	3001      	adds	r0, #1
700003aa:	f415 7f80 	tst.w	r5, #256	@ 0x100
700003ae:	bf02      	ittt	eq
700003b0:	3001      	addeq	r0, #1
700003b2:	f415 3fc0 	tsteq.w	r5, #98304	@ 0x18000
700003b6:	3001      	addeq	r0, #1
700003b8:	bcf0      	pop	{r4, r5, r6, r7}
700003ba:	3801      	subs	r0, #1
700003bc:	4770      	bx	lr
700003be:	bf00      	nop

700003c0 <__aeabi_uldivmod>:
700003c0:	b953      	cbnz	r3, 700003d8 <__aeabi_uldivmod+0x18>
700003c2:	b94a      	cbnz	r2, 700003d8 <__aeabi_uldivmod+0x18>
700003c4:	2900      	cmp	r1, #0
700003c6:	bf08      	it	eq
700003c8:	2800      	cmpeq	r0, #0
700003ca:	bf1c      	itt	ne
700003cc:	f04f 31ff 	movne.w	r1, #4294967295	@ 0xffffffff
700003d0:	f04f 30ff 	movne.w	r0, #4294967295	@ 0xffffffff
700003d4:	f000 b988 	b.w	700006e8 <__aeabi_idiv0>
700003d8:	f1ad 0c08 	sub.w	ip, sp, #8
700003dc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
700003e0:	f000 f806 	bl	700003f0 <__udivmoddi4>
700003e4:	f8dd e004 	ldr.w	lr, [sp, #4]
700003e8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
700003ec:	b004      	add	sp, #16
700003ee:	4770      	bx	lr

700003f0 <__udivmoddi4>:
700003f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
700003f4:	9d08      	ldr	r5, [sp, #32]
700003f6:	468e      	mov	lr, r1
700003f8:	4604      	mov	r4, r0
700003fa:	4688      	mov	r8, r1
700003fc:	2b00      	cmp	r3, #0
700003fe:	d14a      	bne.n	70000496 <__udivmoddi4+0xa6>
70000400:	428a      	cmp	r2, r1
70000402:	4617      	mov	r7, r2
70000404:	d962      	bls.n	700004cc <__udivmoddi4+0xdc>
70000406:	fab2 f682 	clz	r6, r2
7000040a:	b14e      	cbz	r6, 70000420 <__udivmoddi4+0x30>
7000040c:	f1c6 0320 	rsb	r3, r6, #32
70000410:	fa01 f806 	lsl.w	r8, r1, r6
70000414:	fa20 f303 	lsr.w	r3, r0, r3
70000418:	40b7      	lsls	r7, r6
7000041a:	ea43 0808 	orr.w	r8, r3, r8
7000041e:	40b4      	lsls	r4, r6
70000420:	ea4f 4e17 	mov.w	lr, r7, lsr #16
70000424:	fa1f fc87 	uxth.w	ip, r7
70000428:	fbb8 f1fe 	udiv	r1, r8, lr
7000042c:	0c23      	lsrs	r3, r4, #16
7000042e:	fb0e 8811 	mls	r8, lr, r1, r8
70000432:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
70000436:	fb01 f20c 	mul.w	r2, r1, ip
7000043a:	429a      	cmp	r2, r3
7000043c:	d909      	bls.n	70000452 <__udivmoddi4+0x62>
7000043e:	18fb      	adds	r3, r7, r3
70000440:	f101 30ff 	add.w	r0, r1, #4294967295	@ 0xffffffff
70000444:	f080 80ea 	bcs.w	7000061c <__udivmoddi4+0x22c>
70000448:	429a      	cmp	r2, r3
7000044a:	f240 80e7 	bls.w	7000061c <__udivmoddi4+0x22c>
7000044e:	3902      	subs	r1, #2
70000450:	443b      	add	r3, r7
70000452:	1a9a      	subs	r2, r3, r2
70000454:	b2a3      	uxth	r3, r4
70000456:	fbb2 f0fe 	udiv	r0, r2, lr
7000045a:	fb0e 2210 	mls	r2, lr, r0, r2
7000045e:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
70000462:	fb00 fc0c 	mul.w	ip, r0, ip
70000466:	459c      	cmp	ip, r3
70000468:	d909      	bls.n	7000047e <__udivmoddi4+0x8e>
7000046a:	18fb      	adds	r3, r7, r3
7000046c:	f100 32ff 	add.w	r2, r0, #4294967295	@ 0xffffffff
70000470:	f080 80d6 	bcs.w	70000620 <__udivmoddi4+0x230>
70000474:	459c      	cmp	ip, r3
70000476:	f240 80d3 	bls.w	70000620 <__udivmoddi4+0x230>
7000047a:	443b      	add	r3, r7
7000047c:	3802      	subs	r0, #2
7000047e:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
70000482:	eba3 030c 	sub.w	r3, r3, ip
70000486:	2100      	movs	r1, #0
70000488:	b11d      	cbz	r5, 70000492 <__udivmoddi4+0xa2>
7000048a:	40f3      	lsrs	r3, r6
7000048c:	2200      	movs	r2, #0
7000048e:	e9c5 3200 	strd	r3, r2, [r5]
70000492:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
70000496:	428b      	cmp	r3, r1
70000498:	d905      	bls.n	700004a6 <__udivmoddi4+0xb6>
7000049a:	b10d      	cbz	r5, 700004a0 <__udivmoddi4+0xb0>
7000049c:	e9c5 0100 	strd	r0, r1, [r5]
700004a0:	2100      	movs	r1, #0
700004a2:	4608      	mov	r0, r1
700004a4:	e7f5      	b.n	70000492 <__udivmoddi4+0xa2>
700004a6:	fab3 f183 	clz	r1, r3
700004aa:	2900      	cmp	r1, #0
700004ac:	d146      	bne.n	7000053c <__udivmoddi4+0x14c>
700004ae:	4573      	cmp	r3, lr
700004b0:	d302      	bcc.n	700004b8 <__udivmoddi4+0xc8>
700004b2:	4282      	cmp	r2, r0
700004b4:	f200 8105 	bhi.w	700006c2 <__udivmoddi4+0x2d2>
700004b8:	1a84      	subs	r4, r0, r2
700004ba:	eb6e 0203 	sbc.w	r2, lr, r3
700004be:	2001      	movs	r0, #1
700004c0:	4690      	mov	r8, r2
700004c2:	2d00      	cmp	r5, #0
700004c4:	d0e5      	beq.n	70000492 <__udivmoddi4+0xa2>
700004c6:	e9c5 4800 	strd	r4, r8, [r5]
700004ca:	e7e2      	b.n	70000492 <__udivmoddi4+0xa2>
700004cc:	2a00      	cmp	r2, #0
700004ce:	f000 8090 	beq.w	700005f2 <__udivmoddi4+0x202>
700004d2:	fab2 f682 	clz	r6, r2
700004d6:	2e00      	cmp	r6, #0
700004d8:	f040 80a4 	bne.w	70000624 <__udivmoddi4+0x234>
700004dc:	1a8a      	subs	r2, r1, r2
700004de:	0c03      	lsrs	r3, r0, #16
700004e0:	ea4f 4e17 	mov.w	lr, r7, lsr #16
700004e4:	b280      	uxth	r0, r0
700004e6:	b2bc      	uxth	r4, r7
700004e8:	2101      	movs	r1, #1
700004ea:	fbb2 fcfe 	udiv	ip, r2, lr
700004ee:	fb0e 221c 	mls	r2, lr, ip, r2
700004f2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
700004f6:	fb04 f20c 	mul.w	r2, r4, ip
700004fa:	429a      	cmp	r2, r3
700004fc:	d907      	bls.n	7000050e <__udivmoddi4+0x11e>
700004fe:	18fb      	adds	r3, r7, r3
70000500:	f10c 38ff 	add.w	r8, ip, #4294967295	@ 0xffffffff
70000504:	d202      	bcs.n	7000050c <__udivmoddi4+0x11c>
70000506:	429a      	cmp	r2, r3
70000508:	f200 80e0 	bhi.w	700006cc <__udivmoddi4+0x2dc>
7000050c:	46c4      	mov	ip, r8
7000050e:	1a9b      	subs	r3, r3, r2
70000510:	fbb3 f2fe 	udiv	r2, r3, lr
70000514:	fb0e 3312 	mls	r3, lr, r2, r3
70000518:	ea40 4303 	orr.w	r3, r0, r3, lsl #16
7000051c:	fb02 f404 	mul.w	r4, r2, r4
70000520:	429c      	cmp	r4, r3
70000522:	d907      	bls.n	70000534 <__udivmoddi4+0x144>
70000524:	18fb      	adds	r3, r7, r3
70000526:	f102 30ff 	add.w	r0, r2, #4294967295	@ 0xffffffff
7000052a:	d202      	bcs.n	70000532 <__udivmoddi4+0x142>
7000052c:	429c      	cmp	r4, r3
7000052e:	f200 80ca 	bhi.w	700006c6 <__udivmoddi4+0x2d6>
70000532:	4602      	mov	r2, r0
70000534:	1b1b      	subs	r3, r3, r4
70000536:	ea42 400c 	orr.w	r0, r2, ip, lsl #16
7000053a:	e7a5      	b.n	70000488 <__udivmoddi4+0x98>
7000053c:	f1c1 0620 	rsb	r6, r1, #32
70000540:	408b      	lsls	r3, r1
70000542:	fa22 f706 	lsr.w	r7, r2, r6
70000546:	431f      	orrs	r7, r3
70000548:	fa0e f401 	lsl.w	r4, lr, r1
7000054c:	fa20 f306 	lsr.w	r3, r0, r6
70000550:	fa2e fe06 	lsr.w	lr, lr, r6
70000554:	ea4f 4917 	mov.w	r9, r7, lsr #16
70000558:	4323      	orrs	r3, r4
7000055a:	fa00 f801 	lsl.w	r8, r0, r1
7000055e:	fa1f fc87 	uxth.w	ip, r7
70000562:	fbbe f0f9 	udiv	r0, lr, r9
70000566:	0c1c      	lsrs	r4, r3, #16
70000568:	fb09 ee10 	mls	lr, r9, r0, lr
7000056c:	ea44 440e 	orr.w	r4, r4, lr, lsl #16
70000570:	fb00 fe0c 	mul.w	lr, r0, ip
70000574:	45a6      	cmp	lr, r4
70000576:	fa02 f201 	lsl.w	r2, r2, r1
7000057a:	d909      	bls.n	70000590 <__udivmoddi4+0x1a0>
7000057c:	193c      	adds	r4, r7, r4
7000057e:	f100 3aff 	add.w	sl, r0, #4294967295	@ 0xffffffff
70000582:	f080 809c 	bcs.w	700006be <__udivmoddi4+0x2ce>
70000586:	45a6      	cmp	lr, r4
70000588:	f240 8099 	bls.w	700006be <__udivmoddi4+0x2ce>
7000058c:	3802      	subs	r0, #2
7000058e:	443c      	add	r4, r7
70000590:	eba4 040e 	sub.w	r4, r4, lr
70000594:	fa1f fe83 	uxth.w	lr, r3
70000598:	fbb4 f3f9 	udiv	r3, r4, r9
7000059c:	fb09 4413 	mls	r4, r9, r3, r4
700005a0:	ea4e 4404 	orr.w	r4, lr, r4, lsl #16
700005a4:	fb03 fc0c 	mul.w	ip, r3, ip
700005a8:	45a4      	cmp	ip, r4
700005aa:	d908      	bls.n	700005be <__udivmoddi4+0x1ce>
700005ac:	193c      	adds	r4, r7, r4
700005ae:	f103 3eff 	add.w	lr, r3, #4294967295	@ 0xffffffff
700005b2:	f080 8082 	bcs.w	700006ba <__udivmoddi4+0x2ca>
700005b6:	45a4      	cmp	ip, r4
700005b8:	d97f      	bls.n	700006ba <__udivmoddi4+0x2ca>
700005ba:	3b02      	subs	r3, #2
700005bc:	443c      	add	r4, r7
700005be:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
700005c2:	eba4 040c 	sub.w	r4, r4, ip
700005c6:	fba0 ec02 	umull	lr, ip, r0, r2
700005ca:	4564      	cmp	r4, ip
700005cc:	4673      	mov	r3, lr
700005ce:	46e1      	mov	r9, ip
700005d0:	d362      	bcc.n	70000698 <__udivmoddi4+0x2a8>
700005d2:	d05f      	beq.n	70000694 <__udivmoddi4+0x2a4>
700005d4:	b15d      	cbz	r5, 700005ee <__udivmoddi4+0x1fe>
700005d6:	ebb8 0203 	subs.w	r2, r8, r3
700005da:	eb64 0409 	sbc.w	r4, r4, r9
700005de:	fa04 f606 	lsl.w	r6, r4, r6
700005e2:	fa22 f301 	lsr.w	r3, r2, r1
700005e6:	431e      	orrs	r6, r3
700005e8:	40cc      	lsrs	r4, r1
700005ea:	e9c5 6400 	strd	r6, r4, [r5]
700005ee:	2100      	movs	r1, #0
700005f0:	e74f      	b.n	70000492 <__udivmoddi4+0xa2>
700005f2:	fbb1 fcf2 	udiv	ip, r1, r2
700005f6:	0c01      	lsrs	r1, r0, #16
700005f8:	ea41 410e 	orr.w	r1, r1, lr, lsl #16
700005fc:	b280      	uxth	r0, r0
700005fe:	ea40 4201 	orr.w	r2, r0, r1, lsl #16
70000602:	463b      	mov	r3, r7
70000604:	4638      	mov	r0, r7
70000606:	463c      	mov	r4, r7
70000608:	46b8      	mov	r8, r7
7000060a:	46be      	mov	lr, r7
7000060c:	2620      	movs	r6, #32
7000060e:	fbb1 f1f7 	udiv	r1, r1, r7
70000612:	eba2 0208 	sub.w	r2, r2, r8
70000616:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
7000061a:	e766      	b.n	700004ea <__udivmoddi4+0xfa>
7000061c:	4601      	mov	r1, r0
7000061e:	e718      	b.n	70000452 <__udivmoddi4+0x62>
70000620:	4610      	mov	r0, r2
70000622:	e72c      	b.n	7000047e <__udivmoddi4+0x8e>
70000624:	f1c6 0220 	rsb	r2, r6, #32
70000628:	fa2e f302 	lsr.w	r3, lr, r2
7000062c:	40b7      	lsls	r7, r6
7000062e:	40b1      	lsls	r1, r6
70000630:	fa20 f202 	lsr.w	r2, r0, r2
70000634:	ea4f 4e17 	mov.w	lr, r7, lsr #16
70000638:	430a      	orrs	r2, r1
7000063a:	fbb3 f8fe 	udiv	r8, r3, lr
7000063e:	b2bc      	uxth	r4, r7
70000640:	fb0e 3318 	mls	r3, lr, r8, r3
70000644:	0c11      	lsrs	r1, r2, #16
70000646:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
7000064a:	fb08 f904 	mul.w	r9, r8, r4
7000064e:	40b0      	lsls	r0, r6
70000650:	4589      	cmp	r9, r1
70000652:	ea4f 4310 	mov.w	r3, r0, lsr #16
70000656:	b280      	uxth	r0, r0
70000658:	d93e      	bls.n	700006d8 <__udivmoddi4+0x2e8>
7000065a:	1879      	adds	r1, r7, r1
7000065c:	f108 3cff 	add.w	ip, r8, #4294967295	@ 0xffffffff
70000660:	d201      	bcs.n	70000666 <__udivmoddi4+0x276>
70000662:	4589      	cmp	r9, r1
70000664:	d81f      	bhi.n	700006a6 <__udivmoddi4+0x2b6>
70000666:	eba1 0109 	sub.w	r1, r1, r9
7000066a:	fbb1 f9fe 	udiv	r9, r1, lr
7000066e:	fb09 f804 	mul.w	r8, r9, r4
70000672:	fb0e 1119 	mls	r1, lr, r9, r1
70000676:	b292      	uxth	r2, r2
70000678:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
7000067c:	4542      	cmp	r2, r8
7000067e:	d229      	bcs.n	700006d4 <__udivmoddi4+0x2e4>
70000680:	18ba      	adds	r2, r7, r2
70000682:	f109 31ff 	add.w	r1, r9, #4294967295	@ 0xffffffff
70000686:	d2c4      	bcs.n	70000612 <__udivmoddi4+0x222>
70000688:	4542      	cmp	r2, r8
7000068a:	d2c2      	bcs.n	70000612 <__udivmoddi4+0x222>
7000068c:	f1a9 0102 	sub.w	r1, r9, #2
70000690:	443a      	add	r2, r7
70000692:	e7be      	b.n	70000612 <__udivmoddi4+0x222>
70000694:	45f0      	cmp	r8, lr
70000696:	d29d      	bcs.n	700005d4 <__udivmoddi4+0x1e4>
70000698:	ebbe 0302 	subs.w	r3, lr, r2
7000069c:	eb6c 0c07 	sbc.w	ip, ip, r7
700006a0:	3801      	subs	r0, #1
700006a2:	46e1      	mov	r9, ip
700006a4:	e796      	b.n	700005d4 <__udivmoddi4+0x1e4>
700006a6:	eba7 0909 	sub.w	r9, r7, r9
700006aa:	4449      	add	r1, r9
700006ac:	f1a8 0c02 	sub.w	ip, r8, #2
700006b0:	fbb1 f9fe 	udiv	r9, r1, lr
700006b4:	fb09 f804 	mul.w	r8, r9, r4
700006b8:	e7db      	b.n	70000672 <__udivmoddi4+0x282>
700006ba:	4673      	mov	r3, lr
700006bc:	e77f      	b.n	700005be <__udivmoddi4+0x1ce>
700006be:	4650      	mov	r0, sl
700006c0:	e766      	b.n	70000590 <__udivmoddi4+0x1a0>
700006c2:	4608      	mov	r0, r1
700006c4:	e6fd      	b.n	700004c2 <__udivmoddi4+0xd2>
700006c6:	443b      	add	r3, r7
700006c8:	3a02      	subs	r2, #2
700006ca:	e733      	b.n	70000534 <__udivmoddi4+0x144>
700006cc:	f1ac 0c02 	sub.w	ip, ip, #2
700006d0:	443b      	add	r3, r7
700006d2:	e71c      	b.n	7000050e <__udivmoddi4+0x11e>
700006d4:	4649      	mov	r1, r9
700006d6:	e79c      	b.n	70000612 <__udivmoddi4+0x222>
700006d8:	eba1 0109 	sub.w	r1, r1, r9
700006dc:	46c4      	mov	ip, r8
700006de:	fbb1 f9fe 	udiv	r9, r1, lr
700006e2:	fb09 f804 	mul.w	r8, r9, r4
700006e6:	e7c4      	b.n	70000672 <__udivmoddi4+0x282>

700006e8 <__aeabi_idiv0>:
700006e8:	4770      	bx	lr
700006ea:	bf00      	nop

700006ec <MX_EXTMEM_MANAGER_Init>:
/**
  * Init External memory manager
  * @retval None
  */
void MX_EXTMEM_MANAGER_Init(void)
{
700006ec:	b580      	push	{r7, lr}
700006ee:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN MX_EXTMEM_Init_PreTreatment */

  /* USER CODE END MX_EXTMEM_Init_PreTreatment */
  HAL_RCCEx_EnableClockProtection(RCC_CLOCKPROTECT_XSPI);
700006f0:	2001      	movs	r0, #1
700006f2:	f004 fa79 	bl	70004be8 <HAL_RCCEx_EnableClockProtection>

  /* Initialization of the memory parameters */
  memset(extmem_list_config, 0x0, sizeof(extmem_list_config));
700006f6:	22ac      	movs	r2, #172	@ 0xac
700006f8:	2100      	movs	r1, #0
700006fa:	480b      	ldr	r0, [pc, #44]	@ (70000728 <MX_EXTMEM_MANAGER_Init+0x3c>)
700006fc:	f008 fd3f 	bl	7000917e <memset>

  /* EXTMEMORY_1 */
  extmem_list_config[0].MemType = EXTMEM_NOR_SFDP;
70000700:	4b09      	ldr	r3, [pc, #36]	@ (70000728 <MX_EXTMEM_MANAGER_Init+0x3c>)
70000702:	2200      	movs	r2, #0
70000704:	701a      	strb	r2, [r3, #0]
  extmem_list_config[0].Handle = (void*)&hxspi1;
70000706:	4b08      	ldr	r3, [pc, #32]	@ (70000728 <MX_EXTMEM_MANAGER_Init+0x3c>)
70000708:	4a08      	ldr	r2, [pc, #32]	@ (7000072c <MX_EXTMEM_MANAGER_Init+0x40>)
7000070a:	605a      	str	r2, [r3, #4]
  extmem_list_config[0].ConfigType = EXTMEM_LINK_CONFIG_8LINES;
7000070c:	4b06      	ldr	r3, [pc, #24]	@ (70000728 <MX_EXTMEM_MANAGER_Init+0x3c>)
7000070e:	2203      	movs	r2, #3
70000710:	721a      	strb	r2, [r3, #8]

  EXTMEM_Init(EXTMEMORY_1, HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_XSPI1));
70000712:	2002      	movs	r0, #2
70000714:	f002 ff28 	bl	70003568 <HAL_RCCEx_GetPeriphCLKFreq>
70000718:	4603      	mov	r3, r0
7000071a:	4619      	mov	r1, r3
7000071c:	2000      	movs	r0, #0
7000071e:	f006 f927 	bl	70006970 <EXTMEM_Init>

  /* USER CODE BEGIN MX_EXTMEM_Init_PostTreatment */

  /* USER CODE END MX_EXTMEM_Init_PostTreatment */
}
70000722:	bf00      	nop
70000724:	bd80      	pop	{r7, pc}
70000726:	bf00      	nop
70000728:	24000258 	.word	0x24000258
7000072c:	24000150 	.word	0x24000150

70000730 <main>:
/**
  * @brief  The application entry point.
  * @retval int
  */
int main(void)
{
70000730:	b580      	push	{r7, lr}
70000732:	b084      	sub	sp, #16
70000734:	af00      	add	r7, sp, #0
  \details Turns on I-Cache
  */
__STATIC_FORCEINLINE void SCB_EnableICache (void)
{
  #if defined (__ICACHE_PRESENT) && (__ICACHE_PRESENT == 1U)
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
70000736:	4b59      	ldr	r3, [pc, #356]	@ (7000089c <main+0x16c>)
70000738:	695b      	ldr	r3, [r3, #20]
7000073a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
7000073e:	2b00      	cmp	r3, #0
70000740:	d11b      	bne.n	7000077a <main+0x4a>
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
70000742:	f3bf 8f4f 	dsb	sy
}
70000746:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
70000748:	f3bf 8f6f 	isb	sy
}
7000074c:	bf00      	nop

    __DSB();
    __ISB();
    SCB->ICIALLU = 0UL;                     /* invalidate I-Cache */
7000074e:	4b53      	ldr	r3, [pc, #332]	@ (7000089c <main+0x16c>)
70000750:	2200      	movs	r2, #0
70000752:	f8c3 2250 	str.w	r2, [r3, #592]	@ 0x250
  __ASM volatile ("dsb 0xF":::"memory");
70000756:	f3bf 8f4f 	dsb	sy
}
7000075a:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
7000075c:	f3bf 8f6f 	isb	sy
}
70000760:	bf00      	nop
    __DSB();
    __ISB();
    SCB->CCR |=  (uint32_t)SCB_CCR_IC_Msk;  /* enable I-Cache */
70000762:	4b4e      	ldr	r3, [pc, #312]	@ (7000089c <main+0x16c>)
70000764:	695b      	ldr	r3, [r3, #20]
70000766:	4a4d      	ldr	r2, [pc, #308]	@ (7000089c <main+0x16c>)
70000768:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
7000076c:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
7000076e:	f3bf 8f4f 	dsb	sy
}
70000772:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
70000774:	f3bf 8f6f 	isb	sy
}
70000778:	e000      	b.n	7000077c <main+0x4c>
    if (SCB->CCR & SCB_CCR_IC_Msk) return;  /* return if ICache is already enabled */
7000077a:	bf00      	nop
  #if defined (__DCACHE_PRESENT) && (__DCACHE_PRESENT == 1U)
    uint32_t ccsidr;
    uint32_t sets;
    uint32_t ways;

    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
7000077c:	4b47      	ldr	r3, [pc, #284]	@ (7000089c <main+0x16c>)
7000077e:	695b      	ldr	r3, [r3, #20]
70000780:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70000784:	2b00      	cmp	r3, #0
70000786:	d138      	bne.n	700007fa <main+0xca>

    SCB->CSSELR = 0U;                       /* select Level 1 data cache */
70000788:	4b44      	ldr	r3, [pc, #272]	@ (7000089c <main+0x16c>)
7000078a:	2200      	movs	r2, #0
7000078c:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  __ASM volatile ("dsb 0xF":::"memory");
70000790:	f3bf 8f4f 	dsb	sy
}
70000794:	bf00      	nop
    __DSB();

    ccsidr = SCB->CCSIDR;
70000796:	4b41      	ldr	r3, [pc, #260]	@ (7000089c <main+0x16c>)
70000798:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
7000079c:	60fb      	str	r3, [r7, #12]

                                            /* invalidate D-Cache */
    sets = (uint32_t)(CCSIDR_SETS(ccsidr));
7000079e:	68fb      	ldr	r3, [r7, #12]
700007a0:	0b5b      	lsrs	r3, r3, #13
700007a2:	f3c3 030e 	ubfx	r3, r3, #0, #15
700007a6:	60bb      	str	r3, [r7, #8]
    do {
      ways = (uint32_t)(CCSIDR_WAYS(ccsidr));
700007a8:	68fb      	ldr	r3, [r7, #12]
700007aa:	08db      	lsrs	r3, r3, #3
700007ac:	f3c3 0309 	ubfx	r3, r3, #0, #10
700007b0:	607b      	str	r3, [r7, #4]
      do {
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
700007b2:	68bb      	ldr	r3, [r7, #8]
700007b4:	015a      	lsls	r2, r3, #5
700007b6:	f643 73e0 	movw	r3, #16352	@ 0x3fe0
700007ba:	4013      	ands	r3, r2
                      ((ways << SCB_DCISW_WAY_Pos) & SCB_DCISW_WAY_Msk)  );
700007bc:	687a      	ldr	r2, [r7, #4]
700007be:	0792      	lsls	r2, r2, #30
        SCB->DCISW = (((sets << SCB_DCISW_SET_Pos) & SCB_DCISW_SET_Msk) |
700007c0:	4936      	ldr	r1, [pc, #216]	@ (7000089c <main+0x16c>)
700007c2:	4313      	orrs	r3, r2
700007c4:	f8c1 3260 	str.w	r3, [r1, #608]	@ 0x260
        #if defined ( __CC_ARM )
          __schedule_barrier();
        #endif
      } while (ways-- != 0U);
700007c8:	687b      	ldr	r3, [r7, #4]
700007ca:	1e5a      	subs	r2, r3, #1
700007cc:	607a      	str	r2, [r7, #4]
700007ce:	2b00      	cmp	r3, #0
700007d0:	d1ef      	bne.n	700007b2 <main+0x82>
    } while(sets-- != 0U);
700007d2:	68bb      	ldr	r3, [r7, #8]
700007d4:	1e5a      	subs	r2, r3, #1
700007d6:	60ba      	str	r2, [r7, #8]
700007d8:	2b00      	cmp	r3, #0
700007da:	d1e5      	bne.n	700007a8 <main+0x78>
  __ASM volatile ("dsb 0xF":::"memory");
700007dc:	f3bf 8f4f 	dsb	sy
}
700007e0:	bf00      	nop
    __DSB();

    SCB->CCR |=  (uint32_t)SCB_CCR_DC_Msk;  /* enable D-Cache */
700007e2:	4b2e      	ldr	r3, [pc, #184]	@ (7000089c <main+0x16c>)
700007e4:	695b      	ldr	r3, [r3, #20]
700007e6:	4a2d      	ldr	r2, [pc, #180]	@ (7000089c <main+0x16c>)
700007e8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
700007ec:	6153      	str	r3, [r2, #20]
  __ASM volatile ("dsb 0xF":::"memory");
700007ee:	f3bf 8f4f 	dsb	sy
}
700007f2:	bf00      	nop
  __ASM volatile ("isb 0xF":::"memory");
700007f4:	f3bf 8f6f 	isb	sy
}
700007f8:	e000      	b.n	700007fc <main+0xcc>
    if (SCB->CCR & SCB_CCR_DC_Msk) return;  /* return if DCache is already enabled */
700007fa:	bf00      	nop
  SCB_EnableDCache();

  /* MCU Configuration--------------------------------------------------------*/

  /* Update SystemCoreClock variable according to RCC registers values. */
  SystemCoreClockUpdate();
700007fc:	f000 fb2e 	bl	70000e5c <SystemCoreClockUpdate>

  /* Reset of all peripherals, Initializes the Flash interface and the Systick. */
  HAL_Init();
70000800:	f000 ff38 	bl	70001674 <HAL_Init>
  /* USER CODE BEGIN SysInit */

  /* USER CODE END SysInit */

  /* Initialize all configured peripherals */
  MX_GPIO_Init();
70000804:	f000 f8f6 	bl	700009f4 <MX_GPIO_Init>
  MX_USART1_UART_Init();
70000808:	f000 f850 	bl	700008ac <MX_USART1_UART_Init>
  MX_XSPI1_Init();
7000080c:	f000 f89a 	bl	70000944 <MX_XSPI1_Init>
  MX_EXTMEM_MANAGER_Init();
70000810:	f7ff ff6c 	bl	700006ec <MX_EXTMEM_MANAGER_Init>
  /* USER CODE BEGIN 2 */

  /* USER CODE END 2 */

  /* Initialize leds */
  BSP_LED_Init(LED_GREEN);
70000814:	2000      	movs	r0, #0
70000816:	f000 fc83 	bl	70001120 <BSP_LED_Init>
  BSP_LED_Init(LED_YELLOW);
7000081a:	2001      	movs	r0, #1
7000081c:	f000 fc80 	bl	70001120 <BSP_LED_Init>
  BSP_LED_Init(LED_RED);
70000820:	2002      	movs	r0, #2
70000822:	f000 fc7d 	bl	70001120 <BSP_LED_Init>

  /* Initialize USER push-button, will be used to trigger an interrupt each time it's pressed.*/
  BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
70000826:	2101      	movs	r1, #1
70000828:	2000      	movs	r0, #0
7000082a:	f000 fd29 	bl	70001280 <BSP_PB_Init>

  /* Initialize COM1 port (115200, 8 bits (7-bit data + 1 stop bit), no parity */
  BspCOMInit.BaudRate   = 115200;
7000082e:	4b1c      	ldr	r3, [pc, #112]	@ (700008a0 <main+0x170>)
70000830:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
70000834:	601a      	str	r2, [r3, #0]
  BspCOMInit.WordLength = COM_WORDLENGTH_8B;
70000836:	4b1a      	ldr	r3, [pc, #104]	@ (700008a0 <main+0x170>)
70000838:	2200      	movs	r2, #0
7000083a:	605a      	str	r2, [r3, #4]
  BspCOMInit.StopBits   = COM_STOPBITS_1;
7000083c:	4b18      	ldr	r3, [pc, #96]	@ (700008a0 <main+0x170>)
7000083e:	2200      	movs	r2, #0
70000840:	811a      	strh	r2, [r3, #8]
  BspCOMInit.Parity     = COM_PARITY_NONE;
70000842:	4b17      	ldr	r3, [pc, #92]	@ (700008a0 <main+0x170>)
70000844:	2200      	movs	r2, #0
70000846:	815a      	strh	r2, [r3, #10]
  BspCOMInit.HwFlowCtl  = COM_HWCONTROL_NONE;
70000848:	4b15      	ldr	r3, [pc, #84]	@ (700008a0 <main+0x170>)
7000084a:	2200      	movs	r2, #0
7000084c:	819a      	strh	r2, [r3, #12]
  if (BSP_COM_Init(COM1, &BspCOMInit) != BSP_ERROR_NONE)
7000084e:	4914      	ldr	r1, [pc, #80]	@ (700008a0 <main+0x170>)
70000850:	2000      	movs	r0, #0
70000852:	f000 fdd5 	bl	70001400 <BSP_COM_Init>
70000856:	4603      	mov	r3, r0
70000858:	2b00      	cmp	r3, #0
7000085a:	d001      	beq.n	70000860 <main+0x130>
  {
    Error_Handler();
7000085c:	f000 f910 	bl	70000a80 <Error_Handler>
  }

  /* USER CODE BEGIN BSP */
  /* -- Sample board code to send message over COM1 port ---- */
  printf("Welcome to STM32 world !\n\rApplication project is running...\n\r");
70000860:	4810      	ldr	r0, [pc, #64]	@ (700008a4 <main+0x174>)
70000862:	f008 fc37 	bl	700090d4 <iprintf>
  /* -- Sample board code to switch on leds ---- */
  BSP_LED_On(LED_GREEN);
70000866:	2000      	movs	r0, #0
70000868:	f000 fcbc 	bl	700011e4 <BSP_LED_On>
  BSP_LED_On(LED_YELLOW);
7000086c:	2001      	movs	r0, #1
7000086e:	f000 fcb9 	bl	700011e4 <BSP_LED_On>
  BSP_LED_On(LED_RED);
70000872:	2002      	movs	r0, #2
70000874:	f000 fcb6 	bl	700011e4 <BSP_LED_On>
  /* USER CODE BEGIN WHILE */
  while (1)
  {

    /* -- Sample board code for User push-button in interrupt mode ---- */
    if (BspButtonState == BUTTON_PRESSED)
70000878:	4b0b      	ldr	r3, [pc, #44]	@ (700008a8 <main+0x178>)
7000087a:	681b      	ldr	r3, [r3, #0]
7000087c:	2b00      	cmp	r3, #0
7000087e:	d1fb      	bne.n	70000878 <main+0x148>
    {
      /* Update button state */
      BspButtonState = BUTTON_RELEASED;
70000880:	4b09      	ldr	r3, [pc, #36]	@ (700008a8 <main+0x178>)
70000882:	2201      	movs	r2, #1
70000884:	601a      	str	r2, [r3, #0]
      /* -- Sample board code to toggle leds ---- */
      BSP_LED_Toggle(LED_GREEN);
70000886:	2000      	movs	r0, #0
70000888:	f000 fce0 	bl	7000124c <BSP_LED_Toggle>
      BSP_LED_Toggle(LED_YELLOW);
7000088c:	2001      	movs	r0, #1
7000088e:	f000 fcdd 	bl	7000124c <BSP_LED_Toggle>
      BSP_LED_Toggle(LED_RED);
70000892:	2002      	movs	r0, #2
70000894:	f000 fcda 	bl	7000124c <BSP_LED_Toggle>
    if (BspButtonState == BUTTON_PRESSED)
70000898:	e7ee      	b.n	70000878 <main+0x148>
7000089a:	bf00      	nop
7000089c:	e000ed00 	.word	0xe000ed00
700008a0:	240000ac 	.word	0x240000ac
700008a4:	70009de0 	.word	0x70009de0
700008a8:	24000000 	.word	0x24000000

700008ac <MX_USART1_UART_Init>:
  * @brief USART1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
700008ac:	b580      	push	{r7, lr}
700008ae:	af00      	add	r7, sp, #0
  /* USER CODE END USART1_Init 0 */

  /* USER CODE BEGIN USART1_Init 1 */

  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
700008b0:	4b22      	ldr	r3, [pc, #136]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008b2:	4a23      	ldr	r2, [pc, #140]	@ (70000940 <MX_USART1_UART_Init+0x94>)
700008b4:	601a      	str	r2, [r3, #0]
  huart1.Init.BaudRate = 115200;
700008b6:	4b21      	ldr	r3, [pc, #132]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008b8:	f44f 32e1 	mov.w	r2, #115200	@ 0x1c200
700008bc:	605a      	str	r2, [r3, #4]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
700008be:	4b1f      	ldr	r3, [pc, #124]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008c0:	2200      	movs	r2, #0
700008c2:	609a      	str	r2, [r3, #8]
  huart1.Init.StopBits = UART_STOPBITS_1;
700008c4:	4b1d      	ldr	r3, [pc, #116]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008c6:	2200      	movs	r2, #0
700008c8:	60da      	str	r2, [r3, #12]
  huart1.Init.Parity = UART_PARITY_NONE;
700008ca:	4b1c      	ldr	r3, [pc, #112]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008cc:	2200      	movs	r2, #0
700008ce:	611a      	str	r2, [r3, #16]
  huart1.Init.Mode = UART_MODE_TX_RX;
700008d0:	4b1a      	ldr	r3, [pc, #104]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008d2:	220c      	movs	r2, #12
700008d4:	615a      	str	r2, [r3, #20]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
700008d6:	4b19      	ldr	r3, [pc, #100]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008d8:	2200      	movs	r2, #0
700008da:	619a      	str	r2, [r3, #24]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
700008dc:	4b17      	ldr	r3, [pc, #92]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008de:	2200      	movs	r2, #0
700008e0:	61da      	str	r2, [r3, #28]
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
700008e2:	4b16      	ldr	r3, [pc, #88]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008e4:	2200      	movs	r2, #0
700008e6:	621a      	str	r2, [r3, #32]
  huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
700008e8:	4b14      	ldr	r3, [pc, #80]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008ea:	2200      	movs	r2, #0
700008ec:	625a      	str	r2, [r3, #36]	@ 0x24
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
700008ee:	4b13      	ldr	r3, [pc, #76]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008f0:	2200      	movs	r2, #0
700008f2:	629a      	str	r2, [r3, #40]	@ 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
700008f4:	4811      	ldr	r0, [pc, #68]	@ (7000093c <MX_USART1_UART_Init+0x90>)
700008f6:	f004 f9d7 	bl	70004ca8 <HAL_UART_Init>
700008fa:	4603      	mov	r3, r0
700008fc:	2b00      	cmp	r3, #0
700008fe:	d001      	beq.n	70000904 <MX_USART1_UART_Init+0x58>
  {
    Error_Handler();
70000900:	f000 f8be 	bl	70000a80 <Error_Handler>
  }
  if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
70000904:	2100      	movs	r1, #0
70000906:	480d      	ldr	r0, [pc, #52]	@ (7000093c <MX_USART1_UART_Init+0x90>)
70000908:	f005 f8a7 	bl	70005a5a <HAL_UARTEx_SetTxFifoThreshold>
7000090c:	4603      	mov	r3, r0
7000090e:	2b00      	cmp	r3, #0
70000910:	d001      	beq.n	70000916 <MX_USART1_UART_Init+0x6a>
  {
    Error_Handler();
70000912:	f000 f8b5 	bl	70000a80 <Error_Handler>
  }
  if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
70000916:	2100      	movs	r1, #0
70000918:	4808      	ldr	r0, [pc, #32]	@ (7000093c <MX_USART1_UART_Init+0x90>)
7000091a:	f005 f8dc 	bl	70005ad6 <HAL_UARTEx_SetRxFifoThreshold>
7000091e:	4603      	mov	r3, r0
70000920:	2b00      	cmp	r3, #0
70000922:	d001      	beq.n	70000928 <MX_USART1_UART_Init+0x7c>
  {
    Error_Handler();
70000924:	f000 f8ac 	bl	70000a80 <Error_Handler>
  }
  if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
70000928:	4804      	ldr	r0, [pc, #16]	@ (7000093c <MX_USART1_UART_Init+0x90>)
7000092a:	f005 f85d 	bl	700059e8 <HAL_UARTEx_DisableFifoMode>
7000092e:	4603      	mov	r3, r0
70000930:	2b00      	cmp	r3, #0
70000932:	d001      	beq.n	70000938 <MX_USART1_UART_Init+0x8c>
  {
    Error_Handler();
70000934:	f000 f8a4 	bl	70000a80 <Error_Handler>
  }
  /* USER CODE BEGIN USART1_Init 2 */

  /* USER CODE END USART1_Init 2 */

}
70000938:	bf00      	nop
7000093a:	bd80      	pop	{r7, pc}
7000093c:	240000bc 	.word	0x240000bc
70000940:	42001000 	.word	0x42001000

70000944 <MX_XSPI1_Init>:
  * @brief XSPI1 Initialization Function
  * @param None
  * @retval None
  */
static void MX_XSPI1_Init(void)
{
70000944:	b580      	push	{r7, lr}
70000946:	b084      	sub	sp, #16
70000948:	af00      	add	r7, sp, #0

  /* USER CODE BEGIN XSPI1_Init 0 */

  /* USER CODE END XSPI1_Init 0 */

  XSPIM_CfgTypeDef sXspiManagerCfg = {0};
7000094a:	1d3b      	adds	r3, r7, #4
7000094c:	2200      	movs	r2, #0
7000094e:	601a      	str	r2, [r3, #0]
70000950:	605a      	str	r2, [r3, #4]
70000952:	609a      	str	r2, [r3, #8]

  /* USER CODE BEGIN XSPI1_Init 1 */

  /* USER CODE END XSPI1_Init 1 */
  /* XSPI1 parameter configuration*/
  hxspi1.Instance = XSPI1;
70000954:	4b25      	ldr	r3, [pc, #148]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000956:	4a26      	ldr	r2, [pc, #152]	@ (700009f0 <MX_XSPI1_Init+0xac>)
70000958:	601a      	str	r2, [r3, #0]
  hxspi1.Init.FifoThresholdByte = 1;
7000095a:	4b24      	ldr	r3, [pc, #144]	@ (700009ec <MX_XSPI1_Init+0xa8>)
7000095c:	2201      	movs	r2, #1
7000095e:	605a      	str	r2, [r3, #4]
  hxspi1.Init.MemoryMode = HAL_XSPI_DUAL_MEM;
70000960:	4b22      	ldr	r3, [pc, #136]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000962:	2240      	movs	r2, #64	@ 0x40
70000964:	609a      	str	r2, [r3, #8]
  hxspi1.Init.MemoryType = HAL_XSPI_MEMTYPE_MACRONIX;
70000966:	4b21      	ldr	r3, [pc, #132]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000968:	f04f 7280 	mov.w	r2, #16777216	@ 0x1000000
7000096c:	60da      	str	r2, [r3, #12]
  hxspi1.Init.MemorySize = HAL_XSPI_SIZE_16B;
7000096e:	4b1f      	ldr	r3, [pc, #124]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000970:	2200      	movs	r2, #0
70000972:	611a      	str	r2, [r3, #16]
  hxspi1.Init.ChipSelectHighTimeCycle = 1;
70000974:	4b1d      	ldr	r3, [pc, #116]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000976:	2201      	movs	r2, #1
70000978:	615a      	str	r2, [r3, #20]
  hxspi1.Init.FreeRunningClock = HAL_XSPI_FREERUNCLK_ENABLE;
7000097a:	4b1c      	ldr	r3, [pc, #112]	@ (700009ec <MX_XSPI1_Init+0xa8>)
7000097c:	2202      	movs	r2, #2
7000097e:	619a      	str	r2, [r3, #24]
  hxspi1.Init.ClockMode = HAL_XSPI_CLOCK_MODE_0;
70000980:	4b1a      	ldr	r3, [pc, #104]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000982:	2200      	movs	r2, #0
70000984:	61da      	str	r2, [r3, #28]
  hxspi1.Init.WrapSize = HAL_XSPI_WRAP_NOT_SUPPORTED;
70000986:	4b19      	ldr	r3, [pc, #100]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000988:	2200      	movs	r2, #0
7000098a:	621a      	str	r2, [r3, #32]
  hxspi1.Init.ClockPrescaler = 8;
7000098c:	4b17      	ldr	r3, [pc, #92]	@ (700009ec <MX_XSPI1_Init+0xa8>)
7000098e:	2208      	movs	r2, #8
70000990:	625a      	str	r2, [r3, #36]	@ 0x24
  hxspi1.Init.SampleShifting = HAL_XSPI_SAMPLE_SHIFT_NONE;
70000992:	4b16      	ldr	r3, [pc, #88]	@ (700009ec <MX_XSPI1_Init+0xa8>)
70000994:	2200      	movs	r2, #0
70000996:	629a      	str	r2, [r3, #40]	@ 0x28
  hxspi1.Init.ChipSelectBoundary = HAL_XSPI_BONDARYOF_NONE;
70000998:	4b14      	ldr	r3, [pc, #80]	@ (700009ec <MX_XSPI1_Init+0xa8>)
7000099a:	2200      	movs	r2, #0
7000099c:	631a      	str	r2, [r3, #48]	@ 0x30
  hxspi1.Init.MaxTran = 0;
7000099e:	4b13      	ldr	r3, [pc, #76]	@ (700009ec <MX_XSPI1_Init+0xa8>)
700009a0:	2200      	movs	r2, #0
700009a2:	635a      	str	r2, [r3, #52]	@ 0x34
  hxspi1.Init.Refresh = 0;
700009a4:	4b11      	ldr	r3, [pc, #68]	@ (700009ec <MX_XSPI1_Init+0xa8>)
700009a6:	2200      	movs	r2, #0
700009a8:	639a      	str	r2, [r3, #56]	@ 0x38
  hxspi1.Init.MemorySelect = HAL_XSPI_CSSEL_NCS1;
700009aa:	4b10      	ldr	r3, [pc, #64]	@ (700009ec <MX_XSPI1_Init+0xa8>)
700009ac:	2200      	movs	r2, #0
700009ae:	63da      	str	r2, [r3, #60]	@ 0x3c
  if (HAL_XSPI_Init(&hxspi1) != HAL_OK)
700009b0:	480e      	ldr	r0, [pc, #56]	@ (700009ec <MX_XSPI1_Init+0xa8>)
700009b2:	f005 f91d 	bl	70005bf0 <HAL_XSPI_Init>
700009b6:	4603      	mov	r3, r0
700009b8:	2b00      	cmp	r3, #0
700009ba:	d001      	beq.n	700009c0 <MX_XSPI1_Init+0x7c>
  {
    Error_Handler();
700009bc:	f000 f860 	bl	70000a80 <Error_Handler>
  }
  sXspiManagerCfg.nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
700009c0:	2300      	movs	r3, #0
700009c2:	607b      	str	r3, [r7, #4]
  sXspiManagerCfg.IOPort = HAL_XSPIM_IOPORT_1;
700009c4:	2300      	movs	r3, #0
700009c6:	60bb      	str	r3, [r7, #8]
  sXspiManagerCfg.Req2AckTime = 1;
700009c8:	2301      	movs	r3, #1
700009ca:	60fb      	str	r3, [r7, #12]
  if (HAL_XSPIM_Config(&hxspi1, &sXspiManagerCfg, HAL_XSPI_TIMEOUT_DEFAULT_VALUE) != HAL_OK)
700009cc:	1d3b      	adds	r3, r7, #4
700009ce:	f241 3288 	movw	r2, #5000	@ 0x1388
700009d2:	4619      	mov	r1, r3
700009d4:	4805      	ldr	r0, [pc, #20]	@ (700009ec <MX_XSPI1_Init+0xa8>)
700009d6:	f005 fcb7 	bl	70006348 <HAL_XSPIM_Config>
700009da:	4603      	mov	r3, r0
700009dc:	2b00      	cmp	r3, #0
700009de:	d001      	beq.n	700009e4 <MX_XSPI1_Init+0xa0>
  {
    Error_Handler();
700009e0:	f000 f84e 	bl	70000a80 <Error_Handler>
  }
  /* USER CODE BEGIN XSPI1_Init 2 */

  /* USER CODE END XSPI1_Init 2 */

}
700009e4:	bf00      	nop
700009e6:	3710      	adds	r7, #16
700009e8:	46bd      	mov	sp, r7
700009ea:	bd80      	pop	{r7, pc}
700009ec:	24000150 	.word	0x24000150
700009f0:	52005000 	.word	0x52005000

700009f4 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
700009f4:	b480      	push	{r7}
700009f6:	b085      	sub	sp, #20
700009f8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MX_GPIO_Init_1 */

  /* USER CODE END MX_GPIO_Init_1 */

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
700009fa:	4b16      	ldr	r3, [pc, #88]	@ (70000a54 <MX_GPIO_Init+0x60>)
700009fc:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000a00:	4a14      	ldr	r2, [pc, #80]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a02:	f043 0301 	orr.w	r3, r3, #1
70000a06:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000a0a:	4b12      	ldr	r3, [pc, #72]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a0c:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000a10:	60fb      	str	r3, [r7, #12]
70000a12:	68fb      	ldr	r3, [r7, #12]
  __HAL_RCC_GPIOP_CLK_ENABLE();
70000a14:	4b0f      	ldr	r3, [pc, #60]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a16:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000a1a:	4a0e      	ldr	r2, [pc, #56]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a1c:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
70000a20:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000a24:	4b0b      	ldr	r3, [pc, #44]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a26:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000a2a:	60bb      	str	r3, [r7, #8]
70000a2c:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_GPIOO_CLK_ENABLE();
70000a2e:	4b09      	ldr	r3, [pc, #36]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a30:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000a34:	4a07      	ldr	r2, [pc, #28]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a36:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
70000a3a:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000a3e:	4b05      	ldr	r3, [pc, #20]	@ (70000a54 <MX_GPIO_Init+0x60>)
70000a40:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000a44:	607b      	str	r3, [r7, #4]
70000a46:	687b      	ldr	r3, [r7, #4]

  /* USER CODE BEGIN MX_GPIO_Init_2 */

  /* USER CODE END MX_GPIO_Init_2 */
}
70000a48:	bf00      	nop
70000a4a:	3714      	adds	r7, #20
70000a4c:	46bd      	mov	sp, r7
70000a4e:	f85d 7b04 	ldr.w	r7, [sp], #4
70000a52:	4770      	bx	lr
70000a54:	58024400 	.word	0x58024400

70000a58 <BSP_PB_Callback>:
  * @brief  BSP Push Button callback
  * @param  Button Specifies the pressed button
  * @retval None
  */
void BSP_PB_Callback(Button_TypeDef Button)
{
70000a58:	b480      	push	{r7}
70000a5a:	b083      	sub	sp, #12
70000a5c:	af00      	add	r7, sp, #0
70000a5e:	4603      	mov	r3, r0
70000a60:	71fb      	strb	r3, [r7, #7]
  if (Button == BUTTON_USER)
70000a62:	79fb      	ldrb	r3, [r7, #7]
70000a64:	2b00      	cmp	r3, #0
70000a66:	d102      	bne.n	70000a6e <BSP_PB_Callback+0x16>
  {
    BspButtonState = BUTTON_PRESSED;
70000a68:	4b04      	ldr	r3, [pc, #16]	@ (70000a7c <BSP_PB_Callback+0x24>)
70000a6a:	2200      	movs	r2, #0
70000a6c:	601a      	str	r2, [r3, #0]
  }
}
70000a6e:	bf00      	nop
70000a70:	370c      	adds	r7, #12
70000a72:	46bd      	mov	sp, r7
70000a74:	f85d 7b04 	ldr.w	r7, [sp], #4
70000a78:	4770      	bx	lr
70000a7a:	bf00      	nop
70000a7c:	24000000 	.word	0x24000000

70000a80 <Error_Handler>:
/**
  * @brief  This function is executed in case of error occurrence.
  * @retval None
  */
void Error_Handler(void)
{
70000a80:	b480      	push	{r7}
70000a82:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting special-purpose register PRIMASK.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
70000a84:	b672      	cpsid	i
}
70000a86:	bf00      	nop
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
70000a88:	bf00      	nop
70000a8a:	e7fd      	b.n	70000a88 <Error_Handler+0x8>

70000a8c <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
70000a8c:	b580      	push	{r7, lr}
70000a8e:	af00      	add	r7, sp, #0
  /* USER CODE END MspInit 0 */

  /* System interrupt init*/

  /* Enable the XSPIM_P1 interface */
  HAL_PWREx_EnableXSPIM1();
70000a90:	f001 fa04 	bl	70001e9c <HAL_PWREx_EnableXSPIM1>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
70000a94:	bf00      	nop
70000a96:	bd80      	pop	{r7, pc}

70000a98 <HAL_UART_MspInit>:
  * This function configures the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
{
70000a98:	b580      	push	{r7, lr}
70000a9a:	b0aa      	sub	sp, #168	@ 0xa8
70000a9c:	af00      	add	r7, sp, #0
70000a9e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
70000aa0:	f107 0394 	add.w	r3, r7, #148	@ 0x94
70000aa4:	2200      	movs	r2, #0
70000aa6:	601a      	str	r2, [r3, #0]
70000aa8:	605a      	str	r2, [r3, #4]
70000aaa:	609a      	str	r2, [r3, #8]
70000aac:	60da      	str	r2, [r3, #12]
70000aae:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
70000ab0:	f107 0310 	add.w	r3, r7, #16
70000ab4:	2284      	movs	r2, #132	@ 0x84
70000ab6:	2100      	movs	r1, #0
70000ab8:	4618      	mov	r0, r3
70000aba:	f008 fb60 	bl	7000917e <memset>
  if(huart->Instance==USART1)
70000abe:	687b      	ldr	r3, [r7, #4]
70000ac0:	681b      	ldr	r3, [r3, #0]
70000ac2:	4a23      	ldr	r2, [pc, #140]	@ (70000b50 <HAL_UART_MspInit+0xb8>)
70000ac4:	4293      	cmp	r3, r2
70000ac6:	d13e      	bne.n	70000b46 <HAL_UART_MspInit+0xae>

    /* USER CODE END USART1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
70000ac8:	f04f 5380 	mov.w	r3, #268435456	@ 0x10000000
70000acc:	613b      	str	r3, [r7, #16]
    PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
70000ace:	2300      	movs	r3, #0
70000ad0:	67fb      	str	r3, [r7, #124]	@ 0x7c
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
70000ad2:	f107 0310 	add.w	r3, r7, #16
70000ad6:	4618      	mov	r0, r3
70000ad8:	f001 fe42 	bl	70002760 <HAL_RCCEx_PeriphCLKConfig>
70000adc:	4603      	mov	r3, r0
70000ade:	2b00      	cmp	r3, #0
70000ae0:	d001      	beq.n	70000ae6 <HAL_UART_MspInit+0x4e>
    {
      Error_Handler();
70000ae2:	f7ff ffcd 	bl	70000a80 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
70000ae6:	4b1b      	ldr	r3, [pc, #108]	@ (70000b54 <HAL_UART_MspInit+0xbc>)
70000ae8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
70000aec:	4a19      	ldr	r2, [pc, #100]	@ (70000b54 <HAL_UART_MspInit+0xbc>)
70000aee:	f043 0310 	orr.w	r3, r3, #16
70000af2:	f8c2 3150 	str.w	r3, [r2, #336]	@ 0x150
70000af6:	4b17      	ldr	r3, [pc, #92]	@ (70000b54 <HAL_UART_MspInit+0xbc>)
70000af8:	f8d3 3150 	ldr.w	r3, [r3, #336]	@ 0x150
70000afc:	60fb      	str	r3, [r7, #12]
70000afe:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOA_CLK_ENABLE();
70000b00:	4b14      	ldr	r3, [pc, #80]	@ (70000b54 <HAL_UART_MspInit+0xbc>)
70000b02:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000b06:	4a13      	ldr	r2, [pc, #76]	@ (70000b54 <HAL_UART_MspInit+0xbc>)
70000b08:	f043 0301 	orr.w	r3, r3, #1
70000b0c:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000b10:	4b10      	ldr	r3, [pc, #64]	@ (70000b54 <HAL_UART_MspInit+0xbc>)
70000b12:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000b16:	60bb      	str	r3, [r7, #8]
70000b18:	68bb      	ldr	r3, [r7, #8]
    /**USART1 GPIO Configuration
    PA9     ------> USART1_TX
    PA10     ------> USART1_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
70000b1a:	f44f 63c0 	mov.w	r3, #1536	@ 0x600
70000b1e:	f8c7 3094 	str.w	r3, [r7, #148]	@ 0x94
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
70000b22:	2302      	movs	r3, #2
70000b24:	f8c7 3098 	str.w	r3, [r7, #152]	@ 0x98
    GPIO_InitStruct.Pull = GPIO_NOPULL;
70000b28:	2300      	movs	r3, #0
70000b2a:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
70000b2e:	2300      	movs	r3, #0
70000b30:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
70000b34:	2307      	movs	r3, #7
70000b36:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
70000b3a:	f107 0394 	add.w	r3, r7, #148	@ 0x94
70000b3e:	4619      	mov	r1, r3
70000b40:	4805      	ldr	r0, [pc, #20]	@ (70000b58 <HAL_UART_MspInit+0xc0>)
70000b42:	f001 f819 	bl	70001b78 <HAL_GPIO_Init>

    /* USER CODE END USART1_MspInit 1 */

  }

}
70000b46:	bf00      	nop
70000b48:	37a8      	adds	r7, #168	@ 0xa8
70000b4a:	46bd      	mov	sp, r7
70000b4c:	bd80      	pop	{r7, pc}
70000b4e:	bf00      	nop
70000b50:	42001000 	.word	0x42001000
70000b54:	58024400 	.word	0x58024400
70000b58:	58020000 	.word	0x58020000

70000b5c <HAL_XSPI_MspInit>:
  * This function configures the hardware resources used in this example
  * @param hxspi: XSPI handle pointer
  * @retval None
  */
void HAL_XSPI_MspInit(XSPI_HandleTypeDef* hxspi)
{
70000b5c:	b580      	push	{r7, lr}
70000b5e:	b0ac      	sub	sp, #176	@ 0xb0
70000b60:	af00      	add	r7, sp, #0
70000b62:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
70000b64:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
70000b68:	2200      	movs	r2, #0
70000b6a:	601a      	str	r2, [r3, #0]
70000b6c:	605a      	str	r2, [r3, #4]
70000b6e:	609a      	str	r2, [r3, #8]
70000b70:	60da      	str	r2, [r3, #12]
70000b72:	611a      	str	r2, [r3, #16]
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
70000b74:	f107 0318 	add.w	r3, r7, #24
70000b78:	2284      	movs	r2, #132	@ 0x84
70000b7a:	2100      	movs	r1, #0
70000b7c:	4618      	mov	r0, r3
70000b7e:	f008 fafe 	bl	7000917e <memset>
  if(hxspi->Instance==XSPI1)
70000b82:	687b      	ldr	r3, [r7, #4]
70000b84:	681b      	ldr	r3, [r3, #0]
70000b86:	4a39      	ldr	r2, [pc, #228]	@ (70000c6c <HAL_XSPI_MspInit+0x110>)
70000b88:	4293      	cmp	r3, r2
70000b8a:	d16b      	bne.n	70000c64 <HAL_XSPI_MspInit+0x108>

    /* USER CODE END XSPI1_MspInit 0 */

  /** Initializes the peripherals clock
  */
    PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_XSPI1;
70000b8c:	2302      	movs	r3, #2
70000b8e:	61bb      	str	r3, [r7, #24]
    PeriphClkInit.Xspi1ClockSelection = RCC_XSPI1CLKSOURCE_PLL2S;
70000b90:	2310      	movs	r3, #16
70000b92:	623b      	str	r3, [r7, #32]
    if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
70000b94:	f107 0318 	add.w	r3, r7, #24
70000b98:	4618      	mov	r0, r3
70000b9a:	f001 fde1 	bl	70002760 <HAL_RCCEx_PeriphCLKConfig>
70000b9e:	4603      	mov	r3, r0
70000ba0:	2b00      	cmp	r3, #0
70000ba2:	d001      	beq.n	70000ba8 <HAL_XSPI_MspInit+0x4c>
    {
      Error_Handler();
70000ba4:	f7ff ff6c 	bl	70000a80 <Error_Handler>
    }

    /* Peripheral clock enable */
    __HAL_RCC_XSPIM_CLK_ENABLE();
70000ba8:	4b31      	ldr	r3, [pc, #196]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000baa:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
70000bae:	4a30      	ldr	r2, [pc, #192]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bb0:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
70000bb4:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
70000bb8:	4b2d      	ldr	r3, [pc, #180]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bba:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
70000bbe:	617b      	str	r3, [r7, #20]
70000bc0:	697b      	ldr	r3, [r7, #20]
    __HAL_RCC_XSPI1_CLK_ENABLE();
70000bc2:	4b2b      	ldr	r3, [pc, #172]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bc4:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
70000bc8:	4a29      	ldr	r2, [pc, #164]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bca:	f043 0320 	orr.w	r3, r3, #32
70000bce:	f8c2 3134 	str.w	r3, [r2, #308]	@ 0x134
70000bd2:	4b27      	ldr	r3, [pc, #156]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bd4:	f8d3 3134 	ldr.w	r3, [r3, #308]	@ 0x134
70000bd8:	613b      	str	r3, [r7, #16]
70000bda:	693b      	ldr	r3, [r7, #16]

    __HAL_RCC_GPIOP_CLK_ENABLE();
70000bdc:	4b24      	ldr	r3, [pc, #144]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bde:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000be2:	4a23      	ldr	r2, [pc, #140]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000be4:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
70000be8:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000bec:	4b20      	ldr	r3, [pc, #128]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bee:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000bf2:	60fb      	str	r3, [r7, #12]
70000bf4:	68fb      	ldr	r3, [r7, #12]
    __HAL_RCC_GPIOO_CLK_ENABLE();
70000bf6:	4b1e      	ldr	r3, [pc, #120]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bf8:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000bfc:	4a1c      	ldr	r2, [pc, #112]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000bfe:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
70000c02:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70000c06:	4b1a      	ldr	r3, [pc, #104]	@ (70000c70 <HAL_XSPI_MspInit+0x114>)
70000c08:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70000c0c:	60bb      	str	r3, [r7, #8]
70000c0e:	68bb      	ldr	r3, [r7, #8]
    PP1     ------> XSPIM_P1_IO1
    PP4     ------> XSPIM_P1_IO4
    PO4     ------> XSPIM_P1_CLK
    PP6     ------> XSPIM_P1_IO6
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_0|GPIO_PIN_7
70000c10:	23ff      	movs	r3, #255	@ 0xff
70000c12:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
                          |GPIO_PIN_5|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_6;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
70000c16:	2302      	movs	r3, #2
70000c18:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
70000c1c:	2300      	movs	r3, #0
70000c1e:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
70000c22:	2303      	movs	r3, #3
70000c24:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
70000c28:	2309      	movs	r3, #9
70000c2a:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    HAL_GPIO_Init(GPIOP, &GPIO_InitStruct);
70000c2e:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
70000c32:	4619      	mov	r1, r3
70000c34:	480f      	ldr	r0, [pc, #60]	@ (70000c74 <HAL_XSPI_MspInit+0x118>)
70000c36:	f000 ff9f 	bl	70001b78 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4;
70000c3a:	2314      	movs	r3, #20
70000c3c:	f8c7 309c 	str.w	r3, [r7, #156]	@ 0x9c
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
70000c40:	2302      	movs	r3, #2
70000c42:	f8c7 30a0 	str.w	r3, [r7, #160]	@ 0xa0
    GPIO_InitStruct.Pull = GPIO_NOPULL;
70000c46:	2300      	movs	r3, #0
70000c48:	f8c7 30a4 	str.w	r3, [r7, #164]	@ 0xa4
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
70000c4c:	2303      	movs	r3, #3
70000c4e:	f8c7 30a8 	str.w	r3, [r7, #168]	@ 0xa8
    GPIO_InitStruct.Alternate = GPIO_AF9_XSPIM_P1;
70000c52:	2309      	movs	r3, #9
70000c54:	f8c7 30ac 	str.w	r3, [r7, #172]	@ 0xac
    HAL_GPIO_Init(GPIOO, &GPIO_InitStruct);
70000c58:	f107 039c 	add.w	r3, r7, #156	@ 0x9c
70000c5c:	4619      	mov	r1, r3
70000c5e:	4806      	ldr	r0, [pc, #24]	@ (70000c78 <HAL_XSPI_MspInit+0x11c>)
70000c60:	f000 ff8a 	bl	70001b78 <HAL_GPIO_Init>

    /* USER CODE END XSPI1_MspInit 1 */

  }

}
70000c64:	bf00      	nop
70000c66:	37b0      	adds	r7, #176	@ 0xb0
70000c68:	46bd      	mov	sp, r7
70000c6a:	bd80      	pop	{r7, pc}
70000c6c:	52005000 	.word	0x52005000
70000c70:	58024400 	.word	0x58024400
70000c74:	58023c00 	.word	0x58023c00
70000c78:	58023800 	.word	0x58023800

70000c7c <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
70000c7c:	b480      	push	{r7}
70000c7e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN NonMaskableInt_IRQn 0 */

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */
   while (1)
70000c80:	bf00      	nop
70000c82:	e7fd      	b.n	70000c80 <NMI_Handler+0x4>

70000c84 <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
70000c84:	b480      	push	{r7}
70000c86:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
70000c88:	bf00      	nop
70000c8a:	e7fd      	b.n	70000c88 <HardFault_Handler+0x4>

70000c8c <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
70000c8c:	b480      	push	{r7}
70000c8e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
70000c90:	bf00      	nop
70000c92:	e7fd      	b.n	70000c90 <MemManage_Handler+0x4>

70000c94 <BusFault_Handler>:

/**
  * @brief This function handles Pre-fetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
70000c94:	b480      	push	{r7}
70000c96:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
70000c98:	bf00      	nop
70000c9a:	e7fd      	b.n	70000c98 <BusFault_Handler+0x4>

70000c9c <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
70000c9c:	b480      	push	{r7}
70000c9e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
70000ca0:	bf00      	nop
70000ca2:	e7fd      	b.n	70000ca0 <UsageFault_Handler+0x4>

70000ca4 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
70000ca4:	b480      	push	{r7}
70000ca6:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
70000ca8:	bf00      	nop
70000caa:	46bd      	mov	sp, r7
70000cac:	f85d 7b04 	ldr.w	r7, [sp], #4
70000cb0:	4770      	bx	lr

70000cb2 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
70000cb2:	b480      	push	{r7}
70000cb4:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
70000cb6:	bf00      	nop
70000cb8:	46bd      	mov	sp, r7
70000cba:	f85d 7b04 	ldr.w	r7, [sp], #4
70000cbe:	4770      	bx	lr

70000cc0 <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
70000cc0:	b480      	push	{r7}
70000cc2:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
70000cc4:	bf00      	nop
70000cc6:	46bd      	mov	sp, r7
70000cc8:	f85d 7b04 	ldr.w	r7, [sp], #4
70000ccc:	4770      	bx	lr

70000cce <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
70000cce:	b580      	push	{r7, lr}
70000cd0:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
70000cd2:	f000 fd23 	bl	7000171c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
70000cd6:	bf00      	nop
70000cd8:	bd80      	pop	{r7, pc}

70000cda <EXTI13_IRQHandler>:

/**
  * @brief This function handles EXTI line13 interrupt.
  */
void EXTI13_IRQHandler(void)
{
70000cda:	b580      	push	{r7, lr}
70000cdc:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI13_IRQn 0 */

  /* USER CODE END EXTI13_IRQn 0 */
  BSP_PB_IRQHandler(BUTTON_USER);
70000cde:	2000      	movs	r0, #0
70000ce0:	f000 fb7c 	bl	700013dc <BSP_PB_IRQHandler>
  /* USER CODE BEGIN EXTI13_IRQn 1 */

  /* USER CODE END EXTI13_IRQn 1 */
}
70000ce4:	bf00      	nop
70000ce6:	bd80      	pop	{r7, pc}

70000ce8 <_read>:
  _kill(status, -1);
  while (1) {}    /* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
70000ce8:	b580      	push	{r7, lr}
70000cea:	b086      	sub	sp, #24
70000cec:	af00      	add	r7, sp, #0
70000cee:	60f8      	str	r0, [r7, #12]
70000cf0:	60b9      	str	r1, [r7, #8]
70000cf2:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
70000cf4:	2300      	movs	r3, #0
70000cf6:	617b      	str	r3, [r7, #20]
70000cf8:	e00a      	b.n	70000d10 <_read+0x28>
  {
    *ptr++ = __io_getchar();
70000cfa:	f3af 8000 	nop.w
70000cfe:	4601      	mov	r1, r0
70000d00:	68bb      	ldr	r3, [r7, #8]
70000d02:	1c5a      	adds	r2, r3, #1
70000d04:	60ba      	str	r2, [r7, #8]
70000d06:	b2ca      	uxtb	r2, r1
70000d08:	701a      	strb	r2, [r3, #0]
  for (DataIdx = 0; DataIdx < len; DataIdx++)
70000d0a:	697b      	ldr	r3, [r7, #20]
70000d0c:	3301      	adds	r3, #1
70000d0e:	617b      	str	r3, [r7, #20]
70000d10:	697a      	ldr	r2, [r7, #20]
70000d12:	687b      	ldr	r3, [r7, #4]
70000d14:	429a      	cmp	r2, r3
70000d16:	dbf0      	blt.n	70000cfa <_read+0x12>
  }

  return len;
70000d18:	687b      	ldr	r3, [r7, #4]
}
70000d1a:	4618      	mov	r0, r3
70000d1c:	3718      	adds	r7, #24
70000d1e:	46bd      	mov	sp, r7
70000d20:	bd80      	pop	{r7, pc}

70000d22 <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
70000d22:	b580      	push	{r7, lr}
70000d24:	b086      	sub	sp, #24
70000d26:	af00      	add	r7, sp, #0
70000d28:	60f8      	str	r0, [r7, #12]
70000d2a:	60b9      	str	r1, [r7, #8]
70000d2c:	607a      	str	r2, [r7, #4]
  (void)file;
  int DataIdx;

  for (DataIdx = 0; DataIdx < len; DataIdx++)
70000d2e:	2300      	movs	r3, #0
70000d30:	617b      	str	r3, [r7, #20]
70000d32:	e009      	b.n	70000d48 <_write+0x26>
  {
    __io_putchar(*ptr++);
70000d34:	68bb      	ldr	r3, [r7, #8]
70000d36:	1c5a      	adds	r2, r3, #1
70000d38:	60ba      	str	r2, [r7, #8]
70000d3a:	781b      	ldrb	r3, [r3, #0]
70000d3c:	4618      	mov	r0, r3
70000d3e:	f000 fbaf 	bl	700014a0 <__io_putchar>
  for (DataIdx = 0; DataIdx < len; DataIdx++)
70000d42:	697b      	ldr	r3, [r7, #20]
70000d44:	3301      	adds	r3, #1
70000d46:	617b      	str	r3, [r7, #20]
70000d48:	697a      	ldr	r2, [r7, #20]
70000d4a:	687b      	ldr	r3, [r7, #4]
70000d4c:	429a      	cmp	r2, r3
70000d4e:	dbf1      	blt.n	70000d34 <_write+0x12>
  }
  return len;
70000d50:	687b      	ldr	r3, [r7, #4]
}
70000d52:	4618      	mov	r0, r3
70000d54:	3718      	adds	r7, #24
70000d56:	46bd      	mov	sp, r7
70000d58:	bd80      	pop	{r7, pc}

70000d5a <_close>:

int _close(int file)
{
70000d5a:	b480      	push	{r7}
70000d5c:	b083      	sub	sp, #12
70000d5e:	af00      	add	r7, sp, #0
70000d60:	6078      	str	r0, [r7, #4]
  (void)file;
  return -1;
70000d62:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
}
70000d66:	4618      	mov	r0, r3
70000d68:	370c      	adds	r7, #12
70000d6a:	46bd      	mov	sp, r7
70000d6c:	f85d 7b04 	ldr.w	r7, [sp], #4
70000d70:	4770      	bx	lr

70000d72 <_fstat>:


int _fstat(int file, struct stat *st)
{
70000d72:	b480      	push	{r7}
70000d74:	b083      	sub	sp, #12
70000d76:	af00      	add	r7, sp, #0
70000d78:	6078      	str	r0, [r7, #4]
70000d7a:	6039      	str	r1, [r7, #0]
  (void)file;
  st->st_mode = S_IFCHR;
70000d7c:	683b      	ldr	r3, [r7, #0]
70000d7e:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
70000d82:	605a      	str	r2, [r3, #4]
  return 0;
70000d84:	2300      	movs	r3, #0
}
70000d86:	4618      	mov	r0, r3
70000d88:	370c      	adds	r7, #12
70000d8a:	46bd      	mov	sp, r7
70000d8c:	f85d 7b04 	ldr.w	r7, [sp], #4
70000d90:	4770      	bx	lr

70000d92 <_isatty>:

int _isatty(int file)
{
70000d92:	b480      	push	{r7}
70000d94:	b083      	sub	sp, #12
70000d96:	af00      	add	r7, sp, #0
70000d98:	6078      	str	r0, [r7, #4]
  (void)file;
  return 1;
70000d9a:	2301      	movs	r3, #1
}
70000d9c:	4618      	mov	r0, r3
70000d9e:	370c      	adds	r7, #12
70000da0:	46bd      	mov	sp, r7
70000da2:	f85d 7b04 	ldr.w	r7, [sp], #4
70000da6:	4770      	bx	lr

70000da8 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
70000da8:	b480      	push	{r7}
70000daa:	b085      	sub	sp, #20
70000dac:	af00      	add	r7, sp, #0
70000dae:	60f8      	str	r0, [r7, #12]
70000db0:	60b9      	str	r1, [r7, #8]
70000db2:	607a      	str	r2, [r7, #4]
  (void)file;
  (void)ptr;
  (void)dir;
  return 0;
70000db4:	2300      	movs	r3, #0
}
70000db6:	4618      	mov	r0, r3
70000db8:	3714      	adds	r7, #20
70000dba:	46bd      	mov	sp, r7
70000dbc:	f85d 7b04 	ldr.w	r7, [sp], #4
70000dc0:	4770      	bx	lr
	...

70000dc4 <_sbrk>:
 *
 * @param incr Memory size
 * @return Pointer to allocated memory
 */
void *_sbrk(ptrdiff_t incr)
{
70000dc4:	b580      	push	{r7, lr}
70000dc6:	b086      	sub	sp, #24
70000dc8:	af00      	add	r7, sp, #0
70000dca:	6078      	str	r0, [r7, #4]
  extern uint8_t _end; /* Symbol defined in the linker script */
  extern uint8_t _estack; /* Symbol defined in the linker script */
  extern uint32_t _Min_Stack_Size; /* Symbol defined in the linker script */
  const uint32_t stack_limit = (uint32_t)&_estack - (uint32_t)&_Min_Stack_Size;
70000dcc:	4a14      	ldr	r2, [pc, #80]	@ (70000e20 <_sbrk+0x5c>)
70000dce:	4b15      	ldr	r3, [pc, #84]	@ (70000e24 <_sbrk+0x60>)
70000dd0:	1ad3      	subs	r3, r2, r3
70000dd2:	617b      	str	r3, [r7, #20]
  const uint8_t *max_heap = (uint8_t *)stack_limit;
70000dd4:	697b      	ldr	r3, [r7, #20]
70000dd6:	613b      	str	r3, [r7, #16]
  uint8_t *prev_heap_end;

  /* Initialize heap end at first call */
  if (NULL == __sbrk_heap_end)
70000dd8:	4b13      	ldr	r3, [pc, #76]	@ (70000e28 <_sbrk+0x64>)
70000dda:	681b      	ldr	r3, [r3, #0]
70000ddc:	2b00      	cmp	r3, #0
70000dde:	d102      	bne.n	70000de6 <_sbrk+0x22>
  {
    __sbrk_heap_end = &_end;
70000de0:	4b11      	ldr	r3, [pc, #68]	@ (70000e28 <_sbrk+0x64>)
70000de2:	4a12      	ldr	r2, [pc, #72]	@ (70000e2c <_sbrk+0x68>)
70000de4:	601a      	str	r2, [r3, #0]
  }

  /* Protect heap from growing into the reserved MSP stack */
  if (__sbrk_heap_end + incr > max_heap)
70000de6:	4b10      	ldr	r3, [pc, #64]	@ (70000e28 <_sbrk+0x64>)
70000de8:	681a      	ldr	r2, [r3, #0]
70000dea:	687b      	ldr	r3, [r7, #4]
70000dec:	4413      	add	r3, r2
70000dee:	693a      	ldr	r2, [r7, #16]
70000df0:	429a      	cmp	r2, r3
70000df2:	d207      	bcs.n	70000e04 <_sbrk+0x40>
  {
    errno = ENOMEM;
70000df4:	f008 fa12 	bl	7000921c <__errno>
70000df8:	4603      	mov	r3, r0
70000dfa:	220c      	movs	r2, #12
70000dfc:	601a      	str	r2, [r3, #0]
    return (void *)-1;
70000dfe:	f04f 33ff 	mov.w	r3, #4294967295	@ 0xffffffff
70000e02:	e009      	b.n	70000e18 <_sbrk+0x54>
  }

  prev_heap_end = __sbrk_heap_end;
70000e04:	4b08      	ldr	r3, [pc, #32]	@ (70000e28 <_sbrk+0x64>)
70000e06:	681b      	ldr	r3, [r3, #0]
70000e08:	60fb      	str	r3, [r7, #12]
  __sbrk_heap_end += incr;
70000e0a:	4b07      	ldr	r3, [pc, #28]	@ (70000e28 <_sbrk+0x64>)
70000e0c:	681a      	ldr	r2, [r3, #0]
70000e0e:	687b      	ldr	r3, [r7, #4]
70000e10:	4413      	add	r3, r2
70000e12:	4a05      	ldr	r2, [pc, #20]	@ (70000e28 <_sbrk+0x64>)
70000e14:	6013      	str	r3, [r2, #0]

  return (void *)prev_heap_end;
70000e16:	68fb      	ldr	r3, [r7, #12]
}
70000e18:	4618      	mov	r0, r3
70000e1a:	3718      	adds	r7, #24
70000e1c:	46bd      	mov	sp, r7
70000e1e:	bd80      	pop	{r7, pc}
70000e20:	20010000 	.word	0x20010000
70000e24:	00000400 	.word	0x00000400
70000e28:	240001b0 	.word	0x240001b0
70000e2c:	20000000 	.word	0x20000000

70000e30 <SystemInit>:
  * @brief  Setup the microcontroller system.
  * @retval None
  */

void SystemInit(void)
{
70000e30:	b480      	push	{r7}
70000e32:	af00      	add	r7, sp, #0
  /* Configure the Vector Table location -------------------------------------*/
  SCB->VTOR = INTVECT_START;
70000e34:	4b07      	ldr	r3, [pc, #28]	@ (70000e54 <SystemInit+0x24>)
70000e36:	4a08      	ldr	r2, [pc, #32]	@ (70000e58 <SystemInit+0x28>)
70000e38:	609a      	str	r2, [r3, #8]

  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 20U)|(3UL << 22U));  /* set CP10 and CP11 Full Access */
70000e3a:	4b06      	ldr	r3, [pc, #24]	@ (70000e54 <SystemInit+0x24>)
70000e3c:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
70000e40:	4a04      	ldr	r2, [pc, #16]	@ (70000e54 <SystemInit+0x24>)
70000e42:	f443 0370 	orr.w	r3, r3, #15728640	@ 0xf00000
70000e46:	f8c2 3088 	str.w	r3, [r2, #136]	@ 0x88
#endif
}
70000e4a:	bf00      	nop
70000e4c:	46bd      	mov	sp, r7
70000e4e:	f85d 7b04 	ldr.w	r7, [sp], #4
70000e52:	4770      	bx	lr
70000e54:	e000ed00 	.word	0xe000ed00
70000e58:	70000028 	.word	0x70000028

70000e5c <SystemCoreClockUpdate>:
  *           value for HSE crystal.
  *
  * @retval None
  */
void SystemCoreClockUpdate(void)
{
70000e5c:	b480      	push	{r7}
70000e5e:	b089      	sub	sp, #36	@ 0x24
70000e60:	af00      	add	r7, sp, #0
  uint32_t sysclk, hsivalue, pllsource, pllm, pllp, core_presc;
  float_t pllfracn, pllvco;

  /* Get SYSCLK source -------------------------------------------------------*/
  switch (RCC->CFGR & RCC_CFGR_SWS)
70000e62:	4b92      	ldr	r3, [pc, #584]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000e64:	691b      	ldr	r3, [r3, #16]
70000e66:	f003 0338 	and.w	r3, r3, #56	@ 0x38
70000e6a:	2b18      	cmp	r3, #24
70000e6c:	f200 80fb 	bhi.w	70001066 <SystemCoreClockUpdate+0x20a>
70000e70:	a201      	add	r2, pc, #4	@ (adr r2, 70000e78 <SystemCoreClockUpdate+0x1c>)
70000e72:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70000e76:	bf00      	nop
70000e78:	70000edd 	.word	0x70000edd
70000e7c:	70001067 	.word	0x70001067
70000e80:	70001067 	.word	0x70001067
70000e84:	70001067 	.word	0x70001067
70000e88:	70001067 	.word	0x70001067
70000e8c:	70001067 	.word	0x70001067
70000e90:	70001067 	.word	0x70001067
70000e94:	70001067 	.word	0x70001067
70000e98:	70000ef1 	.word	0x70000ef1
70000e9c:	70001067 	.word	0x70001067
70000ea0:	70001067 	.word	0x70001067
70000ea4:	70001067 	.word	0x70001067
70000ea8:	70001067 	.word	0x70001067
70000eac:	70001067 	.word	0x70001067
70000eb0:	70001067 	.word	0x70001067
70000eb4:	70001067 	.word	0x70001067
70000eb8:	70000ef7 	.word	0x70000ef7
70000ebc:	70001067 	.word	0x70001067
70000ec0:	70001067 	.word	0x70001067
70000ec4:	70001067 	.word	0x70001067
70000ec8:	70001067 	.word	0x70001067
70000ecc:	70001067 	.word	0x70001067
70000ed0:	70001067 	.word	0x70001067
70000ed4:	70001067 	.word	0x70001067
70000ed8:	70000efd 	.word	0x70000efd
  {
  case 0x00:  /* HSI used as system clock source (default after reset) */
    sysclk = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
70000edc:	4b73      	ldr	r3, [pc, #460]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000ede:	681b      	ldr	r3, [r3, #0]
70000ee0:	08db      	lsrs	r3, r3, #3
70000ee2:	f003 0303 	and.w	r3, r3, #3
70000ee6:	4a72      	ldr	r2, [pc, #456]	@ (700010b0 <SystemCoreClockUpdate+0x254>)
70000ee8:	fa22 f303 	lsr.w	r3, r2, r3
70000eec:	61fb      	str	r3, [r7, #28]
    break;
70000eee:	e0c4      	b.n	7000107a <SystemCoreClockUpdate+0x21e>

  case 0x08:  /* CSI used as system clock source */
    sysclk = CSI_VALUE;
70000ef0:	4b70      	ldr	r3, [pc, #448]	@ (700010b4 <SystemCoreClockUpdate+0x258>)
70000ef2:	61fb      	str	r3, [r7, #28]
    break;
70000ef4:	e0c1      	b.n	7000107a <SystemCoreClockUpdate+0x21e>

  case 0x10:  /* HSE used as system clock source */
    sysclk = HSE_VALUE;
70000ef6:	4b70      	ldr	r3, [pc, #448]	@ (700010b8 <SystemCoreClockUpdate+0x25c>)
70000ef8:	61fb      	str	r3, [r7, #28]
    break;
70000efa:	e0be      	b.n	7000107a <SystemCoreClockUpdate+0x21e>

  case 0x18:  /* PLL1 used as system clock  source */
    /* PLL1_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
       SYSCLK = PLL1_VCO / PLL1R
       */
    pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
70000efc:	4b6b      	ldr	r3, [pc, #428]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000efe:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70000f00:	f003 0303 	and.w	r3, r3, #3
70000f04:	613b      	str	r3, [r7, #16]
    pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos)  ;
70000f06:	4b69      	ldr	r3, [pc, #420]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000f08:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70000f0a:	091b      	lsrs	r3, r3, #4
70000f0c:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70000f10:	60fb      	str	r3, [r7, #12]
    if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) != 0U)
70000f12:	4b66      	ldr	r3, [pc, #408]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000f14:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70000f16:	f003 0301 	and.w	r3, r3, #1
70000f1a:	2b00      	cmp	r3, #0
70000f1c:	d00b      	beq.n	70000f36 <SystemCoreClockUpdate+0xda>
    {
      pllfracn = (float_t)(uint32_t)(((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN)>> RCC_PLL1FRACR_FRACN_Pos));
70000f1e:	4b63      	ldr	r3, [pc, #396]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000f20:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
70000f22:	08db      	lsrs	r3, r3, #3
70000f24:	f3c3 030c 	ubfx	r3, r3, #0, #13
70000f28:	ee07 3a90 	vmov	s15, r3
70000f2c:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000f30:	edc7 7a06 	vstr	s15, [r7, #24]
70000f34:	e002      	b.n	70000f3c <SystemCoreClockUpdate+0xe0>
    }
    else
    {
      pllfracn = (float_t)0U;
70000f36:	f04f 0300 	mov.w	r3, #0
70000f3a:	61bb      	str	r3, [r7, #24]
    }

    if (pllm != 0U)
70000f3c:	68fb      	ldr	r3, [r7, #12]
70000f3e:	2b00      	cmp	r3, #0
70000f40:	f000 808e 	beq.w	70001060 <SystemCoreClockUpdate+0x204>
    {
      switch (pllsource)
70000f44:	693b      	ldr	r3, [r7, #16]
70000f46:	2b01      	cmp	r3, #1
70000f48:	d024      	beq.n	70000f94 <SystemCoreClockUpdate+0x138>
70000f4a:	693b      	ldr	r3, [r7, #16]
70000f4c:	2b02      	cmp	r3, #2
70000f4e:	d143      	bne.n	70000fd8 <SystemCoreClockUpdate+0x17c>
      {
      case 0x02:  /* HSE used as PLL1 clock source */
        pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
70000f50:	68fb      	ldr	r3, [r7, #12]
70000f52:	ee07 3a90 	vmov	s15, r3
70000f56:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000f5a:	eddf 6a58 	vldr	s13, [pc, #352]	@ 700010bc <SystemCoreClockUpdate+0x260>
70000f5e:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70000f62:	4b52      	ldr	r3, [pc, #328]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000f64:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70000f66:	f3c3 0308 	ubfx	r3, r3, #0, #9
70000f6a:	ee07 3a90 	vmov	s15, r3
70000f6e:	eef8 6a67 	vcvt.f32.u32	s13, s15
70000f72:	ed97 6a06 	vldr	s12, [r7, #24]
70000f76:	eddf 5a52 	vldr	s11, [pc, #328]	@ 700010c0 <SystemCoreClockUpdate+0x264>
70000f7a:	eec6 7a25 	vdiv.f32	s15, s12, s11
70000f7e:	ee76 7aa7 	vadd.f32	s15, s13, s15
70000f82:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70000f86:	ee77 7aa6 	vadd.f32	s15, s15, s13
70000f8a:	ee67 7a27 	vmul.f32	s15, s14, s15
70000f8e:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
70000f92:	e04f      	b.n	70001034 <SystemCoreClockUpdate+0x1d8>

      case 0x01:  /* CSI used as PLL1 clock source */
        pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
70000f94:	68fb      	ldr	r3, [r7, #12]
70000f96:	ee07 3a90 	vmov	s15, r3
70000f9a:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000f9e:	eddf 6a49 	vldr	s13, [pc, #292]	@ 700010c4 <SystemCoreClockUpdate+0x268>
70000fa2:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70000fa6:	4b41      	ldr	r3, [pc, #260]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000fa8:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70000faa:	f3c3 0308 	ubfx	r3, r3, #0, #9
70000fae:	ee07 3a90 	vmov	s15, r3
70000fb2:	eef8 6a67 	vcvt.f32.u32	s13, s15
70000fb6:	ed97 6a06 	vldr	s12, [r7, #24]
70000fba:	eddf 5a41 	vldr	s11, [pc, #260]	@ 700010c0 <SystemCoreClockUpdate+0x264>
70000fbe:	eec6 7a25 	vdiv.f32	s15, s12, s11
70000fc2:	ee76 7aa7 	vadd.f32	s15, s13, s15
70000fc6:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70000fca:	ee77 7aa6 	vadd.f32	s15, s15, s13
70000fce:	ee67 7a27 	vmul.f32	s15, s14, s15
70000fd2:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
70000fd6:	e02d      	b.n	70001034 <SystemCoreClockUpdate+0x1d8>

      case 0x00:  /* HSI used as PLL1 clock source */
      default:
        hsivalue = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
70000fd8:	4b34      	ldr	r3, [pc, #208]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70000fda:	681b      	ldr	r3, [r3, #0]
70000fdc:	08db      	lsrs	r3, r3, #3
70000fde:	f003 0303 	and.w	r3, r3, #3
70000fe2:	4a33      	ldr	r2, [pc, #204]	@ (700010b0 <SystemCoreClockUpdate+0x254>)
70000fe4:	fa22 f303 	lsr.w	r3, r2, r3
70000fe8:	60bb      	str	r3, [r7, #8]
        pllvco = ( (float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (pllfracn/(float_t)0x2000) +(float_t)1 );
70000fea:	68bb      	ldr	r3, [r7, #8]
70000fec:	ee07 3a90 	vmov	s15, r3
70000ff0:	eef8 6a67 	vcvt.f32.u32	s13, s15
70000ff4:	68fb      	ldr	r3, [r7, #12]
70000ff6:	ee07 3a90 	vmov	s15, r3
70000ffa:	eef8 7a67 	vcvt.f32.u32	s15, s15
70000ffe:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70001002:	4b2a      	ldr	r3, [pc, #168]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70001004:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70001006:	f3c3 0308 	ubfx	r3, r3, #0, #9
7000100a:	ee07 3a90 	vmov	s15, r3
7000100e:	eef8 6a67 	vcvt.f32.u32	s13, s15
70001012:	ed97 6a06 	vldr	s12, [r7, #24]
70001016:	eddf 5a2a 	vldr	s11, [pc, #168]	@ 700010c0 <SystemCoreClockUpdate+0x264>
7000101a:	eec6 7a25 	vdiv.f32	s15, s12, s11
7000101e:	ee76 7aa7 	vadd.f32	s15, s13, s15
70001022:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70001026:	ee77 7aa6 	vadd.f32	s15, s15, s13
7000102a:	ee67 7a27 	vmul.f32	s15, s14, s15
7000102e:	edc7 7a05 	vstr	s15, [r7, #20]
        break;
70001032:	bf00      	nop
      }
      pllp = (((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVP) >> RCC_PLL1DIVR1_DIVP_Pos) + 1U ) ;
70001034:	4b1d      	ldr	r3, [pc, #116]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70001036:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70001038:	0a5b      	lsrs	r3, r3, #9
7000103a:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
7000103e:	3301      	adds	r3, #1
70001040:	607b      	str	r3, [r7, #4]
      sysclk =  (uint32_t)(float_t)(pllvco/(float_t)pllp);
70001042:	687b      	ldr	r3, [r7, #4]
70001044:	ee07 3a90 	vmov	s15, r3
70001048:	eeb8 7a67 	vcvt.f32.u32	s14, s15
7000104c:	edd7 6a05 	vldr	s13, [r7, #20]
70001050:	eec6 7a87 	vdiv.f32	s15, s13, s14
70001054:	eefc 7ae7 	vcvt.u32.f32	s15, s15
70001058:	ee17 3a90 	vmov	r3, s15
7000105c:	61fb      	str	r3, [r7, #28]
    }
    else
    {
      sysclk = 0U;
    }
    break;
7000105e:	e00c      	b.n	7000107a <SystemCoreClockUpdate+0x21e>
      sysclk = 0U;
70001060:	2300      	movs	r3, #0
70001062:	61fb      	str	r3, [r7, #28]
    break;
70001064:	e009      	b.n	7000107a <SystemCoreClockUpdate+0x21e>

  default:  /* Unexpected, default to HSI used as system clock source (default after reset) */
    sysclk = (HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos));
70001066:	4b11      	ldr	r3, [pc, #68]	@ (700010ac <SystemCoreClockUpdate+0x250>)
70001068:	681b      	ldr	r3, [r3, #0]
7000106a:	08db      	lsrs	r3, r3, #3
7000106c:	f003 0303 	and.w	r3, r3, #3
70001070:	4a0f      	ldr	r2, [pc, #60]	@ (700010b0 <SystemCoreClockUpdate+0x254>)
70001072:	fa22 f303 	lsr.w	r3, r2, r3
70001076:	61fb      	str	r3, [r7, #28]
    break;
70001078:	bf00      	nop
  }

  /* system clock frequency : CM7 CPU frequency  */
  core_presc = (RCC->CDCFGR & RCC_CDCFGR_CPRE);
7000107a:	4b0c      	ldr	r3, [pc, #48]	@ (700010ac <SystemCoreClockUpdate+0x250>)
7000107c:	699b      	ldr	r3, [r3, #24]
7000107e:	f003 030f 	and.w	r3, r3, #15
70001082:	603b      	str	r3, [r7, #0]
  if (core_presc >= 8U)
70001084:	683b      	ldr	r3, [r7, #0]
70001086:	2b07      	cmp	r3, #7
70001088:	d907      	bls.n	7000109a <SystemCoreClockUpdate+0x23e>
  {
    SystemCoreClock = (sysclk >> (core_presc - RCC_CDCFGR_CPRE_3 + 1U));
7000108a:	683b      	ldr	r3, [r7, #0]
7000108c:	3b07      	subs	r3, #7
7000108e:	69fa      	ldr	r2, [r7, #28]
70001090:	fa22 f303 	lsr.w	r3, r2, r3
70001094:	4a0c      	ldr	r2, [pc, #48]	@ (700010c8 <SystemCoreClockUpdate+0x26c>)
70001096:	6013      	str	r3, [r2, #0]
  }
  else
  {
    SystemCoreClock = sysclk;
  }
}
70001098:	e002      	b.n	700010a0 <SystemCoreClockUpdate+0x244>
    SystemCoreClock = sysclk;
7000109a:	4a0b      	ldr	r2, [pc, #44]	@ (700010c8 <SystemCoreClockUpdate+0x26c>)
7000109c:	69fb      	ldr	r3, [r7, #28]
7000109e:	6013      	str	r3, [r2, #0]
}
700010a0:	bf00      	nop
700010a2:	3724      	adds	r7, #36	@ 0x24
700010a4:	46bd      	mov	sp, r7
700010a6:	f85d 7b04 	ldr.w	r7, [sp], #4
700010aa:	4770      	bx	lr
700010ac:	58024400 	.word	0x58024400
700010b0:	03d09000 	.word	0x03d09000
700010b4:	003d0900 	.word	0x003d0900
700010b8:	016e3600 	.word	0x016e3600
700010bc:	4bb71b00 	.word	0x4bb71b00
700010c0:	46000000 	.word	0x46000000
700010c4:	4a742400 	.word	0x4a742400
700010c8:	24000004 	.word	0x24000004

700010cc <Reset_Handler>:

    .section  .text.Reset_Handler
  .weak  Reset_Handler
  .type  Reset_Handler, %function
Reset_Handler:
  ldr   r0, =_estack
700010cc:	480d      	ldr	r0, [pc, #52]	@ (70001104 <LoopForever+0x2>)
  mov   sp, r0          /* set stack pointer */
700010ce:	4685      	mov	sp, r0
/* Call the clock system initialization function.*/
  bl  SystemInit
700010d0:	f7ff feae 	bl	70000e30 <SystemInit>

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
700010d4:	480c      	ldr	r0, [pc, #48]	@ (70001108 <LoopForever+0x6>)
  ldr r1, =_edata
700010d6:	490d      	ldr	r1, [pc, #52]	@ (7000110c <LoopForever+0xa>)
  ldr r2, =_sidata
700010d8:	4a0d      	ldr	r2, [pc, #52]	@ (70001110 <LoopForever+0xe>)
  movs r3, #0
700010da:	2300      	movs	r3, #0
  b LoopCopyDataInit
700010dc:	e002      	b.n	700010e4 <LoopCopyDataInit>

700010de <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
700010de:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
700010e0:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
700010e2:	3304      	adds	r3, #4

700010e4 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
700010e4:	18c4      	adds	r4, r0, r3
  cmp r4, r1
700010e6:	428c      	cmp	r4, r1
  bcc CopyDataInit
700010e8:	d3f9      	bcc.n	700010de <CopyDataInit>

/* Zero fill the bss segment. */
  ldr r2, =_sbss
700010ea:	4a0a      	ldr	r2, [pc, #40]	@ (70001114 <LoopForever+0x12>)
  ldr r4, =_ebss
700010ec:	4c0a      	ldr	r4, [pc, #40]	@ (70001118 <LoopForever+0x16>)
  movs r3, #0
700010ee:	2300      	movs	r3, #0
  b LoopFillZerobss
700010f0:	e001      	b.n	700010f6 <LoopFillZerobss>

700010f2 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
700010f2:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
700010f4:	3204      	adds	r2, #4

700010f6 <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
700010f6:	42a2      	cmp	r2, r4
  bcc FillZerobss
700010f8:	d3fb      	bcc.n	700010f2 <FillZerobss>

/* Call static constructors */
    bl __libc_init_array
700010fa:	f008 f895 	bl	70009228 <__libc_init_array>
/* Call the application's entry point.*/
  bl  main
700010fe:	f7ff fb17 	bl	70000730 <main>

70001102 <LoopForever>:

LoopForever:
  b LoopForever
70001102:	e7fe      	b.n	70001102 <LoopForever>
  ldr   r0, =_estack
70001104:	20010000 	.word	0x20010000
  ldr r0, =_sdata
70001108:	24000000 	.word	0x24000000
  ldr r1, =_edata
7000110c:	24000090 	.word	0x24000090
  ldr r2, =_sidata
70001110:	70009ed8 	.word	0x70009ed8
  ldr r2, =_sbss
70001114:	24000090 	.word	0x24000090
  ldr r4, =_ebss
70001118:	240005d8 	.word	0x240005d8

7000111c <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section  .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b  Infinite_Loop
7000111c:	e7fe      	b.n	7000111c <ADC1_2_IRQHandler>
	...

70001120 <BSP_LED_Init>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code
  */
int32_t BSP_LED_Init(Led_TypeDef Led)
{
70001120:	b580      	push	{r7, lr}
70001122:	b08c      	sub	sp, #48	@ 0x30
70001124:	af00      	add	r7, sp, #0
70001126:	4603      	mov	r3, r0
70001128:	71fb      	strb	r3, [r7, #7]
  int32_t ret = BSP_ERROR_NONE;
7000112a:	2300      	movs	r3, #0
7000112c:	62fb      	str	r3, [r7, #44]	@ 0x2c
  GPIO_InitTypeDef GPIO_Init = {0};
7000112e:	f107 0318 	add.w	r3, r7, #24
70001132:	2200      	movs	r2, #0
70001134:	601a      	str	r2, [r3, #0]
70001136:	605a      	str	r2, [r3, #4]
70001138:	609a      	str	r2, [r3, #8]
7000113a:	60da      	str	r2, [r3, #12]
7000113c:	611a      	str	r2, [r3, #16]

  /* Enable the GPIO_LED Clock */
  if (Led == LD1)
7000113e:	79fb      	ldrb	r3, [r7, #7]
70001140:	2b00      	cmp	r3, #0
70001142:	d10d      	bne.n	70001160 <BSP_LED_Init+0x40>
  {
    LD1_GPIO_CLK_ENABLE();
70001144:	4b24      	ldr	r3, [pc, #144]	@ (700011d8 <BSP_LED_Init+0xb8>)
70001146:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000114a:	4a23      	ldr	r2, [pc, #140]	@ (700011d8 <BSP_LED_Init+0xb8>)
7000114c:	f043 0308 	orr.w	r3, r3, #8
70001150:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70001154:	4b20      	ldr	r3, [pc, #128]	@ (700011d8 <BSP_LED_Init+0xb8>)
70001156:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000115a:	617b      	str	r3, [r7, #20]
7000115c:	697b      	ldr	r3, [r7, #20]
7000115e:	e01d      	b.n	7000119c <BSP_LED_Init+0x7c>
  }
  else if (Led == LD2)
70001160:	79fb      	ldrb	r3, [r7, #7]
70001162:	2b01      	cmp	r3, #1
70001164:	d10d      	bne.n	70001182 <BSP_LED_Init+0x62>
  {
    LD2_GPIO_CLK_ENABLE();
70001166:	4b1c      	ldr	r3, [pc, #112]	@ (700011d8 <BSP_LED_Init+0xb8>)
70001168:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000116c:	4a1a      	ldr	r2, [pc, #104]	@ (700011d8 <BSP_LED_Init+0xb8>)
7000116e:	f043 0308 	orr.w	r3, r3, #8
70001172:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70001176:	4b18      	ldr	r3, [pc, #96]	@ (700011d8 <BSP_LED_Init+0xb8>)
70001178:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000117c:	613b      	str	r3, [r7, #16]
7000117e:	693b      	ldr	r3, [r7, #16]
70001180:	e00c      	b.n	7000119c <BSP_LED_Init+0x7c>
  }
  else /* Led == LD3 */
  {
    LD3_GPIO_CLK_ENABLE();
70001182:	4b15      	ldr	r3, [pc, #84]	@ (700011d8 <BSP_LED_Init+0xb8>)
70001184:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70001188:	4a13      	ldr	r2, [pc, #76]	@ (700011d8 <BSP_LED_Init+0xb8>)
7000118a:	f043 0302 	orr.w	r3, r3, #2
7000118e:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
70001192:	4b11      	ldr	r3, [pc, #68]	@ (700011d8 <BSP_LED_Init+0xb8>)
70001194:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
70001198:	60fb      	str	r3, [r7, #12]
7000119a:	68fb      	ldr	r3, [r7, #12]
  }

  /* configure the GPIO_LED pin */
  GPIO_Init.Pin   = LED_PIN[Led];
7000119c:	79fb      	ldrb	r3, [r7, #7]
7000119e:	4a0f      	ldr	r2, [pc, #60]	@ (700011dc <BSP_LED_Init+0xbc>)
700011a0:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700011a4:	61bb      	str	r3, [r7, #24]
  GPIO_Init.Mode  = GPIO_MODE_OUTPUT_PP;
700011a6:	2301      	movs	r3, #1
700011a8:	61fb      	str	r3, [r7, #28]
  GPIO_Init.Pull  = GPIO_PULLUP;
700011aa:	2301      	movs	r3, #1
700011ac:	623b      	str	r3, [r7, #32]
  GPIO_Init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
700011ae:	2303      	movs	r3, #3
700011b0:	627b      	str	r3, [r7, #36]	@ 0x24
  HAL_GPIO_Init(LED_PORT[Led], &GPIO_Init);
700011b2:	79fb      	ldrb	r3, [r7, #7]
700011b4:	4a0a      	ldr	r2, [pc, #40]	@ (700011e0 <BSP_LED_Init+0xc0>)
700011b6:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
700011ba:	f107 0218 	add.w	r2, r7, #24
700011be:	4611      	mov	r1, r2
700011c0:	4618      	mov	r0, r3
700011c2:	f000 fcd9 	bl	70001b78 <HAL_GPIO_Init>

  /* By default, turn off LED */
  (void) BSP_LED_Off(Led);
700011c6:	79fb      	ldrb	r3, [r7, #7]
700011c8:	4618      	mov	r0, r3
700011ca:	f000 f825 	bl	70001218 <BSP_LED_Off>
  return ret;
700011ce:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
}
700011d0:	4618      	mov	r0, r3
700011d2:	3730      	adds	r7, #48	@ 0x30
700011d4:	46bd      	mov	sp, r7
700011d6:	bd80      	pop	{r7, pc}
700011d8:	58024400 	.word	0x58024400
700011dc:	24000008 	.word	0x24000008
700011e0:	24000010 	.word	0x24000010

700011e4 <BSP_LED_On>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code
  */
int32_t BSP_LED_On(Led_TypeDef Led)
{
700011e4:	b580      	push	{r7, lr}
700011e6:	b082      	sub	sp, #8
700011e8:	af00      	add	r7, sp, #0
700011ea:	4603      	mov	r3, r0
700011ec:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_SET);
700011ee:	79fb      	ldrb	r3, [r7, #7]
700011f0:	4a07      	ldr	r2, [pc, #28]	@ (70001210 <BSP_LED_On+0x2c>)
700011f2:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
700011f6:	79fb      	ldrb	r3, [r7, #7]
700011f8:	4a06      	ldr	r2, [pc, #24]	@ (70001214 <BSP_LED_On+0x30>)
700011fa:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700011fe:	2201      	movs	r2, #1
70001200:	4619      	mov	r1, r3
70001202:	f000 fe19 	bl	70001e38 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
70001206:	2300      	movs	r3, #0
}
70001208:	4618      	mov	r0, r3
7000120a:	3708      	adds	r7, #8
7000120c:	46bd      	mov	sp, r7
7000120e:	bd80      	pop	{r7, pc}
70001210:	24000010 	.word	0x24000010
70001214:	24000008 	.word	0x24000008

70001218 <BSP_LED_Off>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code
  */
int32_t BSP_LED_Off(Led_TypeDef Led)
{
70001218:	b580      	push	{r7, lr}
7000121a:	b082      	sub	sp, #8
7000121c:	af00      	add	r7, sp, #0
7000121e:	4603      	mov	r3, r0
70001220:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_WritePin(LED_PORT[Led], LED_PIN[Led], GPIO_PIN_RESET);
70001222:	79fb      	ldrb	r3, [r7, #7]
70001224:	4a07      	ldr	r2, [pc, #28]	@ (70001244 <BSP_LED_Off+0x2c>)
70001226:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
7000122a:	79fb      	ldrb	r3, [r7, #7]
7000122c:	4a06      	ldr	r2, [pc, #24]	@ (70001248 <BSP_LED_Off+0x30>)
7000122e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
70001232:	2200      	movs	r2, #0
70001234:	4619      	mov	r1, r3
70001236:	f000 fdff 	bl	70001e38 <HAL_GPIO_WritePin>

  return BSP_ERROR_NONE;
7000123a:	2300      	movs	r3, #0
}
7000123c:	4618      	mov	r0, r3
7000123e:	3708      	adds	r7, #8
70001240:	46bd      	mov	sp, r7
70001242:	bd80      	pop	{r7, pc}
70001244:	24000010 	.word	0x24000010
70001248:	24000008 	.word	0x24000008

7000124c <BSP_LED_Toggle>:
  *     @arg  LD2
  *     @arg  LD3
  * @retval BSP error code
  */
int32_t BSP_LED_Toggle(Led_TypeDef Led)
{
7000124c:	b580      	push	{r7, lr}
7000124e:	b082      	sub	sp, #8
70001250:	af00      	add	r7, sp, #0
70001252:	4603      	mov	r3, r0
70001254:	71fb      	strb	r3, [r7, #7]
  HAL_GPIO_TogglePin(LED_PORT[Led], LED_PIN[Led]);
70001256:	79fb      	ldrb	r3, [r7, #7]
70001258:	4a07      	ldr	r2, [pc, #28]	@ (70001278 <BSP_LED_Toggle+0x2c>)
7000125a:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
7000125e:	79fb      	ldrb	r3, [r7, #7]
70001260:	4906      	ldr	r1, [pc, #24]	@ (7000127c <BSP_LED_Toggle+0x30>)
70001262:	f831 3013 	ldrh.w	r3, [r1, r3, lsl #1]
70001266:	4619      	mov	r1, r3
70001268:	4610      	mov	r0, r2
7000126a:	f000 fdfd 	bl	70001e68 <HAL_GPIO_TogglePin>
  return BSP_ERROR_NONE;
7000126e:	2300      	movs	r3, #0
}
70001270:	4618      	mov	r0, r3
70001272:	3708      	adds	r7, #8
70001274:	46bd      	mov	sp, r7
70001276:	bd80      	pop	{r7, pc}
70001278:	24000010 	.word	0x24000010
7000127c:	24000008 	.word	0x24000008

70001280 <BSP_PB_Init>:
  *     @arg BUTTON_MODE_EXTI: Button will be connected to EXTI line with interrupt
  *                            generation capability
  * @retval BSP error code
  */
int32_t BSP_PB_Init(Button_TypeDef Button, ButtonMode_TypeDef ButtonMode)
{
70001280:	b580      	push	{r7, lr}
70001282:	b08e      	sub	sp, #56	@ 0x38
70001284:	af00      	add	r7, sp, #0
70001286:	4603      	mov	r3, r0
70001288:	460a      	mov	r2, r1
7000128a:	71fb      	strb	r3, [r7, #7]
7000128c:	4613      	mov	r3, r2
7000128e:	71bb      	strb	r3, [r7, #6]
  int32_t               status = BSP_ERROR_NONE;
70001290:	2300      	movs	r3, #0
70001292:	637b      	str	r3, [r7, #52]	@ 0x34
  GPIO_InitTypeDef      GPIO_Init = {0};
70001294:	f107 0320 	add.w	r3, r7, #32
70001298:	2200      	movs	r2, #0
7000129a:	601a      	str	r2, [r3, #0]
7000129c:	605a      	str	r2, [r3, #4]
7000129e:	609a      	str	r2, [r3, #8]
700012a0:	60da      	str	r2, [r3, #12]
700012a2:	611a      	str	r2, [r3, #16]
  uint32_t              BSP_BUTTON_IT_PRIO[BUTTONn] = {BSP_BUTTON_USER_IT_PRIORITY};
700012a4:	230f      	movs	r3, #15
700012a6:	61fb      	str	r3, [r7, #28]
  uint32_t              BUTTON_EXTI_LINE[BUTTONn]   = {BUTTON_USER_EXTI_LINE};
700012a8:	4b45      	ldr	r3, [pc, #276]	@ (700013c0 <BSP_PB_Init+0x140>)
700012aa:	61bb      	str	r3, [r7, #24]
  BSP_EXTI_LineCallback ButtonCallback[BUTTONn]     = {BUTTON_USER_EXTI_Callback};
700012ac:	4b45      	ldr	r3, [pc, #276]	@ (700013c4 <BSP_PB_Init+0x144>)
700012ae:	617b      	str	r3, [r7, #20]

  /* Enable the BUTTON clock */
  BUTTON_USER_GPIO_CLK_ENABLE();
700012b0:	4b45      	ldr	r3, [pc, #276]	@ (700013c8 <BSP_PB_Init+0x148>)
700012b2:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700012b6:	4a44      	ldr	r2, [pc, #272]	@ (700013c8 <BSP_PB_Init+0x148>)
700012b8:	f043 0304 	orr.w	r3, r3, #4
700012bc:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
700012c0:	4b41      	ldr	r3, [pc, #260]	@ (700013c8 <BSP_PB_Init+0x148>)
700012c2:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700012c6:	613b      	str	r3, [r7, #16]
700012c8:	693b      	ldr	r3, [r7, #16]

  GPIO_Init.Pin   = BUTTON_PIN[Button];
700012ca:	79fb      	ldrb	r3, [r7, #7]
700012cc:	4a3f      	ldr	r2, [pc, #252]	@ (700013cc <BSP_PB_Init+0x14c>)
700012ce:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700012d2:	623b      	str	r3, [r7, #32]
  GPIO_Init.Pull  = GPIO_PULLUP;
700012d4:	2301      	movs	r3, #1
700012d6:	62bb      	str	r3, [r7, #40]	@ 0x28
  GPIO_Init.Speed = GPIO_SPEED_FREQ_LOW;
700012d8:	2300      	movs	r3, #0
700012da:	62fb      	str	r3, [r7, #44]	@ 0x2c

  if (ButtonMode == BUTTON_MODE_GPIO)
700012dc:	79bb      	ldrb	r3, [r7, #6]
700012de:	2b00      	cmp	r3, #0
700012e0:	d10c      	bne.n	700012fc <BSP_PB_Init+0x7c>
  {
    /* Configure Button pin as input */
    GPIO_Init.Mode = GPIO_MODE_INPUT;
700012e2:	2300      	movs	r3, #0
700012e4:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
700012e6:	79fb      	ldrb	r3, [r7, #7]
700012e8:	4a39      	ldr	r2, [pc, #228]	@ (700013d0 <BSP_PB_Init+0x150>)
700012ea:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
700012ee:	f107 0220 	add.w	r2, r7, #32
700012f2:	4611      	mov	r1, r2
700012f4:	4618      	mov	r0, r3
700012f6:	f000 fc3f 	bl	70001b78 <HAL_GPIO_Init>
700012fa:	e058      	b.n	700013ae <BSP_PB_Init+0x12e>
  }
  else /* ButtonMode == BUTTON_MODE_EXTI */
  {
    /* Enable SBS clock */
    __HAL_RCC_SBS_CLK_ENABLE();
700012fc:	4b32      	ldr	r3, [pc, #200]	@ (700013c8 <BSP_PB_Init+0x148>)
700012fe:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
70001302:	4a31      	ldr	r2, [pc, #196]	@ (700013c8 <BSP_PB_Init+0x148>)
70001304:	f043 0302 	orr.w	r3, r3, #2
70001308:	f8c2 3154 	str.w	r3, [r2, #340]	@ 0x154
7000130c:	4b2e      	ldr	r3, [pc, #184]	@ (700013c8 <BSP_PB_Init+0x148>)
7000130e:	f8d3 3154 	ldr.w	r3, [r3, #340]	@ 0x154
70001312:	60fb      	str	r3, [r7, #12]
70001314:	68fb      	ldr	r3, [r7, #12]

    /* Configure Button pin as input with External interrupt */
    GPIO_Init.Mode = GPIO_MODE_IT_FALLING;
70001316:	f44f 1304 	mov.w	r3, #2162688	@ 0x210000
7000131a:	627b      	str	r3, [r7, #36]	@ 0x24
    HAL_GPIO_Init(BUTTON_PORT[Button], &GPIO_Init);
7000131c:	79fb      	ldrb	r3, [r7, #7]
7000131e:	4a2c      	ldr	r2, [pc, #176]	@ (700013d0 <BSP_PB_Init+0x150>)
70001320:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
70001324:	f107 0220 	add.w	r2, r7, #32
70001328:	4611      	mov	r1, r2
7000132a:	4618      	mov	r0, r3
7000132c:	f000 fc24 	bl	70001b78 <HAL_GPIO_Init>

    if (HAL_EXTI_GetHandle(&hpb_exti[Button], BUTTON_EXTI_LINE[Button]) == HAL_OK)
70001330:	79fb      	ldrb	r3, [r7, #7]
70001332:	00db      	lsls	r3, r3, #3
70001334:	4a27      	ldr	r2, [pc, #156]	@ (700013d4 <BSP_PB_Init+0x154>)
70001336:	441a      	add	r2, r3
70001338:	79fb      	ldrb	r3, [r7, #7]
7000133a:	009b      	lsls	r3, r3, #2
7000133c:	3338      	adds	r3, #56	@ 0x38
7000133e:	443b      	add	r3, r7
70001340:	f853 3c20 	ldr.w	r3, [r3, #-32]
70001344:	4619      	mov	r1, r3
70001346:	4610      	mov	r0, r2
70001348:	f000 fbd1 	bl	70001aee <HAL_EXTI_GetHandle>
7000134c:	4603      	mov	r3, r0
7000134e:	2b00      	cmp	r3, #0
70001350:	d12a      	bne.n	700013a8 <BSP_PB_Init+0x128>
    {
      if (HAL_EXTI_RegisterCallback(&hpb_exti[Button], HAL_EXTI_COMMON_CB_ID, ButtonCallback[Button]) == HAL_OK)
70001352:	79fb      	ldrb	r3, [r7, #7]
70001354:	00db      	lsls	r3, r3, #3
70001356:	4a1f      	ldr	r2, [pc, #124]	@ (700013d4 <BSP_PB_Init+0x154>)
70001358:	1898      	adds	r0, r3, r2
7000135a:	79fb      	ldrb	r3, [r7, #7]
7000135c:	009b      	lsls	r3, r3, #2
7000135e:	3338      	adds	r3, #56	@ 0x38
70001360:	443b      	add	r3, r7
70001362:	f853 3c24 	ldr.w	r3, [r3, #-36]
70001366:	461a      	mov	r2, r3
70001368:	2100      	movs	r1, #0
7000136a:	f000 fba6 	bl	70001aba <HAL_EXTI_RegisterCallback>
7000136e:	4603      	mov	r3, r0
70001370:	2b00      	cmp	r3, #0
70001372:	d115      	bne.n	700013a0 <BSP_PB_Init+0x120>
      {
        /* Enable and set Button EXTI Interrupt to the lowest priority */
        HAL_NVIC_SetPriority(BUTTON_IRQn[Button], BSP_BUTTON_IT_PRIO[Button], 0x00);
70001374:	79fb      	ldrb	r3, [r7, #7]
70001376:	4a18      	ldr	r2, [pc, #96]	@ (700013d8 <BSP_PB_Init+0x158>)
70001378:	f932 0013 	ldrsh.w	r0, [r2, r3, lsl #1]
7000137c:	79fb      	ldrb	r3, [r7, #7]
7000137e:	009b      	lsls	r3, r3, #2
70001380:	3338      	adds	r3, #56	@ 0x38
70001382:	443b      	add	r3, r7
70001384:	f853 3c1c 	ldr.w	r3, [r3, #-28]
70001388:	2200      	movs	r2, #0
7000138a:	4619      	mov	r1, r3
7000138c:	f000 fae5 	bl	7000195a <HAL_NVIC_SetPriority>
        HAL_NVIC_EnableIRQ(BUTTON_IRQn[Button]);
70001390:	79fb      	ldrb	r3, [r7, #7]
70001392:	4a11      	ldr	r2, [pc, #68]	@ (700013d8 <BSP_PB_Init+0x158>)
70001394:	f932 3013 	ldrsh.w	r3, [r2, r3, lsl #1]
70001398:	4618      	mov	r0, r3
7000139a:	f000 faf8 	bl	7000198e <HAL_NVIC_EnableIRQ>
7000139e:	e006      	b.n	700013ae <BSP_PB_Init+0x12e>
      }
      else
      {
        status = BSP_ERROR_PERIPH_FAILURE;
700013a0:	f06f 0303 	mvn.w	r3, #3
700013a4:	637b      	str	r3, [r7, #52]	@ 0x34
700013a6:	e002      	b.n	700013ae <BSP_PB_Init+0x12e>
      }
    }
    else
    {
      status = BSP_ERROR_PERIPH_FAILURE;
700013a8:	f06f 0303 	mvn.w	r3, #3
700013ac:	637b      	str	r3, [r7, #52]	@ 0x34
    }
  }

  /* Delay to avoid that possible signal rebound is taken as button release */
  HAL_Delay(1);
700013ae:	2001      	movs	r0, #1
700013b0:	f000 f9d4 	bl	7000175c <HAL_Delay>

  return status;
700013b4:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
}
700013b6:	4618      	mov	r0, r3
700013b8:	3738      	adds	r7, #56	@ 0x38
700013ba:	46bd      	mov	sp, r7
700013bc:	bd80      	pop	{r7, pc}
700013be:	bf00      	nop
700013c0:	1600000d 	.word	0x1600000d
700013c4:	700014d9 	.word	0x700014d9
700013c8:	58024400 	.word	0x58024400
700013cc:	2400001c 	.word	0x2400001c
700013d0:	24000020 	.word	0x24000020
700013d4:	24000248 	.word	0x24000248
700013d8:	24000024 	.word	0x24000024

700013dc <BSP_PB_IRQHandler>:
  *   This parameter should be:
  *     @arg BUTTON_USER
  * @retval None.
  */
void BSP_PB_IRQHandler(Button_TypeDef Button)
{
700013dc:	b580      	push	{r7, lr}
700013de:	b082      	sub	sp, #8
700013e0:	af00      	add	r7, sp, #0
700013e2:	4603      	mov	r3, r0
700013e4:	71fb      	strb	r3, [r7, #7]
  HAL_EXTI_IRQHandler(&hpb_exti[Button]);
700013e6:	79fb      	ldrb	r3, [r7, #7]
700013e8:	00db      	lsls	r3, r3, #3
700013ea:	4a04      	ldr	r2, [pc, #16]	@ (700013fc <BSP_PB_IRQHandler+0x20>)
700013ec:	4413      	add	r3, r2
700013ee:	4618      	mov	r0, r3
700013f0:	f000 fb92 	bl	70001b18 <HAL_EXTI_IRQHandler>
}
700013f4:	bf00      	nop
700013f6:	3708      	adds	r7, #8
700013f8:	46bd      	mov	sp, r7
700013fa:	bd80      	pop	{r7, pc}
700013fc:	24000248 	.word	0x24000248

70001400 <BSP_COM_Init>:
  * @param  COM_Init Pointer to a COM_InitTypeDef structure that contains the
  *                configuration information for the specified COM peripheral.
  * @retval BSP error code
  */
int32_t BSP_COM_Init(COM_TypeDef COM, COM_InitTypeDef *COM_Init)
{
70001400:	b580      	push	{r7, lr}
70001402:	b084      	sub	sp, #16
70001404:	af00      	add	r7, sp, #0
70001406:	4603      	mov	r3, r0
70001408:	6039      	str	r1, [r7, #0]
7000140a:	71fb      	strb	r3, [r7, #7]
  int32_t status = BSP_ERROR_NONE;
7000140c:	2300      	movs	r3, #0
7000140e:	60fb      	str	r3, [r7, #12]

  if (COM_Init == NULL)
70001410:	683b      	ldr	r3, [r7, #0]
70001412:	2b00      	cmp	r3, #0
70001414:	d103      	bne.n	7000141e <BSP_COM_Init+0x1e>
  {
    status = BSP_ERROR_WRONG_PARAM;
70001416:	f06f 0301 	mvn.w	r3, #1
7000141a:	60fb      	str	r3, [r7, #12]
7000141c:	e037      	b.n	7000148e <BSP_COM_Init+0x8e>
  }
  else
  {
    /* Initialize COM instance */
    hcom_uart[COM].Instance = COM_UART[COM];
7000141e:	79fa      	ldrb	r2, [r7, #7]
70001420:	79fb      	ldrb	r3, [r7, #7]
70001422:	491d      	ldr	r1, [pc, #116]	@ (70001498 <BSP_COM_Init+0x98>)
70001424:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
70001428:	491c      	ldr	r1, [pc, #112]	@ (7000149c <BSP_COM_Init+0x9c>)
7000142a:	2094      	movs	r0, #148	@ 0x94
7000142c:	fb00 f303 	mul.w	r3, r0, r3
70001430:	440b      	add	r3, r1
70001432:	601a      	str	r2, [r3, #0]

#if (USE_HAL_UART_REGISTER_CALLBACKS == 0)
    UART_MspInit(&hcom_uart[COM]);
70001434:	79fb      	ldrb	r3, [r7, #7]
70001436:	2294      	movs	r2, #148	@ 0x94
70001438:	fb02 f303 	mul.w	r3, r2, r3
7000143c:	4a17      	ldr	r2, [pc, #92]	@ (7000149c <BSP_COM_Init+0x9c>)
7000143e:	4413      	add	r3, r2
70001440:	4618      	mov	r0, r3
70001442:	f000 f885 	bl	70001550 <UART_MspInit>
    }

    if (status == BSP_ERROR_NONE)
    {
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
      if (COM == COM1)
70001446:	79fb      	ldrb	r3, [r7, #7]
70001448:	2b00      	cmp	r3, #0
7000144a:	d110      	bne.n	7000146e <BSP_COM_Init+0x6e>
      {
        if (MX_USART3_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
7000144c:	79fb      	ldrb	r3, [r7, #7]
7000144e:	2294      	movs	r2, #148	@ 0x94
70001450:	fb02 f303 	mul.w	r3, r2, r3
70001454:	4a11      	ldr	r2, [pc, #68]	@ (7000149c <BSP_COM_Init+0x9c>)
70001456:	4413      	add	r3, r2
70001458:	6839      	ldr	r1, [r7, #0]
7000145a:	4618      	mov	r0, r3
7000145c:	f000 f844 	bl	700014e8 <MX_USART3_Init>
70001460:	4603      	mov	r3, r0
70001462:	2b00      	cmp	r3, #0
70001464:	d013      	beq.n	7000148e <BSP_COM_Init+0x8e>
        {
          status = BSP_ERROR_PERIPH_FAILURE;
70001466:	f06f 0303 	mvn.w	r3, #3
7000146a:	60fb      	str	r3, [r7, #12]
7000146c:	e00f      	b.n	7000148e <BSP_COM_Init+0x8e>
        }
      }
      else /* COM = COM2 */
      {
        if (MX_USART3_Init(&hcom_uart[COM], COM_Init) != HAL_OK)
7000146e:	79fb      	ldrb	r3, [r7, #7]
70001470:	2294      	movs	r2, #148	@ 0x94
70001472:	fb02 f303 	mul.w	r3, r2, r3
70001476:	4a09      	ldr	r2, [pc, #36]	@ (7000149c <BSP_COM_Init+0x9c>)
70001478:	4413      	add	r3, r2
7000147a:	6839      	ldr	r1, [r7, #0]
7000147c:	4618      	mov	r0, r3
7000147e:	f000 f833 	bl	700014e8 <MX_USART3_Init>
70001482:	4603      	mov	r3, r0
70001484:	2b00      	cmp	r3, #0
70001486:	d002      	beq.n	7000148e <BSP_COM_Init+0x8e>
        {
          status = BSP_ERROR_PERIPH_FAILURE;
70001488:	f06f 0303 	mvn.w	r3, #3
7000148c:	60fb      	str	r3, [r7, #12]
#if (USE_HAL_UART_REGISTER_CALLBACKS == 1)
    }
#endif /* USE_HAL_UART_REGISTER_CALLBACKS */
  }

  return status;
7000148e:	68fb      	ldr	r3, [r7, #12]
}
70001490:	4618      	mov	r0, r3
70001492:	3710      	adds	r7, #16
70001494:	46bd      	mov	sp, r7
70001496:	bd80      	pop	{r7, pc}
70001498:	24000028 	.word	0x24000028
7000149c:	240001b4 	.word	0x240001b4

700014a0 <__io_putchar>:

/**
  * @brief  Redirect console output to COM
  */
PUTCHAR_PROTOTYPE
{
700014a0:	b580      	push	{r7, lr}
700014a2:	b082      	sub	sp, #8
700014a4:	af00      	add	r7, sp, #0
700014a6:	6078      	str	r0, [r7, #4]
  HAL_UART_Transmit(&hcom_uart [COM_ActiveLogPort], (uint8_t *) &ch, 1, COM_POLL_TIMEOUT);
700014a8:	4b09      	ldr	r3, [pc, #36]	@ (700014d0 <__io_putchar+0x30>)
700014aa:	781b      	ldrb	r3, [r3, #0]
700014ac:	461a      	mov	r2, r3
700014ae:	2394      	movs	r3, #148	@ 0x94
700014b0:	fb02 f303 	mul.w	r3, r2, r3
700014b4:	4a07      	ldr	r2, [pc, #28]	@ (700014d4 <__io_putchar+0x34>)
700014b6:	1898      	adds	r0, r3, r2
700014b8:	1d39      	adds	r1, r7, #4
700014ba:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
700014be:	2201      	movs	r2, #1
700014c0:	f003 fc42 	bl	70004d48 <HAL_UART_Transmit>
  return ch;
700014c4:	687b      	ldr	r3, [r7, #4]
}
700014c6:	4618      	mov	r0, r3
700014c8:	3708      	adds	r7, #8
700014ca:	46bd      	mov	sp, r7
700014cc:	bd80      	pop	{r7, pc}
700014ce:	bf00      	nop
700014d0:	24000250 	.word	0x24000250
700014d4:	240001b4 	.word	0x240001b4

700014d8 <BUTTON_USER_EXTI_Callback>:
/**
  * @brief  User EXTI line detection callbacks.
  * @retval None
  */
static void BUTTON_USER_EXTI_Callback(void)
{
700014d8:	b580      	push	{r7, lr}
700014da:	af00      	add	r7, sp, #0
  BSP_PB_Callback(BUTTON_USER);
700014dc:	2000      	movs	r0, #0
700014de:	f7ff fabb 	bl	70000a58 <BSP_PB_Callback>
}
700014e2:	bf00      	nop
700014e4:	bd80      	pop	{r7, pc}
	...

700014e8 <MX_USART3_Init>:
  * @param  COM_Init Pointer to a UART_HandleTypeDef structure that contains the
  *                  configuration information for the specified USART peripheral.
  * @retval HAL error code
  */
__weak HAL_StatusTypeDef MX_USART3_Init(UART_HandleTypeDef *huart, MX_UART_InitTypeDef *COM_Init)
{
700014e8:	b580      	push	{r7, lr}
700014ea:	b082      	sub	sp, #8
700014ec:	af00      	add	r7, sp, #0
700014ee:	6078      	str	r0, [r7, #4]
700014f0:	6039      	str	r1, [r7, #0]
  /* USART configuration */
  huart->Instance          = COM_UART[COM1];
700014f2:	4b16      	ldr	r3, [pc, #88]	@ (7000154c <MX_USART3_Init+0x64>)
700014f4:	681a      	ldr	r2, [r3, #0]
700014f6:	687b      	ldr	r3, [r7, #4]
700014f8:	601a      	str	r2, [r3, #0]
  huart->Init.BaudRate     = COM_Init->BaudRate;
700014fa:	683b      	ldr	r3, [r7, #0]
700014fc:	681a      	ldr	r2, [r3, #0]
700014fe:	687b      	ldr	r3, [r7, #4]
70001500:	605a      	str	r2, [r3, #4]
  huart->Init.Mode         = UART_MODE_TX_RX;
70001502:	687b      	ldr	r3, [r7, #4]
70001504:	220c      	movs	r2, #12
70001506:	615a      	str	r2, [r3, #20]
  huart->Init.Parity       = (uint32_t)COM_Init->Parity;
70001508:	683b      	ldr	r3, [r7, #0]
7000150a:	895b      	ldrh	r3, [r3, #10]
7000150c:	461a      	mov	r2, r3
7000150e:	687b      	ldr	r3, [r7, #4]
70001510:	611a      	str	r2, [r3, #16]
  huart->Init.WordLength   = (uint32_t)COM_Init->WordLength;
70001512:	683b      	ldr	r3, [r7, #0]
70001514:	685a      	ldr	r2, [r3, #4]
70001516:	687b      	ldr	r3, [r7, #4]
70001518:	609a      	str	r2, [r3, #8]
  huart->Init.StopBits     = (uint32_t)COM_Init->StopBits;
7000151a:	683b      	ldr	r3, [r7, #0]
7000151c:	891b      	ldrh	r3, [r3, #8]
7000151e:	461a      	mov	r2, r3
70001520:	687b      	ldr	r3, [r7, #4]
70001522:	60da      	str	r2, [r3, #12]
  huart->Init.HwFlowCtl    = (uint32_t)COM_Init->HwFlowCtl;
70001524:	683b      	ldr	r3, [r7, #0]
70001526:	899b      	ldrh	r3, [r3, #12]
70001528:	461a      	mov	r2, r3
7000152a:	687b      	ldr	r3, [r7, #4]
7000152c:	619a      	str	r2, [r3, #24]
  huart->Init.OverSampling = UART_OVERSAMPLING_8;
7000152e:	687b      	ldr	r3, [r7, #4]
70001530:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
70001534:	61da      	str	r2, [r3, #28]
  huart->Init.ClockPrescaler     = UART_PRESCALER_DIV1;
70001536:	687b      	ldr	r3, [r7, #4]
70001538:	2200      	movs	r2, #0
7000153a:	625a      	str	r2, [r3, #36]	@ 0x24
  return HAL_UART_Init(huart);
7000153c:	6878      	ldr	r0, [r7, #4]
7000153e:	f003 fbb3 	bl	70004ca8 <HAL_UART_Init>
70001542:	4603      	mov	r3, r0
}
70001544:	4618      	mov	r0, r3
70001546:	3708      	adds	r7, #8
70001548:	46bd      	mov	sp, r7
7000154a:	bd80      	pop	{r7, pc}
7000154c:	24000028 	.word	0x24000028

70001550 <UART_MspInit>:
  * @brief  Initialize UART MSP.
  * @param  huart UART handle.
  * @retval None.
  */
static void UART_MspInit(const UART_HandleTypeDef *huart)
{
70001550:	b580      	push	{r7, lr}
70001552:	b092      	sub	sp, #72	@ 0x48
70001554:	af00      	add	r7, sp, #0
70001556:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_Init = {0};
70001558:	f107 0330 	add.w	r3, r7, #48	@ 0x30
7000155c:	2200      	movs	r2, #0
7000155e:	601a      	str	r2, [r3, #0]
70001560:	605a      	str	r2, [r3, #4]
70001562:	609a      	str	r2, [r3, #8]
70001564:	60da      	str	r2, [r3, #12]
70001566:	611a      	str	r2, [r3, #16]
  GPIO_TypeDef    *COM_TX_PORT[COMn] = {COM1_TX_GPIO_PORT};
70001568:	4b3f      	ldr	r3, [pc, #252]	@ (70001668 <UART_MspInit+0x118>)
7000156a:	62fb      	str	r3, [r7, #44]	@ 0x2c
  GPIO_TypeDef    *COM_RX_PORT[COMn] = {COM1_RX_GPIO_PORT};
7000156c:	4b3e      	ldr	r3, [pc, #248]	@ (70001668 <UART_MspInit+0x118>)
7000156e:	62bb      	str	r3, [r7, #40]	@ 0x28
  const uint16_t   COM_TX_PIN[COMn]  = {COM1_TX_PIN};
70001570:	f44f 7380 	mov.w	r3, #256	@ 0x100
70001574:	84bb      	strh	r3, [r7, #36]	@ 0x24
  const uint16_t   COM_RX_PIN[COMn]  = {COM1_RX_PIN};
70001576:	f44f 7300 	mov.w	r3, #512	@ 0x200
7000157a:	843b      	strh	r3, [r7, #32]
  const uint8_t    COM_TX_AF[COMn]   = {COM1_TX_AF};
7000157c:	2307      	movs	r3, #7
7000157e:	773b      	strb	r3, [r7, #28]
  const uint8_t    COM_RX_AF[COMn]   = {COM1_RX_AF};
70001580:	2307      	movs	r3, #7
70001582:	763b      	strb	r3, [r7, #24]
  COM_TypeDef      COM;

  /* Get COM according instance */
  if (huart->Instance == COM1_UART)
70001584:	687b      	ldr	r3, [r7, #4]
70001586:	681b      	ldr	r3, [r3, #0]
70001588:	4a38      	ldr	r2, [pc, #224]	@ (7000166c <UART_MspInit+0x11c>)
7000158a:	4293      	cmp	r3, r2
7000158c:	d168      	bne.n	70001660 <UART_MspInit+0x110>
  {
    COM = COM1;
7000158e:	2300      	movs	r3, #0
70001590:	f887 3047 	strb.w	r3, [r7, #71]	@ 0x47
    /* Enable COM and GPIO clocks */
    COM1_TX_GPIO_CLK_ENABLE();
70001594:	4b36      	ldr	r3, [pc, #216]	@ (70001670 <UART_MspInit+0x120>)
70001596:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
7000159a:	4a35      	ldr	r2, [pc, #212]	@ (70001670 <UART_MspInit+0x120>)
7000159c:	f043 0308 	orr.w	r3, r3, #8
700015a0:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
700015a4:	4b32      	ldr	r3, [pc, #200]	@ (70001670 <UART_MspInit+0x120>)
700015a6:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700015aa:	617b      	str	r3, [r7, #20]
700015ac:	697b      	ldr	r3, [r7, #20]
    COM1_RX_GPIO_CLK_ENABLE();
700015ae:	4b30      	ldr	r3, [pc, #192]	@ (70001670 <UART_MspInit+0x120>)
700015b0:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700015b4:	4a2e      	ldr	r2, [pc, #184]	@ (70001670 <UART_MspInit+0x120>)
700015b6:	f043 0308 	orr.w	r3, r3, #8
700015ba:	f8c2 3140 	str.w	r3, [r2, #320]	@ 0x140
700015be:	4b2c      	ldr	r3, [pc, #176]	@ (70001670 <UART_MspInit+0x120>)
700015c0:	f8d3 3140 	ldr.w	r3, [r3, #320]	@ 0x140
700015c4:	613b      	str	r3, [r7, #16]
700015c6:	693b      	ldr	r3, [r7, #16]
    COM1_CLK_ENABLE();
700015c8:	4b29      	ldr	r3, [pc, #164]	@ (70001670 <UART_MspInit+0x120>)
700015ca:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
700015ce:	4a28      	ldr	r2, [pc, #160]	@ (70001670 <UART_MspInit+0x120>)
700015d0:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
700015d4:	f8c2 3148 	str.w	r3, [r2, #328]	@ 0x148
700015d8:	4b25      	ldr	r3, [pc, #148]	@ (70001670 <UART_MspInit+0x120>)
700015da:	f8d3 3148 	ldr.w	r3, [r3, #328]	@ 0x148
700015de:	60fb      	str	r3, [r7, #12]
700015e0:	68fb      	ldr	r3, [r7, #12]
  {
    return;
  }

  /* Configure COM Tx as alternate function */
  GPIO_Init.Pin       = COM_TX_PIN[COM];
700015e2:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
700015e6:	005b      	lsls	r3, r3, #1
700015e8:	3348      	adds	r3, #72	@ 0x48
700015ea:	443b      	add	r3, r7
700015ec:	f833 3c24 	ldrh.w	r3, [r3, #-36]
700015f0:	633b      	str	r3, [r7, #48]	@ 0x30
  GPIO_Init.Mode      = GPIO_MODE_AF_PP;
700015f2:	2302      	movs	r3, #2
700015f4:	637b      	str	r3, [r7, #52]	@ 0x34
  GPIO_Init.Speed     = GPIO_SPEED_FREQ_HIGH;
700015f6:	2302      	movs	r3, #2
700015f8:	63fb      	str	r3, [r7, #60]	@ 0x3c
  GPIO_Init.Pull      = GPIO_PULLUP;
700015fa:	2301      	movs	r3, #1
700015fc:	63bb      	str	r3, [r7, #56]	@ 0x38
  GPIO_Init.Alternate = COM_TX_AF[COM];
700015fe:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
70001602:	3348      	adds	r3, #72	@ 0x48
70001604:	443b      	add	r3, r7
70001606:	f813 3c2c 	ldrb.w	r3, [r3, #-44]
7000160a:	643b      	str	r3, [r7, #64]	@ 0x40
  HAL_GPIO_Init(COM_TX_PORT[COM], &GPIO_Init);
7000160c:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
70001610:	009b      	lsls	r3, r3, #2
70001612:	3348      	adds	r3, #72	@ 0x48
70001614:	443b      	add	r3, r7
70001616:	f853 3c1c 	ldr.w	r3, [r3, #-28]
7000161a:	f107 0230 	add.w	r2, r7, #48	@ 0x30
7000161e:	4611      	mov	r1, r2
70001620:	4618      	mov	r0, r3
70001622:	f000 faa9 	bl	70001b78 <HAL_GPIO_Init>

  /* Configure COM Rx as alternate function */
  GPIO_Init.Pin       = COM_RX_PIN[COM];
70001626:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
7000162a:	005b      	lsls	r3, r3, #1
7000162c:	3348      	adds	r3, #72	@ 0x48
7000162e:	443b      	add	r3, r7
70001630:	f833 3c28 	ldrh.w	r3, [r3, #-40]
70001634:	633b      	str	r3, [r7, #48]	@ 0x30
  GPIO_Init.Alternate = COM_RX_AF[COM];
70001636:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
7000163a:	3348      	adds	r3, #72	@ 0x48
7000163c:	443b      	add	r3, r7
7000163e:	f813 3c30 	ldrb.w	r3, [r3, #-48]
70001642:	643b      	str	r3, [r7, #64]	@ 0x40
  HAL_GPIO_Init(COM_RX_PORT[COM], &GPIO_Init);
70001644:	f897 3047 	ldrb.w	r3, [r7, #71]	@ 0x47
70001648:	009b      	lsls	r3, r3, #2
7000164a:	3348      	adds	r3, #72	@ 0x48
7000164c:	443b      	add	r3, r7
7000164e:	f853 3c20 	ldr.w	r3, [r3, #-32]
70001652:	f107 0230 	add.w	r2, r7, #48	@ 0x30
70001656:	4611      	mov	r1, r2
70001658:	4618      	mov	r0, r3
7000165a:	f000 fa8d 	bl	70001b78 <HAL_GPIO_Init>
7000165e:	e000      	b.n	70001662 <UART_MspInit+0x112>
    return;
70001660:	bf00      	nop
}
70001662:	3748      	adds	r7, #72	@ 0x48
70001664:	46bd      	mov	sp, r7
70001666:	bd80      	pop	{r7, pc}
70001668:	58020c00 	.word	0x58020c00
7000166c:	40004800 	.word	0x40004800
70001670:	58024400 	.word	0x58024400

70001674 <HAL_Init>:
  *         each 1ms in the SysTick_Handler() interrupt handler.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
70001674:	b580      	push	{r7, lr}
70001676:	b082      	sub	sp, #8
70001678:	af00      	add	r7, sp, #0
  HAL_StatusTypeDef  status = HAL_OK;
7000167a:	2300      	movs	r3, #0
7000167c:	71fb      	strb	r3, [r7, #7]

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
7000167e:	2003      	movs	r0, #3
70001680:	f000 f960 	bl	70001944 <HAL_NVIC_SetPriorityGrouping>

  /* Use SysTick as time base source and configure 1ms tick */
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
70001684:	200f      	movs	r0, #15
70001686:	f000 f80d 	bl	700016a4 <HAL_InitTick>
7000168a:	4603      	mov	r3, r0
7000168c:	2b00      	cmp	r3, #0
7000168e:	d002      	beq.n	70001696 <HAL_Init+0x22>
  {
    status = HAL_ERROR;
70001690:	2301      	movs	r3, #1
70001692:	71fb      	strb	r3, [r7, #7]
70001694:	e001      	b.n	7000169a <HAL_Init+0x26>
  }
  else
  {
    /* Init the low level hardware */
    HAL_MspInit();
70001696:	f7ff f9f9 	bl	70000a8c <HAL_MspInit>
  }

  /* Return function status */
  return status;
7000169a:	79fb      	ldrb	r3, [r7, #7]
}
7000169c:	4618      	mov	r0, r3
7000169e:	3708      	adds	r7, #8
700016a0:	46bd      	mov	sp, r7
700016a2:	bd80      	pop	{r7, pc}

700016a4 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
700016a4:	b580      	push	{r7, lr}
700016a6:	b084      	sub	sp, #16
700016a8:	af00      	add	r7, sp, #0
700016aa:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef  status = HAL_OK;
700016ac:	2300      	movs	r3, #0
700016ae:	73fb      	strb	r3, [r7, #15]

  /* Check uwTickFreq for MisraC 2012 (even if uwTickFreq is a enum type that doesn't take the value zero)*/
  if ((uint32_t)uwTickFreq != 0U)
700016b0:	4b17      	ldr	r3, [pc, #92]	@ (70001710 <HAL_InitTick+0x6c>)
700016b2:	781b      	ldrb	r3, [r3, #0]
700016b4:	2b00      	cmp	r3, #0
700016b6:	d023      	beq.n	70001700 <HAL_InitTick+0x5c>
  {
    /*Configure the SysTick to have interrupt in 1ms time basis*/
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / (uint32_t)uwTickFreq)) == 0U)
700016b8:	4b16      	ldr	r3, [pc, #88]	@ (70001714 <HAL_InitTick+0x70>)
700016ba:	681a      	ldr	r2, [r3, #0]
700016bc:	4b14      	ldr	r3, [pc, #80]	@ (70001710 <HAL_InitTick+0x6c>)
700016be:	781b      	ldrb	r3, [r3, #0]
700016c0:	4619      	mov	r1, r3
700016c2:	f44f 737a 	mov.w	r3, #1000	@ 0x3e8
700016c6:	fbb3 f3f1 	udiv	r3, r3, r1
700016ca:	fbb2 f3f3 	udiv	r3, r2, r3
700016ce:	4618      	mov	r0, r3
700016d0:	f000 f96b 	bl	700019aa <HAL_SYSTICK_Config>
700016d4:	4603      	mov	r3, r0
700016d6:	2b00      	cmp	r3, #0
700016d8:	d10f      	bne.n	700016fa <HAL_InitTick+0x56>
    {
      /* Configure the SysTick IRQ priority */
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
700016da:	687b      	ldr	r3, [r7, #4]
700016dc:	2b0f      	cmp	r3, #15
700016de:	d809      	bhi.n	700016f4 <HAL_InitTick+0x50>
      {
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
700016e0:	2200      	movs	r2, #0
700016e2:	6879      	ldr	r1, [r7, #4]
700016e4:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
700016e8:	f000 f937 	bl	7000195a <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
700016ec:	4a0a      	ldr	r2, [pc, #40]	@ (70001718 <HAL_InitTick+0x74>)
700016ee:	687b      	ldr	r3, [r7, #4]
700016f0:	6013      	str	r3, [r2, #0]
700016f2:	e007      	b.n	70001704 <HAL_InitTick+0x60>
      }
      else
      {
        status = HAL_ERROR;
700016f4:	2301      	movs	r3, #1
700016f6:	73fb      	strb	r3, [r7, #15]
700016f8:	e004      	b.n	70001704 <HAL_InitTick+0x60>
      }
    }
    else
    {
      status = HAL_ERROR;
700016fa:	2301      	movs	r3, #1
700016fc:	73fb      	strb	r3, [r7, #15]
700016fe:	e001      	b.n	70001704 <HAL_InitTick+0x60>
    }
  }
  else
  {
    status = HAL_ERROR;
70001700:	2301      	movs	r3, #1
70001702:	73fb      	strb	r3, [r7, #15]
  }

  /* Return function status */
  return status;
70001704:	7bfb      	ldrb	r3, [r7, #15]
}
70001706:	4618      	mov	r0, r3
70001708:	3710      	adds	r7, #16
7000170a:	46bd      	mov	sp, r7
7000170c:	bd80      	pop	{r7, pc}
7000170e:	bf00      	nop
70001710:	24000030 	.word	0x24000030
70001714:	24000004 	.word	0x24000004
70001718:	2400002c 	.word	0x2400002c

7000171c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
7000171c:	b480      	push	{r7}
7000171e:	af00      	add	r7, sp, #0
  uwTick += (uint32_t)uwTickFreq;
70001720:	4b06      	ldr	r3, [pc, #24]	@ (7000173c <HAL_IncTick+0x20>)
70001722:	781b      	ldrb	r3, [r3, #0]
70001724:	461a      	mov	r2, r3
70001726:	4b06      	ldr	r3, [pc, #24]	@ (70001740 <HAL_IncTick+0x24>)
70001728:	681b      	ldr	r3, [r3, #0]
7000172a:	4413      	add	r3, r2
7000172c:	4a04      	ldr	r2, [pc, #16]	@ (70001740 <HAL_IncTick+0x24>)
7000172e:	6013      	str	r3, [r2, #0]
}
70001730:	bf00      	nop
70001732:	46bd      	mov	sp, r7
70001734:	f85d 7b04 	ldr.w	r7, [sp], #4
70001738:	4770      	bx	lr
7000173a:	bf00      	nop
7000173c:	24000030 	.word	0x24000030
70001740:	24000254 	.word	0x24000254

70001744 <HAL_GetTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
70001744:	b480      	push	{r7}
70001746:	af00      	add	r7, sp, #0
  return uwTick;
70001748:	4b03      	ldr	r3, [pc, #12]	@ (70001758 <HAL_GetTick+0x14>)
7000174a:	681b      	ldr	r3, [r3, #0]
}
7000174c:	4618      	mov	r0, r3
7000174e:	46bd      	mov	sp, r7
70001750:	f85d 7b04 	ldr.w	r7, [sp], #4
70001754:	4770      	bx	lr
70001756:	bf00      	nop
70001758:	24000254 	.word	0x24000254

7000175c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
7000175c:	b580      	push	{r7, lr}
7000175e:	b084      	sub	sp, #16
70001760:	af00      	add	r7, sp, #0
70001762:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
70001764:	f7ff ffee 	bl	70001744 <HAL_GetTick>
70001768:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
7000176a:	687b      	ldr	r3, [r7, #4]
7000176c:	60fb      	str	r3, [r7, #12]

  /* Add a period to ensure minimum wait */
  if (wait < HAL_MAX_DELAY)
7000176e:	68fb      	ldr	r3, [r7, #12]
70001770:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
70001774:	d005      	beq.n	70001782 <HAL_Delay+0x26>
  {
    wait += (uint32_t)uwTickFreq;
70001776:	4b0a      	ldr	r3, [pc, #40]	@ (700017a0 <HAL_Delay+0x44>)
70001778:	781b      	ldrb	r3, [r3, #0]
7000177a:	461a      	mov	r2, r3
7000177c:	68fb      	ldr	r3, [r7, #12]
7000177e:	4413      	add	r3, r2
70001780:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
70001782:	bf00      	nop
70001784:	f7ff ffde 	bl	70001744 <HAL_GetTick>
70001788:	4602      	mov	r2, r0
7000178a:	68bb      	ldr	r3, [r7, #8]
7000178c:	1ad3      	subs	r3, r2, r3
7000178e:	68fa      	ldr	r2, [r7, #12]
70001790:	429a      	cmp	r2, r3
70001792:	d8f7      	bhi.n	70001784 <HAL_Delay+0x28>
  {
  }
}
70001794:	bf00      	nop
70001796:	bf00      	nop
70001798:	3710      	adds	r7, #16
7000179a:	46bd      	mov	sp, r7
7000179c:	bd80      	pop	{r7, pc}
7000179e:	bf00      	nop
700017a0:	24000030 	.word	0x24000030

700017a4 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
700017a4:	b480      	push	{r7}
700017a6:	b085      	sub	sp, #20
700017a8:	af00      	add	r7, sp, #0
700017aa:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
700017ac:	687b      	ldr	r3, [r7, #4]
700017ae:	f003 0307 	and.w	r3, r3, #7
700017b2:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
700017b4:	4b0b      	ldr	r3, [pc, #44]	@ (700017e4 <__NVIC_SetPriorityGrouping+0x40>)
700017b6:	68db      	ldr	r3, [r3, #12]
700017b8:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
700017ba:	68ba      	ldr	r2, [r7, #8]
700017bc:	f64f 03ff 	movw	r3, #63743	@ 0xf8ff
700017c0:	4013      	ands	r3, r2
700017c2:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
700017c4:	68fb      	ldr	r3, [r7, #12]
700017c6:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
700017c8:	68bb      	ldr	r3, [r7, #8]
700017ca:	431a      	orrs	r2, r3
  reg_value  =  (reg_value                                   |
700017cc:	4b06      	ldr	r3, [pc, #24]	@ (700017e8 <__NVIC_SetPriorityGrouping+0x44>)
700017ce:	4313      	orrs	r3, r2
700017d0:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
700017d2:	4a04      	ldr	r2, [pc, #16]	@ (700017e4 <__NVIC_SetPriorityGrouping+0x40>)
700017d4:	68bb      	ldr	r3, [r7, #8]
700017d6:	60d3      	str	r3, [r2, #12]
}
700017d8:	bf00      	nop
700017da:	3714      	adds	r7, #20
700017dc:	46bd      	mov	sp, r7
700017de:	f85d 7b04 	ldr.w	r7, [sp], #4
700017e2:	4770      	bx	lr
700017e4:	e000ed00 	.word	0xe000ed00
700017e8:	05fa0000 	.word	0x05fa0000

700017ec <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
700017ec:	b480      	push	{r7}
700017ee:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
700017f0:	4b04      	ldr	r3, [pc, #16]	@ (70001804 <__NVIC_GetPriorityGrouping+0x18>)
700017f2:	68db      	ldr	r3, [r3, #12]
700017f4:	0a1b      	lsrs	r3, r3, #8
700017f6:	f003 0307 	and.w	r3, r3, #7
}
700017fa:	4618      	mov	r0, r3
700017fc:	46bd      	mov	sp, r7
700017fe:	f85d 7b04 	ldr.w	r7, [sp], #4
70001802:	4770      	bx	lr
70001804:	e000ed00 	.word	0xe000ed00

70001808 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
70001808:	b480      	push	{r7}
7000180a:	b083      	sub	sp, #12
7000180c:	af00      	add	r7, sp, #0
7000180e:	4603      	mov	r3, r0
70001810:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
70001812:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
70001816:	2b00      	cmp	r3, #0
70001818:	db0b      	blt.n	70001832 <__NVIC_EnableIRQ+0x2a>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
7000181a:	88fb      	ldrh	r3, [r7, #6]
7000181c:	f003 021f 	and.w	r2, r3, #31
70001820:	4907      	ldr	r1, [pc, #28]	@ (70001840 <__NVIC_EnableIRQ+0x38>)
70001822:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
70001826:	095b      	lsrs	r3, r3, #5
70001828:	2001      	movs	r0, #1
7000182a:	fa00 f202 	lsl.w	r2, r0, r2
7000182e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
    __COMPILER_BARRIER();
  }
}
70001832:	bf00      	nop
70001834:	370c      	adds	r7, #12
70001836:	46bd      	mov	sp, r7
70001838:	f85d 7b04 	ldr.w	r7, [sp], #4
7000183c:	4770      	bx	lr
7000183e:	bf00      	nop
70001840:	e000e100 	.word	0xe000e100

70001844 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
70001844:	b480      	push	{r7}
70001846:	b083      	sub	sp, #12
70001848:	af00      	add	r7, sp, #0
7000184a:	4603      	mov	r3, r0
7000184c:	6039      	str	r1, [r7, #0]
7000184e:	80fb      	strh	r3, [r7, #6]
  if ((int32_t)(IRQn) >= 0)
70001850:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
70001854:	2b00      	cmp	r3, #0
70001856:	db0a      	blt.n	7000186e <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]                = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
70001858:	683b      	ldr	r3, [r7, #0]
7000185a:	b2da      	uxtb	r2, r3
7000185c:	490c      	ldr	r1, [pc, #48]	@ (70001890 <__NVIC_SetPriority+0x4c>)
7000185e:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
70001862:	0112      	lsls	r2, r2, #4
70001864:	b2d2      	uxtb	r2, r2
70001866:	440b      	add	r3, r1
70001868:	f883 2300 	strb.w	r2, [r3, #768]	@ 0x300
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
7000186c:	e00a      	b.n	70001884 <__NVIC_SetPriority+0x40>
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
7000186e:	683b      	ldr	r3, [r7, #0]
70001870:	b2da      	uxtb	r2, r3
70001872:	4908      	ldr	r1, [pc, #32]	@ (70001894 <__NVIC_SetPriority+0x50>)
70001874:	88fb      	ldrh	r3, [r7, #6]
70001876:	f003 030f 	and.w	r3, r3, #15
7000187a:	3b04      	subs	r3, #4
7000187c:	0112      	lsls	r2, r2, #4
7000187e:	b2d2      	uxtb	r2, r2
70001880:	440b      	add	r3, r1
70001882:	761a      	strb	r2, [r3, #24]
}
70001884:	bf00      	nop
70001886:	370c      	adds	r7, #12
70001888:	46bd      	mov	sp, r7
7000188a:	f85d 7b04 	ldr.w	r7, [sp], #4
7000188e:	4770      	bx	lr
70001890:	e000e100 	.word	0xe000e100
70001894:	e000ed00 	.word	0xe000ed00

70001898 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
70001898:	b480      	push	{r7}
7000189a:	b089      	sub	sp, #36	@ 0x24
7000189c:	af00      	add	r7, sp, #0
7000189e:	60f8      	str	r0, [r7, #12]
700018a0:	60b9      	str	r1, [r7, #8]
700018a2:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
700018a4:	68fb      	ldr	r3, [r7, #12]
700018a6:	f003 0307 	and.w	r3, r3, #7
700018aa:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
700018ac:	69fb      	ldr	r3, [r7, #28]
700018ae:	f1c3 0307 	rsb	r3, r3, #7
700018b2:	2b04      	cmp	r3, #4
700018b4:	bf28      	it	cs
700018b6:	2304      	movcs	r3, #4
700018b8:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
700018ba:	69fb      	ldr	r3, [r7, #28]
700018bc:	3304      	adds	r3, #4
700018be:	2b06      	cmp	r3, #6
700018c0:	d902      	bls.n	700018c8 <NVIC_EncodePriority+0x30>
700018c2:	69fb      	ldr	r3, [r7, #28]
700018c4:	3b03      	subs	r3, #3
700018c6:	e000      	b.n	700018ca <NVIC_EncodePriority+0x32>
700018c8:	2300      	movs	r3, #0
700018ca:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
700018cc:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
700018d0:	69bb      	ldr	r3, [r7, #24]
700018d2:	fa02 f303 	lsl.w	r3, r2, r3
700018d6:	43da      	mvns	r2, r3
700018d8:	68bb      	ldr	r3, [r7, #8]
700018da:	401a      	ands	r2, r3
700018dc:	697b      	ldr	r3, [r7, #20]
700018de:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
700018e0:	f04f 31ff 	mov.w	r1, #4294967295	@ 0xffffffff
700018e4:	697b      	ldr	r3, [r7, #20]
700018e6:	fa01 f303 	lsl.w	r3, r1, r3
700018ea:	43d9      	mvns	r1, r3
700018ec:	687b      	ldr	r3, [r7, #4]
700018ee:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
700018f0:	4313      	orrs	r3, r2
         );
}
700018f2:	4618      	mov	r0, r3
700018f4:	3724      	adds	r7, #36	@ 0x24
700018f6:	46bd      	mov	sp, r7
700018f8:	f85d 7b04 	ldr.w	r7, [sp], #4
700018fc:	4770      	bx	lr
	...

70001900 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
70001900:	b580      	push	{r7, lr}
70001902:	b082      	sub	sp, #8
70001904:	af00      	add	r7, sp, #0
70001906:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
70001908:	687b      	ldr	r3, [r7, #4]
7000190a:	3b01      	subs	r3, #1
7000190c:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
70001910:	d301      	bcc.n	70001916 <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
70001912:	2301      	movs	r3, #1
70001914:	e00f      	b.n	70001936 <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
70001916:	4a0a      	ldr	r2, [pc, #40]	@ (70001940 <SysTick_Config+0x40>)
70001918:	687b      	ldr	r3, [r7, #4]
7000191a:	3b01      	subs	r3, #1
7000191c:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
7000191e:	210f      	movs	r1, #15
70001920:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
70001924:	f7ff ff8e 	bl	70001844 <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
70001928:	4b05      	ldr	r3, [pc, #20]	@ (70001940 <SysTick_Config+0x40>)
7000192a:	2200      	movs	r2, #0
7000192c:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
7000192e:	4b04      	ldr	r3, [pc, #16]	@ (70001940 <SysTick_Config+0x40>)
70001930:	2207      	movs	r2, #7
70001932:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
70001934:	2300      	movs	r3, #0
}
70001936:	4618      	mov	r0, r3
70001938:	3708      	adds	r7, #8
7000193a:	46bd      	mov	sp, r7
7000193c:	bd80      	pop	{r7, pc}
7000193e:	bf00      	nop
70001940:	e000e010 	.word	0xe000e010

70001944 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ pre-emption is no more possible.
  *         The pending IRQ priority will be managed only by the subpriority.
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
70001944:	b580      	push	{r7, lr}
70001946:	b082      	sub	sp, #8
70001948:	af00      	add	r7, sp, #0
7000194a:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
7000194c:	6878      	ldr	r0, [r7, #4]
7000194e:	f7ff ff29 	bl	700017a4 <__NVIC_SetPriorityGrouping>
}
70001952:	bf00      	nop
70001954:	3708      	adds	r7, #8
70001956:	46bd      	mov	sp, r7
70001958:	bd80      	pop	{r7, pc}

7000195a <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
7000195a:	b580      	push	{r7, lr}
7000195c:	b086      	sub	sp, #24
7000195e:	af00      	add	r7, sp, #0
70001960:	4603      	mov	r3, r0
70001962:	60b9      	str	r1, [r7, #8]
70001964:	607a      	str	r2, [r7, #4]
70001966:	81fb      	strh	r3, [r7, #14]
  uint32_t prioritygroup;

  /* Check the parameters */
  assert_param(IS_NVIC_PRIO_INTERRUPT(IRQn));
  prioritygroup = NVIC_GetPriorityGrouping();
70001968:	f7ff ff40 	bl	700017ec <__NVIC_GetPriorityGrouping>
7000196c:	6178      	str	r0, [r7, #20]
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority, prioritygroup));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority, prioritygroup));

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
7000196e:	687a      	ldr	r2, [r7, #4]
70001970:	68b9      	ldr	r1, [r7, #8]
70001972:	6978      	ldr	r0, [r7, #20]
70001974:	f7ff ff90 	bl	70001898 <NVIC_EncodePriority>
70001978:	4602      	mov	r2, r0
7000197a:	f9b7 300e 	ldrsh.w	r3, [r7, #14]
7000197e:	4611      	mov	r1, r2
70001980:	4618      	mov	r0, r3
70001982:	f7ff ff5f 	bl	70001844 <__NVIC_SetPriority>
}
70001986:	bf00      	nop
70001988:	3718      	adds	r7, #24
7000198a:	46bd      	mov	sp, r7
7000198c:	bd80      	pop	{r7, pc}

7000198e <HAL_NVIC_EnableIRQ>:
  *         (For the complete STM32 Devices IRQ Channels list, please refer
  *         to the appropriate CMSIS device file (stm32h7rsxxxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
7000198e:	b580      	push	{r7, lr}
70001990:	b082      	sub	sp, #8
70001992:	af00      	add	r7, sp, #0
70001994:	4603      	mov	r3, r0
70001996:	80fb      	strh	r3, [r7, #6]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
70001998:	f9b7 3006 	ldrsh.w	r3, [r7, #6]
7000199c:	4618      	mov	r0, r3
7000199e:	f7ff ff33 	bl	70001808 <__NVIC_EnableIRQ>
}
700019a2:	bf00      	nop
700019a4:	3708      	adds	r7, #8
700019a6:	46bd      	mov	sp, r7
700019a8:	bd80      	pop	{r7, pc}

700019aa <HAL_SYSTICK_Config>:
  * @param  TicksNumb Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
700019aa:	b580      	push	{r7, lr}
700019ac:	b082      	sub	sp, #8
700019ae:	af00      	add	r7, sp, #0
700019b0:	6078      	str	r0, [r7, #4]
  return SysTick_Config(TicksNumb);
700019b2:	6878      	ldr	r0, [r7, #4]
700019b4:	f7ff ffa4 	bl	70001900 <SysTick_Config>
700019b8:	4603      	mov	r3, r0
}
700019ba:	4618      	mov	r0, r3
700019bc:	3708      	adds	r7, #8
700019be:	46bd      	mov	sp, r7
700019c0:	bd80      	pop	{r7, pc}

700019c2 <HAL_DMA_Abort>:
  *         is suspended while a data transfer is on-going, the current data will be transferred and the channel will be
  *         effectively suspended only after the transfer of any on-going data is finished.
  * @retval HAL status.
  */
HAL_StatusTypeDef HAL_DMA_Abort(DMA_HandleTypeDef *const hdma)
{
700019c2:	b580      	push	{r7, lr}
700019c4:	b084      	sub	sp, #16
700019c6:	af00      	add	r7, sp, #0
700019c8:	6078      	str	r0, [r7, #4]
  /* Get tick number */
  uint32_t tickstart =  HAL_GetTick();
700019ca:	f7ff febb 	bl	70001744 <HAL_GetTick>
700019ce:	60f8      	str	r0, [r7, #12]

  /* Check the DMA peripheral handle parameter */
  if (hdma == NULL)
700019d0:	687b      	ldr	r3, [r7, #4]
700019d2:	2b00      	cmp	r3, #0
700019d4:	d101      	bne.n	700019da <HAL_DMA_Abort+0x18>
  {
    return HAL_ERROR;
700019d6:	2301      	movs	r3, #1
700019d8:	e06b      	b.n	70001ab2 <HAL_DMA_Abort+0xf0>
  }

  /* Check DMA channel state */
  if (hdma->State != HAL_DMA_STATE_BUSY)
700019da:	687b      	ldr	r3, [r7, #4]
700019dc:	f893 3054 	ldrb.w	r3, [r3, #84]	@ 0x54
700019e0:	b2db      	uxtb	r3, r3
700019e2:	2b02      	cmp	r3, #2
700019e4:	d008      	beq.n	700019f8 <HAL_DMA_Abort+0x36>
  {
    /* Update the DMA channel error code */
    hdma->ErrorCode = HAL_DMA_ERROR_NO_XFER;
700019e6:	687b      	ldr	r3, [r7, #4]
700019e8:	2220      	movs	r2, #32
700019ea:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
700019ec:	687b      	ldr	r3, [r7, #4]
700019ee:	2200      	movs	r2, #0
700019f0:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

    return HAL_ERROR;
700019f4:	2301      	movs	r3, #1
700019f6:	e05c      	b.n	70001ab2 <HAL_DMA_Abort+0xf0>
  }
  else
  {
    /* Suspend the channel */
    hdma->Instance->CCR |= DMA_CCR_SUSP;
700019f8:	687b      	ldr	r3, [r7, #4]
700019fa:	681b      	ldr	r3, [r3, #0]
700019fc:	695a      	ldr	r2, [r3, #20]
700019fe:	687b      	ldr	r3, [r7, #4]
70001a00:	681b      	ldr	r3, [r3, #0]
70001a02:	f042 0204 	orr.w	r2, r2, #4
70001a06:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_SUSPEND;
70001a08:	687b      	ldr	r3, [r7, #4]
70001a0a:	2205      	movs	r2, #5
70001a0c:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check if the DMA Channel is suspended */
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
70001a10:	e020      	b.n	70001a54 <HAL_DMA_Abort+0x92>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > HAL_TIMEOUT_DMA_ABORT)
70001a12:	f7ff fe97 	bl	70001744 <HAL_GetTick>
70001a16:	4602      	mov	r2, r0
70001a18:	68fb      	ldr	r3, [r7, #12]
70001a1a:	1ad3      	subs	r3, r2, r3
70001a1c:	2b05      	cmp	r3, #5
70001a1e:	d919      	bls.n	70001a54 <HAL_DMA_Abort+0x92>
      {
        /* Update the DMA channel error code */
        hdma->ErrorCode |= HAL_DMA_ERROR_TIMEOUT;
70001a20:	687b      	ldr	r3, [r7, #4]
70001a22:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
70001a24:	f043 0210 	orr.w	r2, r3, #16
70001a28:	687b      	ldr	r3, [r7, #4]
70001a2a:	659a      	str	r2, [r3, #88]	@ 0x58

        /* Update the DMA channel state */
        hdma->State = HAL_DMA_STATE_ERROR;
70001a2c:	687b      	ldr	r3, [r7, #4]
70001a2e:	2203      	movs	r2, #3
70001a30:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

        /* Check DMA channel transfer mode */
        if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
70001a34:	687b      	ldr	r3, [r7, #4]
70001a36:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70001a38:	f003 0380 	and.w	r3, r3, #128	@ 0x80
70001a3c:	2b00      	cmp	r3, #0
70001a3e:	d003      	beq.n	70001a48 <HAL_DMA_Abort+0x86>
        {
          /* Update the linked-list queue state */
          hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
70001a40:	687b      	ldr	r3, [r7, #4]
70001a42:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
70001a44:	2201      	movs	r2, #1
70001a46:	731a      	strb	r2, [r3, #12]
        }

        /* Process Unlocked */
        __HAL_UNLOCK(hdma);
70001a48:	687b      	ldr	r3, [r7, #4]
70001a4a:	2200      	movs	r2, #0
70001a4c:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c

        return HAL_ERROR;
70001a50:	2301      	movs	r3, #1
70001a52:	e02e      	b.n	70001ab2 <HAL_DMA_Abort+0xf0>
    while ((hdma->Instance->CSR & DMA_CSR_SUSPF) == 0U)
70001a54:	687b      	ldr	r3, [r7, #4]
70001a56:	681b      	ldr	r3, [r3, #0]
70001a58:	691b      	ldr	r3, [r3, #16]
70001a5a:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
70001a5e:	2b00      	cmp	r3, #0
70001a60:	d0d7      	beq.n	70001a12 <HAL_DMA_Abort+0x50>
      }
    }

    /* Reset the channel */
    hdma->Instance->CCR |= DMA_CCR_RESET;
70001a62:	687b      	ldr	r3, [r7, #4]
70001a64:	681b      	ldr	r3, [r3, #0]
70001a66:	695a      	ldr	r2, [r3, #20]
70001a68:	687b      	ldr	r3, [r7, #4]
70001a6a:	681b      	ldr	r3, [r3, #0]
70001a6c:	f042 0202 	orr.w	r2, r2, #2
70001a70:	615a      	str	r2, [r3, #20]

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_ABORT;
70001a72:	687b      	ldr	r3, [r7, #4]
70001a74:	2204      	movs	r2, #4
70001a76:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Clear all status flags */
    __HAL_DMA_CLEAR_FLAG(hdma, (DMA_FLAG_TC | DMA_FLAG_HT | DMA_FLAG_DTE | DMA_FLAG_ULE | DMA_FLAG_USE | DMA_FLAG_SUSP |
70001a7a:	687b      	ldr	r3, [r7, #4]
70001a7c:	681b      	ldr	r3, [r3, #0]
70001a7e:	f44f 42fe 	mov.w	r2, #32512	@ 0x7f00
70001a82:	60da      	str	r2, [r3, #12]
                                DMA_FLAG_TO));

    /* Update the DMA channel state */
    hdma->State = HAL_DMA_STATE_READY;
70001a84:	687b      	ldr	r3, [r7, #4]
70001a86:	2201      	movs	r2, #1
70001a88:	f883 2054 	strb.w	r2, [r3, #84]	@ 0x54

    /* Check DMA channel transfer mode */
    if ((hdma->Mode & DMA_LINKEDLIST) == DMA_LINKEDLIST)
70001a8c:	687b      	ldr	r3, [r7, #4]
70001a8e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70001a90:	f003 0380 	and.w	r3, r3, #128	@ 0x80
70001a94:	2b00      	cmp	r3, #0
70001a96:	d007      	beq.n	70001aa8 <HAL_DMA_Abort+0xe6>
    {
      /* Update the linked-list queue state */
      hdma->LinkedListQueue->State = HAL_DMA_QUEUE_STATE_READY;
70001a98:	687b      	ldr	r3, [r7, #4]
70001a9a:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
70001a9c:	2201      	movs	r2, #1
70001a9e:	731a      	strb	r2, [r3, #12]

      /* Clear remaining data size to ensure loading linked-list from memory next start */
      hdma->Instance->CBR1 = 0U;
70001aa0:	687b      	ldr	r3, [r7, #4]
70001aa2:	681b      	ldr	r3, [r3, #0]
70001aa4:	2200      	movs	r2, #0
70001aa6:	649a      	str	r2, [r3, #72]	@ 0x48
    }

    /* Process Unlocked */
    __HAL_UNLOCK(hdma);
70001aa8:	687b      	ldr	r3, [r7, #4]
70001aaa:	2200      	movs	r2, #0
70001aac:	f883 204c 	strb.w	r2, [r3, #76]	@ 0x4c
  }

  return HAL_OK;
70001ab0:	2300      	movs	r3, #0
}
70001ab2:	4618      	mov	r0, r3
70001ab4:	3710      	adds	r7, #16
70001ab6:	46bd      	mov	sp, r7
70001ab8:	bd80      	pop	{r7, pc}

70001aba <HAL_EXTI_RegisterCallback>:
  *         This parameter can be one of @arg @ref EXTI_CallbackIDTypeDef values.
  * @param  pPendingCbfn function pointer to be stored as callback.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_RegisterCallback(EXTI_HandleTypeDef *hexti, EXTI_CallbackIDTypeDef CallbackID, void (*pPendingCbfn)(void))
{
70001aba:	b480      	push	{r7}
70001abc:	b087      	sub	sp, #28
70001abe:	af00      	add	r7, sp, #0
70001ac0:	60f8      	str	r0, [r7, #12]
70001ac2:	460b      	mov	r3, r1
70001ac4:	607a      	str	r2, [r7, #4]
70001ac6:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef status = HAL_OK;
70001ac8:	2300      	movs	r3, #0
70001aca:	75fb      	strb	r3, [r7, #23]

  switch (CallbackID)
70001acc:	7afb      	ldrb	r3, [r7, #11]
70001ace:	2b00      	cmp	r3, #0
70001ad0:	d103      	bne.n	70001ada <HAL_EXTI_RegisterCallback+0x20>
  {
    case  HAL_EXTI_COMMON_CB_ID:
      hexti->PendingCallback = pPendingCbfn;
70001ad2:	68fb      	ldr	r3, [r7, #12]
70001ad4:	687a      	ldr	r2, [r7, #4]
70001ad6:	605a      	str	r2, [r3, #4]
      break;
70001ad8:	e002      	b.n	70001ae0 <HAL_EXTI_RegisterCallback+0x26>

    default:
      status = HAL_ERROR;
70001ada:	2301      	movs	r3, #1
70001adc:	75fb      	strb	r3, [r7, #23]
      break;
70001ade:	bf00      	nop
  }

  return status;
70001ae0:	7dfb      	ldrb	r3, [r7, #23]
}
70001ae2:	4618      	mov	r0, r3
70001ae4:	371c      	adds	r7, #28
70001ae6:	46bd      	mov	sp, r7
70001ae8:	f85d 7b04 	ldr.w	r7, [sp], #4
70001aec:	4770      	bx	lr

70001aee <HAL_EXTI_GetHandle>:
  * @param  ExtiLine Exti line number.
  *         This parameter can be from 0 to @ref EXTI_LINE_NB.
  * @retval HAL Status.
  */
HAL_StatusTypeDef HAL_EXTI_GetHandle(EXTI_HandleTypeDef *hexti, uint32_t ExtiLine)
{
70001aee:	b480      	push	{r7}
70001af0:	b083      	sub	sp, #12
70001af2:	af00      	add	r7, sp, #0
70001af4:	6078      	str	r0, [r7, #4]
70001af6:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_EXTI_LINE(ExtiLine));

  /* Check null pointer */
  if (hexti == NULL)
70001af8:	687b      	ldr	r3, [r7, #4]
70001afa:	2b00      	cmp	r3, #0
70001afc:	d101      	bne.n	70001b02 <HAL_EXTI_GetHandle+0x14>
  {
    return HAL_ERROR;
70001afe:	2301      	movs	r3, #1
70001b00:	e003      	b.n	70001b0a <HAL_EXTI_GetHandle+0x1c>
  }
  else
  {
    /* Store line number as handle private field */
    hexti->Line = ExtiLine;
70001b02:	687b      	ldr	r3, [r7, #4]
70001b04:	683a      	ldr	r2, [r7, #0]
70001b06:	601a      	str	r2, [r3, #0]

    return HAL_OK;
70001b08:	2300      	movs	r3, #0
  }
}
70001b0a:	4618      	mov	r0, r3
70001b0c:	370c      	adds	r7, #12
70001b0e:	46bd      	mov	sp, r7
70001b10:	f85d 7b04 	ldr.w	r7, [sp], #4
70001b14:	4770      	bx	lr
	...

70001b18 <HAL_EXTI_IRQHandler>:
  * @brief  Handle EXTI interrupt request.
  * @param  hexti Exti handle.
  * @retval none.
  */
void HAL_EXTI_IRQHandler(const EXTI_HandleTypeDef *hexti)
{
70001b18:	b580      	push	{r7, lr}
70001b1a:	b086      	sub	sp, #24
70001b1c:	af00      	add	r7, sp, #0
70001b1e:	6078      	str	r0, [r7, #4]
  uint32_t regval;
  uint32_t maskline;
  uint32_t offset;

  /* Compute line register offset and line mask */
  offset = ((hexti->Line & EXTI_REG_MASK) >> EXTI_REG_SHIFT);
70001b20:	687b      	ldr	r3, [r7, #4]
70001b22:	681b      	ldr	r3, [r3, #0]
70001b24:	0c1b      	lsrs	r3, r3, #16
70001b26:	f003 0303 	and.w	r3, r3, #3
70001b2a:	617b      	str	r3, [r7, #20]
  maskline = (1uL << (hexti->Line & EXTI_PIN_MASK));
70001b2c:	687b      	ldr	r3, [r7, #4]
70001b2e:	681b      	ldr	r3, [r3, #0]
70001b30:	f003 031f 	and.w	r3, r3, #31
70001b34:	2201      	movs	r2, #1
70001b36:	fa02 f303 	lsl.w	r3, r2, r3
70001b3a:	613b      	str	r3, [r7, #16]

  /* Get pending bit  */
  regaddr = (__IO uint32_t *)(&EXTI->PR1 + (EXTI_MODE_OFFSET * offset));
70001b3c:	697b      	ldr	r3, [r7, #20]
70001b3e:	011a      	lsls	r2, r3, #4
70001b40:	4b0c      	ldr	r3, [pc, #48]	@ (70001b74 <HAL_EXTI_IRQHandler+0x5c>)
70001b42:	4413      	add	r3, r2
70001b44:	60fb      	str	r3, [r7, #12]
  regval = (*regaddr & maskline);
70001b46:	68fb      	ldr	r3, [r7, #12]
70001b48:	681b      	ldr	r3, [r3, #0]
70001b4a:	693a      	ldr	r2, [r7, #16]
70001b4c:	4013      	ands	r3, r2
70001b4e:	60bb      	str	r3, [r7, #8]

  if (regval != 0x00u)
70001b50:	68bb      	ldr	r3, [r7, #8]
70001b52:	2b00      	cmp	r3, #0
70001b54:	d009      	beq.n	70001b6a <HAL_EXTI_IRQHandler+0x52>
  {
    /* Clear pending bit */
    *regaddr = maskline;
70001b56:	68fb      	ldr	r3, [r7, #12]
70001b58:	693a      	ldr	r2, [r7, #16]
70001b5a:	601a      	str	r2, [r3, #0]

    /* Call callback */
    if (hexti->PendingCallback != NULL)
70001b5c:	687b      	ldr	r3, [r7, #4]
70001b5e:	685b      	ldr	r3, [r3, #4]
70001b60:	2b00      	cmp	r3, #0
70001b62:	d002      	beq.n	70001b6a <HAL_EXTI_IRQHandler+0x52>
    {
      hexti->PendingCallback();
70001b64:	687b      	ldr	r3, [r7, #4]
70001b66:	685b      	ldr	r3, [r3, #4]
70001b68:	4798      	blx	r3
    }
  }
}
70001b6a:	bf00      	nop
70001b6c:	3718      	adds	r7, #24
70001b6e:	46bd      	mov	sp, r7
70001b70:	bd80      	pop	{r7, pc}
70001b72:	bf00      	nop
70001b74:	58000088 	.word	0x58000088

70001b78 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, const GPIO_InitTypeDef *GPIO_Init)
{
70001b78:	b480      	push	{r7}
70001b7a:	b087      	sub	sp, #28
70001b7c:	af00      	add	r7, sp, #0
70001b7e:	6078      	str	r0, [r7, #4]
70001b80:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00U;
70001b82:	2300      	movs	r3, #0
70001b84:	617b      	str	r3, [r7, #20]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00U)
70001b86:	e143      	b.n	70001e10 <HAL_GPIO_Init+0x298>
  {
    /* Get current io position */
    iocurrent = (GPIO_Init->Pin) & (1UL << position);
70001b88:	683b      	ldr	r3, [r7, #0]
70001b8a:	681a      	ldr	r2, [r3, #0]
70001b8c:	2101      	movs	r1, #1
70001b8e:	697b      	ldr	r3, [r7, #20]
70001b90:	fa01 f303 	lsl.w	r3, r1, r3
70001b94:	4013      	ands	r3, r2
70001b96:	60fb      	str	r3, [r7, #12]

    if (iocurrent != 0x00U)
70001b98:	68fb      	ldr	r3, [r7, #12]
70001b9a:	2b00      	cmp	r3, #0
70001b9c:	f000 8135 	beq.w	70001e0a <HAL_GPIO_Init+0x292>
    {
      /*--------------------- GPIO Mode Configuration ------------------------*/
      /* In case of Output or Alternate function mode selection */
      if (((GPIO_Init->Mode & GPIO_MODE) == MODE_OUTPUT) || ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF))
70001ba0:	683b      	ldr	r3, [r7, #0]
70001ba2:	685b      	ldr	r3, [r3, #4]
70001ba4:	f003 0303 	and.w	r3, r3, #3
70001ba8:	2b01      	cmp	r3, #1
70001baa:	d005      	beq.n	70001bb8 <HAL_GPIO_Init+0x40>
70001bac:	683b      	ldr	r3, [r7, #0]
70001bae:	685b      	ldr	r3, [r3, #4]
70001bb0:	f003 0303 	and.w	r3, r3, #3
70001bb4:	2b02      	cmp	r3, #2
70001bb6:	d130      	bne.n	70001c1a <HAL_GPIO_Init+0xa2>
      {
        /* Check the Speed parameter */
        assert_param(IS_GPIO_SPEED(GPIO_Init->Speed));

        /* Configure the IO Speed */
        temp = GPIOx->OSPEEDR;
70001bb8:	687b      	ldr	r3, [r7, #4]
70001bba:	689b      	ldr	r3, [r3, #8]
70001bbc:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * GPIO_OSPEEDR_OSPEED1_Pos));
70001bbe:	697b      	ldr	r3, [r7, #20]
70001bc0:	005b      	lsls	r3, r3, #1
70001bc2:	2203      	movs	r2, #3
70001bc4:	fa02 f303 	lsl.w	r3, r2, r3
70001bc8:	43db      	mvns	r3, r3
70001bca:	693a      	ldr	r2, [r7, #16]
70001bcc:	4013      	ands	r3, r2
70001bce:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_Init->Speed << (position * GPIO_OSPEEDR_OSPEED1_Pos));
70001bd0:	683b      	ldr	r3, [r7, #0]
70001bd2:	68da      	ldr	r2, [r3, #12]
70001bd4:	697b      	ldr	r3, [r7, #20]
70001bd6:	005b      	lsls	r3, r3, #1
70001bd8:	fa02 f303 	lsl.w	r3, r2, r3
70001bdc:	693a      	ldr	r2, [r7, #16]
70001bde:	4313      	orrs	r3, r2
70001be0:	613b      	str	r3, [r7, #16]
        GPIOx->OSPEEDR = temp;
70001be2:	687b      	ldr	r3, [r7, #4]
70001be4:	693a      	ldr	r2, [r7, #16]
70001be6:	609a      	str	r2, [r3, #8]

        /* Configure the IO Output Type */
        temp = GPIOx->OTYPER;
70001be8:	687b      	ldr	r3, [r7, #4]
70001bea:	685b      	ldr	r3, [r3, #4]
70001bec:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
70001bee:	2201      	movs	r2, #1
70001bf0:	697b      	ldr	r3, [r7, #20]
70001bf2:	fa02 f303 	lsl.w	r3, r2, r3
70001bf6:	43db      	mvns	r3, r3
70001bf8:	693a      	ldr	r2, [r7, #16]
70001bfa:	4013      	ands	r3, r2
70001bfc:	613b      	str	r3, [r7, #16]
        temp |= (((GPIO_Init->Mode & OUTPUT_TYPE) >> OUTPUT_TYPE_Pos) << position);
70001bfe:	683b      	ldr	r3, [r7, #0]
70001c00:	685b      	ldr	r3, [r3, #4]
70001c02:	091b      	lsrs	r3, r3, #4
70001c04:	f003 0201 	and.w	r2, r3, #1
70001c08:	697b      	ldr	r3, [r7, #20]
70001c0a:	fa02 f303 	lsl.w	r3, r2, r3
70001c0e:	693a      	ldr	r2, [r7, #16]
70001c10:	4313      	orrs	r3, r2
70001c12:	613b      	str	r3, [r7, #16]
        GPIOx->OTYPER = temp;
70001c14:	687b      	ldr	r3, [r7, #4]
70001c16:	693a      	ldr	r2, [r7, #16]
70001c18:	605a      	str	r2, [r3, #4]
      }

      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
70001c1a:	683b      	ldr	r3, [r7, #0]
70001c1c:	685b      	ldr	r3, [r3, #4]
70001c1e:	f003 0303 	and.w	r3, r3, #3
70001c22:	2b03      	cmp	r3, #3
70001c24:	d109      	bne.n	70001c3a <HAL_GPIO_Init+0xc2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
70001c26:	683b      	ldr	r3, [r7, #0]
70001c28:	685b      	ldr	r3, [r3, #4]
70001c2a:	f003 0303 	and.w	r3, r3, #3
      if (((GPIO_Init->Mode & GPIO_MODE) != MODE_ANALOG) ||
70001c2e:	2b03      	cmp	r3, #3
70001c30:	d11b      	bne.n	70001c6a <HAL_GPIO_Init+0xf2>
          (((GPIO_Init->Mode & GPIO_MODE) == MODE_ANALOG) && (GPIO_Init->Pull != GPIO_PULLUP)))
70001c32:	683b      	ldr	r3, [r7, #0]
70001c34:	689b      	ldr	r3, [r3, #8]
70001c36:	2b01      	cmp	r3, #1
70001c38:	d017      	beq.n	70001c6a <HAL_GPIO_Init+0xf2>
      {
        /* Check the Pull parameter */
        assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

        /* Activate the Pull-up or Pull down resistor for the current IO */
        temp = GPIOx->PUPDR;
70001c3a:	687b      	ldr	r3, [r7, #4]
70001c3c:	68db      	ldr	r3, [r3, #12]
70001c3e:	613b      	str	r3, [r7, #16]
        temp &= ~(GPIO_PUPDR_PUPD0 << (position * GPIO_PUPDR_PUPD1_Pos));
70001c40:	697b      	ldr	r3, [r7, #20]
70001c42:	005b      	lsls	r3, r3, #1
70001c44:	2203      	movs	r2, #3
70001c46:	fa02 f303 	lsl.w	r3, r2, r3
70001c4a:	43db      	mvns	r3, r3
70001c4c:	693a      	ldr	r2, [r7, #16]
70001c4e:	4013      	ands	r3, r2
70001c50:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Pull) << (position * GPIO_PUPDR_PUPD1_Pos));
70001c52:	683b      	ldr	r3, [r7, #0]
70001c54:	689a      	ldr	r2, [r3, #8]
70001c56:	697b      	ldr	r3, [r7, #20]
70001c58:	005b      	lsls	r3, r3, #1
70001c5a:	fa02 f303 	lsl.w	r3, r2, r3
70001c5e:	693a      	ldr	r2, [r7, #16]
70001c60:	4313      	orrs	r3, r2
70001c62:	613b      	str	r3, [r7, #16]
        GPIOx->PUPDR = temp;
70001c64:	687b      	ldr	r3, [r7, #4]
70001c66:	693a      	ldr	r2, [r7, #16]
70001c68:	60da      	str	r2, [r3, #12]
      }

      /* In case of Alternate function mode selection */
      if ((GPIO_Init->Mode & GPIO_MODE) == MODE_AF)
70001c6a:	683b      	ldr	r3, [r7, #0]
70001c6c:	685b      	ldr	r3, [r3, #4]
70001c6e:	f003 0303 	and.w	r3, r3, #3
70001c72:	2b02      	cmp	r3, #2
70001c74:	d123      	bne.n	70001cbe <HAL_GPIO_Init+0x146>
        /* Check the Alternate function parameters */
        assert_param(IS_GPIO_AF_INSTANCE(GPIOx));
        assert_param(IS_GPIO_AF(GPIO_Init->Alternate));

        /* Configure Alternate function mapped with the current IO */
        temp = GPIOx->AFR[position >> 3U];
70001c76:	697b      	ldr	r3, [r7, #20]
70001c78:	08da      	lsrs	r2, r3, #3
70001c7a:	687b      	ldr	r3, [r7, #4]
70001c7c:	3208      	adds	r2, #8
70001c7e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
70001c82:	613b      	str	r3, [r7, #16]
        temp &= ~(0xFuL << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
70001c84:	697b      	ldr	r3, [r7, #20]
70001c86:	f003 0307 	and.w	r3, r3, #7
70001c8a:	009b      	lsls	r3, r3, #2
70001c8c:	220f      	movs	r2, #15
70001c8e:	fa02 f303 	lsl.w	r3, r2, r3
70001c92:	43db      	mvns	r3, r3
70001c94:	693a      	ldr	r2, [r7, #16]
70001c96:	4013      	ands	r3, r2
70001c98:	613b      	str	r3, [r7, #16]
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07U) * GPIO_AFRL_AFSEL1_Pos));
70001c9a:	683b      	ldr	r3, [r7, #0]
70001c9c:	691a      	ldr	r2, [r3, #16]
70001c9e:	697b      	ldr	r3, [r7, #20]
70001ca0:	f003 0307 	and.w	r3, r3, #7
70001ca4:	009b      	lsls	r3, r3, #2
70001ca6:	fa02 f303 	lsl.w	r3, r2, r3
70001caa:	693a      	ldr	r2, [r7, #16]
70001cac:	4313      	orrs	r3, r2
70001cae:	613b      	str	r3, [r7, #16]
        GPIOx->AFR[position >> 3U] = temp;
70001cb0:	697b      	ldr	r3, [r7, #20]
70001cb2:	08da      	lsrs	r2, r3, #3
70001cb4:	687b      	ldr	r3, [r7, #4]
70001cb6:	3208      	adds	r2, #8
70001cb8:	6939      	ldr	r1, [r7, #16]
70001cba:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      }

      /* Configure IO Direction mode (Input, Output, Alternate or Analog) */
      temp = GPIOx->MODER;
70001cbe:	687b      	ldr	r3, [r7, #4]
70001cc0:	681b      	ldr	r3, [r3, #0]
70001cc2:	613b      	str	r3, [r7, #16]
      temp &= ~(GPIO_MODER_MODE0 << (position * GPIO_MODER_MODE1_Pos));
70001cc4:	697b      	ldr	r3, [r7, #20]
70001cc6:	005b      	lsls	r3, r3, #1
70001cc8:	2203      	movs	r2, #3
70001cca:	fa02 f303 	lsl.w	r3, r2, r3
70001cce:	43db      	mvns	r3, r3
70001cd0:	693a      	ldr	r2, [r7, #16]
70001cd2:	4013      	ands	r3, r2
70001cd4:	613b      	str	r3, [r7, #16]
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * GPIO_MODER_MODE1_Pos));
70001cd6:	683b      	ldr	r3, [r7, #0]
70001cd8:	685b      	ldr	r3, [r3, #4]
70001cda:	f003 0203 	and.w	r2, r3, #3
70001cde:	697b      	ldr	r3, [r7, #20]
70001ce0:	005b      	lsls	r3, r3, #1
70001ce2:	fa02 f303 	lsl.w	r3, r2, r3
70001ce6:	693a      	ldr	r2, [r7, #16]
70001ce8:	4313      	orrs	r3, r2
70001cea:	613b      	str	r3, [r7, #16]
      GPIOx->MODER = temp;
70001cec:	687b      	ldr	r3, [r7, #4]
70001cee:	693a      	ldr	r2, [r7, #16]
70001cf0:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) != 0x00U)
70001cf2:	683b      	ldr	r3, [r7, #0]
70001cf4:	685b      	ldr	r3, [r3, #4]
70001cf6:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
70001cfa:	2b00      	cmp	r3, #0
70001cfc:	f000 8085 	beq.w	70001e0a <HAL_GPIO_Init+0x292>
      {
        temp = SBS->EXTICR[position >> 2U];
70001d00:	4a4b      	ldr	r2, [pc, #300]	@ (70001e30 <HAL_GPIO_Init+0x2b8>)
70001d02:	697b      	ldr	r3, [r7, #20]
70001d04:	089b      	lsrs	r3, r3, #2
70001d06:	334c      	adds	r3, #76	@ 0x4c
70001d08:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
70001d0c:	613b      	str	r3, [r7, #16]
        temp &= ~(0x0FuL << ((position & 0x03U) * SBS_EXTICR1_PC_EXTI1_Pos));
70001d0e:	697b      	ldr	r3, [r7, #20]
70001d10:	f003 0303 	and.w	r3, r3, #3
70001d14:	009b      	lsls	r3, r3, #2
70001d16:	220f      	movs	r2, #15
70001d18:	fa02 f303 	lsl.w	r3, r2, r3
70001d1c:	43db      	mvns	r3, r3
70001d1e:	693a      	ldr	r2, [r7, #16]
70001d20:	4013      	ands	r3, r2
70001d22:	613b      	str	r3, [r7, #16]
        temp |= (GPIO_GET_INDEX(GPIOx) << ((position & 0x03U) * SBS_EXTICR1_PC_EXTI1_Pos));
70001d24:	687b      	ldr	r3, [r7, #4]
70001d26:	0a9a      	lsrs	r2, r3, #10
70001d28:	4b42      	ldr	r3, [pc, #264]	@ (70001e34 <HAL_GPIO_Init+0x2bc>)
70001d2a:	4013      	ands	r3, r2
70001d2c:	697a      	ldr	r2, [r7, #20]
70001d2e:	f002 0203 	and.w	r2, r2, #3
70001d32:	0092      	lsls	r2, r2, #2
70001d34:	4093      	lsls	r3, r2
70001d36:	693a      	ldr	r2, [r7, #16]
70001d38:	4313      	orrs	r3, r2
70001d3a:	613b      	str	r3, [r7, #16]
        SBS->EXTICR[position >> 2U] = temp;
70001d3c:	493c      	ldr	r1, [pc, #240]	@ (70001e30 <HAL_GPIO_Init+0x2b8>)
70001d3e:	697b      	ldr	r3, [r7, #20]
70001d40:	089b      	lsrs	r3, r3, #2
70001d42:	334c      	adds	r3, #76	@ 0x4c
70001d44:	693a      	ldr	r2, [r7, #16]
70001d46:	f841 2023 	str.w	r2, [r1, r3, lsl #2]

        /* Clear Rising Falling edge configuration */
        temp = EXTI->RTSR1;
70001d4a:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001d4e:	681b      	ldr	r3, [r3, #0]
70001d50:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001d52:	68fb      	ldr	r3, [r7, #12]
70001d54:	43db      	mvns	r3, r3
70001d56:	693a      	ldr	r2, [r7, #16]
70001d58:	4013      	ands	r3, r2
70001d5a:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_RISING) != 0x00U)
70001d5c:	683b      	ldr	r3, [r7, #0]
70001d5e:	685b      	ldr	r3, [r3, #4]
70001d60:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
70001d64:	2b00      	cmp	r3, #0
70001d66:	d003      	beq.n	70001d70 <HAL_GPIO_Init+0x1f8>
        {
          temp |= iocurrent;
70001d68:	693a      	ldr	r2, [r7, #16]
70001d6a:	68fb      	ldr	r3, [r7, #12]
70001d6c:	4313      	orrs	r3, r2
70001d6e:	613b      	str	r3, [r7, #16]
        }
        EXTI->RTSR1 = temp;
70001d70:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001d74:	693b      	ldr	r3, [r7, #16]
70001d76:	6013      	str	r3, [r2, #0]

        temp = EXTI->FTSR1;
70001d78:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001d7c:	685b      	ldr	r3, [r3, #4]
70001d7e:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001d80:	68fb      	ldr	r3, [r7, #12]
70001d82:	43db      	mvns	r3, r3
70001d84:	693a      	ldr	r2, [r7, #16]
70001d86:	4013      	ands	r3, r2
70001d88:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & TRIGGER_FALLING) != 0x00U)
70001d8a:	683b      	ldr	r3, [r7, #0]
70001d8c:	685b      	ldr	r3, [r3, #4]
70001d8e:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
70001d92:	2b00      	cmp	r3, #0
70001d94:	d003      	beq.n	70001d9e <HAL_GPIO_Init+0x226>
        {
          temp |= iocurrent;
70001d96:	693a      	ldr	r2, [r7, #16]
70001d98:	68fb      	ldr	r3, [r7, #12]
70001d9a:	4313      	orrs	r3, r2
70001d9c:	613b      	str	r3, [r7, #16]
        }
        EXTI->FTSR1 = temp;
70001d9e:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001da2:	693b      	ldr	r3, [r7, #16]
70001da4:	6053      	str	r3, [r2, #4]

        /* Clear EXTI line configuration */
        temp = EXTI->EMR1;
70001da6:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001daa:	f8d3 3084 	ldr.w	r3, [r3, #132]	@ 0x84
70001dae:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001db0:	68fb      	ldr	r3, [r7, #12]
70001db2:	43db      	mvns	r3, r3
70001db4:	693a      	ldr	r2, [r7, #16]
70001db6:	4013      	ands	r3, r2
70001db8:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_EVT) != 0x00U)
70001dba:	683b      	ldr	r3, [r7, #0]
70001dbc:	685b      	ldr	r3, [r3, #4]
70001dbe:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70001dc2:	2b00      	cmp	r3, #0
70001dc4:	d003      	beq.n	70001dce <HAL_GPIO_Init+0x256>
        {
          temp |= iocurrent;
70001dc6:	693a      	ldr	r2, [r7, #16]
70001dc8:	68fb      	ldr	r3, [r7, #12]
70001dca:	4313      	orrs	r3, r2
70001dcc:	613b      	str	r3, [r7, #16]
        }
        EXTI->EMR1 = temp;
70001dce:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001dd2:	693b      	ldr	r3, [r7, #16]
70001dd4:	f8c2 3084 	str.w	r3, [r2, #132]	@ 0x84

        temp = EXTI->IMR1;
70001dd8:	f04f 43b0 	mov.w	r3, #1476395008	@ 0x58000000
70001ddc:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
70001de0:	613b      	str	r3, [r7, #16]
        temp &= ~(iocurrent);
70001de2:	68fb      	ldr	r3, [r7, #12]
70001de4:	43db      	mvns	r3, r3
70001de6:	693a      	ldr	r2, [r7, #16]
70001de8:	4013      	ands	r3, r2
70001dea:	613b      	str	r3, [r7, #16]
        if ((GPIO_Init->Mode & EXTI_IT) != 0x00U)
70001dec:	683b      	ldr	r3, [r7, #0]
70001dee:	685b      	ldr	r3, [r3, #4]
70001df0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70001df4:	2b00      	cmp	r3, #0
70001df6:	d003      	beq.n	70001e00 <HAL_GPIO_Init+0x288>
        {
          temp |= iocurrent;
70001df8:	693a      	ldr	r2, [r7, #16]
70001dfa:	68fb      	ldr	r3, [r7, #12]
70001dfc:	4313      	orrs	r3, r2
70001dfe:	613b      	str	r3, [r7, #16]
        }
        EXTI->IMR1 = temp;
70001e00:	f04f 42b0 	mov.w	r2, #1476395008	@ 0x58000000
70001e04:	693b      	ldr	r3, [r7, #16]
70001e06:	f8c2 3080 	str.w	r3, [r2, #128]	@ 0x80
      }
    }

    position++;
70001e0a:	697b      	ldr	r3, [r7, #20]
70001e0c:	3301      	adds	r3, #1
70001e0e:	617b      	str	r3, [r7, #20]
  while (((GPIO_Init->Pin) >> position) != 0x00U)
70001e10:	683b      	ldr	r3, [r7, #0]
70001e12:	681a      	ldr	r2, [r3, #0]
70001e14:	697b      	ldr	r3, [r7, #20]
70001e16:	fa22 f303 	lsr.w	r3, r2, r3
70001e1a:	2b00      	cmp	r3, #0
70001e1c:	f47f aeb4 	bne.w	70001b88 <HAL_GPIO_Init+0x10>
  }
}
70001e20:	bf00      	nop
70001e22:	bf00      	nop
70001e24:	371c      	adds	r7, #28
70001e26:	46bd      	mov	sp, r7
70001e28:	f85d 7b04 	ldr.w	r7, [sp], #4
70001e2c:	4770      	bx	lr
70001e2e:	bf00      	nop
70001e30:	58000400 	.word	0x58000400
70001e34:	0029ff7f 	.word	0x0029ff7f

70001e38 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
70001e38:	b480      	push	{r7}
70001e3a:	b083      	sub	sp, #12
70001e3c:	af00      	add	r7, sp, #0
70001e3e:	6078      	str	r0, [r7, #4]
70001e40:	460b      	mov	r3, r1
70001e42:	807b      	strh	r3, [r7, #2]
70001e44:	4613      	mov	r3, r2
70001e46:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
70001e48:	787b      	ldrb	r3, [r7, #1]
70001e4a:	2b00      	cmp	r3, #0
70001e4c:	d003      	beq.n	70001e56 <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
70001e4e:	887a      	ldrh	r2, [r7, #2]
70001e50:	687b      	ldr	r3, [r7, #4]
70001e52:	619a      	str	r2, [r3, #24]
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
  }
}
70001e54:	e002      	b.n	70001e5c <HAL_GPIO_WritePin+0x24>
    GPIOx->BRR = (uint32_t)GPIO_Pin;
70001e56:	887a      	ldrh	r2, [r7, #2]
70001e58:	687b      	ldr	r3, [r7, #4]
70001e5a:	629a      	str	r2, [r3, #40]	@ 0x28
}
70001e5c:	bf00      	nop
70001e5e:	370c      	adds	r7, #12
70001e60:	46bd      	mov	sp, r7
70001e62:	f85d 7b04 	ldr.w	r7, [sp], #4
70001e66:	4770      	bx	lr

70001e68 <HAL_GPIO_TogglePin>:
  * @param  GPIO_Pin specifies the pin to be toggled.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
70001e68:	b480      	push	{r7}
70001e6a:	b085      	sub	sp, #20
70001e6c:	af00      	add	r7, sp, #0
70001e6e:	6078      	str	r0, [r7, #4]
70001e70:	460b      	mov	r3, r1
70001e72:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Output Data Register value */
  odr = GPIOx->ODR;
70001e74:	687b      	ldr	r3, [r7, #4]
70001e76:	695b      	ldr	r3, [r3, #20]
70001e78:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
70001e7a:	887a      	ldrh	r2, [r7, #2]
70001e7c:	68fb      	ldr	r3, [r7, #12]
70001e7e:	4013      	ands	r3, r2
70001e80:	041a      	lsls	r2, r3, #16
70001e82:	68fb      	ldr	r3, [r7, #12]
70001e84:	43d9      	mvns	r1, r3
70001e86:	887b      	ldrh	r3, [r7, #2]
70001e88:	400b      	ands	r3, r1
70001e8a:	431a      	orrs	r2, r3
70001e8c:	687b      	ldr	r3, [r7, #4]
70001e8e:	619a      	str	r2, [r3, #24]
}
70001e90:	bf00      	nop
70001e92:	3714      	adds	r7, #20
70001e94:	46bd      	mov	sp, r7
70001e96:	f85d 7b04 	ldr.w	r7, [sp], #4
70001e9a:	4770      	bx	lr

70001e9c <HAL_PWREx_EnableXSPIM1>:
  * @note   The XSPIM_P1 supply must be stable prior to setting
            this bit.
  * @retval None.
  */
void HAL_PWREx_EnableXSPIM1(void)
{
70001e9c:	b480      	push	{r7}
70001e9e:	af00      	add	r7, sp, #0
  SET_BIT(PWR->CSR2, PWR_CSR2_EN_XSPIM1);
70001ea0:	4b05      	ldr	r3, [pc, #20]	@ (70001eb8 <HAL_PWREx_EnableXSPIM1+0x1c>)
70001ea2:	68db      	ldr	r3, [r3, #12]
70001ea4:	4a04      	ldr	r2, [pc, #16]	@ (70001eb8 <HAL_PWREx_EnableXSPIM1+0x1c>)
70001ea6:	f443 4380 	orr.w	r3, r3, #16384	@ 0x4000
70001eaa:	60d3      	str	r3, [r2, #12]
}
70001eac:	bf00      	nop
70001eae:	46bd      	mov	sp, r7
70001eb0:	f85d 7b04 	ldr.w	r7, [sp], #4
70001eb4:	4770      	bx	lr
70001eb6:	bf00      	nop
70001eb8:	58024800 	.word	0x58024800

70001ebc <HAL_RCC_GetSysClockFreq>:
  *
  *
  * @retval SYSCLK frequency
  */
uint32_t HAL_RCC_GetSysClockFreq(void)
{
70001ebc:	b480      	push	{r7}
70001ebe:	b08b      	sub	sp, #44	@ 0x2c
70001ec0:	af00      	add	r7, sp, #0
  uint32_t sysclockfreq;
  uint32_t prescaler;

  /* Get SYSCLK source -------------------------------------------------------*/

  switch (RCC->CFGR & RCC_CFGR_SWS)
70001ec2:	4baa      	ldr	r3, [pc, #680]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001ec4:	691b      	ldr	r3, [r3, #16]
70001ec6:	f003 0338 	and.w	r3, r3, #56	@ 0x38
70001eca:	2b18      	cmp	r3, #24
70001ecc:	f200 8136 	bhi.w	7000213c <HAL_RCC_GetSysClockFreq+0x280>
70001ed0:	a201      	add	r2, pc, #4	@ (adr r2, 70001ed8 <HAL_RCC_GetSysClockFreq+0x1c>)
70001ed2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70001ed6:	bf00      	nop
70001ed8:	70001f3d 	.word	0x70001f3d
70001edc:	7000213d 	.word	0x7000213d
70001ee0:	7000213d 	.word	0x7000213d
70001ee4:	7000213d 	.word	0x7000213d
70001ee8:	7000213d 	.word	0x7000213d
70001eec:	7000213d 	.word	0x7000213d
70001ef0:	7000213d 	.word	0x7000213d
70001ef4:	7000213d 	.word	0x7000213d
70001ef8:	70001f63 	.word	0x70001f63
70001efc:	7000213d 	.word	0x7000213d
70001f00:	7000213d 	.word	0x7000213d
70001f04:	7000213d 	.word	0x7000213d
70001f08:	7000213d 	.word	0x7000213d
70001f0c:	7000213d 	.word	0x7000213d
70001f10:	7000213d 	.word	0x7000213d
70001f14:	7000213d 	.word	0x7000213d
70001f18:	70001f69 	.word	0x70001f69
70001f1c:	7000213d 	.word	0x7000213d
70001f20:	7000213d 	.word	0x7000213d
70001f24:	7000213d 	.word	0x7000213d
70001f28:	7000213d 	.word	0x7000213d
70001f2c:	7000213d 	.word	0x7000213d
70001f30:	7000213d 	.word	0x7000213d
70001f34:	7000213d 	.word	0x7000213d
70001f38:	70001f6f 	.word	0x70001f6f
  {
    case RCC_SYSCLKSOURCE_STATUS_HSI:  /* HSI used as system clock source */

      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70001f3c:	4b8b      	ldr	r3, [pc, #556]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001f3e:	681b      	ldr	r3, [r3, #0]
70001f40:	f003 0320 	and.w	r3, r3, #32
70001f44:	2b00      	cmp	r3, #0
70001f46:	d009      	beq.n	70001f5c <HAL_RCC_GetSysClockFreq+0xa0>
      {
        sysclockfreq = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70001f48:	4b88      	ldr	r3, [pc, #544]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001f4a:	681b      	ldr	r3, [r3, #0]
70001f4c:	08db      	lsrs	r3, r3, #3
70001f4e:	f003 0303 	and.w	r3, r3, #3
70001f52:	4a87      	ldr	r2, [pc, #540]	@ (70002170 <HAL_RCC_GetSysClockFreq+0x2b4>)
70001f54:	fa22 f303 	lsr.w	r3, r2, r3
70001f58:	623b      	str	r3, [r7, #32]
      {
        /* Can't retrieve HSIDIV value */
        sysclockfreq = 0U;
      }

      break;
70001f5a:	e0f2      	b.n	70002142 <HAL_RCC_GetSysClockFreq+0x286>
        sysclockfreq = 0U;
70001f5c:	2300      	movs	r3, #0
70001f5e:	623b      	str	r3, [r7, #32]
      break;
70001f60:	e0ef      	b.n	70002142 <HAL_RCC_GetSysClockFreq+0x286>

    case RCC_SYSCLKSOURCE_STATUS_CSI:  /* CSI used as system clock  source */
      sysclockfreq = CSI_VALUE;
70001f62:	4b84      	ldr	r3, [pc, #528]	@ (70002174 <HAL_RCC_GetSysClockFreq+0x2b8>)
70001f64:	623b      	str	r3, [r7, #32]
      break;
70001f66:	e0ec      	b.n	70002142 <HAL_RCC_GetSysClockFreq+0x286>

    case RCC_SYSCLKSOURCE_STATUS_HSE:  /* HSE used as system clock  source */
      sysclockfreq = HSE_VALUE;
70001f68:	4b83      	ldr	r3, [pc, #524]	@ (70002178 <HAL_RCC_GetSysClockFreq+0x2bc>)
70001f6a:	623b      	str	r3, [r7, #32]
      break;
70001f6c:	e0e9      	b.n	70002142 <HAL_RCC_GetSysClockFreq+0x286>
    case RCC_SYSCLKSOURCE_STATUS_PLLCLK:  /* PLL1 used as system clock  source */

      /* PLL_VCO = (HSE_VALUE or HSI_VALUE or CSI_VALUE/ PLLM) * PLLN
      SYSCLK = PLL_VCO / PLLR
      */
      pllsource = (RCC->PLLCKSELR & RCC_PLLCKSELR_PLLSRC);
70001f6e:	4b7f      	ldr	r3, [pc, #508]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001f70:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70001f72:	f003 0303 	and.w	r3, r3, #3
70001f76:	61fb      	str	r3, [r7, #28]
      pllm = ((RCC->PLLCKSELR & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos)  ;
70001f78:	4b7c      	ldr	r3, [pc, #496]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001f7a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70001f7c:	091b      	lsrs	r3, r3, #4
70001f7e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70001f82:	61bb      	str	r3, [r7, #24]
      pllfracen = ((RCC-> PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) >> RCC_PLLCFGR_PLL1FRACEN_Pos);
70001f84:	4b79      	ldr	r3, [pc, #484]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001f86:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70001f88:	f003 0301 	and.w	r3, r3, #1
70001f8c:	617b      	str	r3, [r7, #20]
      fracn1 = (float_t)(uint32_t)(pllfracen * ((RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN) >> 3));
70001f8e:	4b77      	ldr	r3, [pc, #476]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001f90:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
70001f92:	08db      	lsrs	r3, r3, #3
70001f94:	f3c3 030c 	ubfx	r3, r3, #0, #13
70001f98:	697a      	ldr	r2, [r7, #20]
70001f9a:	fb02 f303 	mul.w	r3, r2, r3
70001f9e:	ee07 3a90 	vmov	s15, r3
70001fa2:	eef8 7a67 	vcvt.f32.u32	s15, s15
70001fa6:	edc7 7a04 	vstr	s15, [r7, #16]

      if (pllm != 0U)
70001faa:	69bb      	ldr	r3, [r7, #24]
70001fac:	2b00      	cmp	r3, #0
70001fae:	f000 80c2 	beq.w	70002136 <HAL_RCC_GetSysClockFreq+0x27a>
      {
        switch (pllsource)
70001fb2:	69fb      	ldr	r3, [r7, #28]
70001fb4:	2b02      	cmp	r3, #2
70001fb6:	d064      	beq.n	70002082 <HAL_RCC_GetSysClockFreq+0x1c6>
70001fb8:	69fb      	ldr	r3, [r7, #28]
70001fba:	2b02      	cmp	r3, #2
70001fbc:	f200 8083 	bhi.w	700020c6 <HAL_RCC_GetSysClockFreq+0x20a>
70001fc0:	69fb      	ldr	r3, [r7, #28]
70001fc2:	2b00      	cmp	r3, #0
70001fc4:	d003      	beq.n	70001fce <HAL_RCC_GetSysClockFreq+0x112>
70001fc6:	69fb      	ldr	r3, [r7, #28]
70001fc8:	2b01      	cmp	r3, #1
70001fca:	d038      	beq.n	7000203e <HAL_RCC_GetSysClockFreq+0x182>
70001fcc:	e07b      	b.n	700020c6 <HAL_RCC_GetSysClockFreq+0x20a>
        {
          case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */

            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70001fce:	4b67      	ldr	r3, [pc, #412]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001fd0:	681b      	ldr	r3, [r3, #0]
70001fd2:	f003 0320 	and.w	r3, r3, #32
70001fd6:	2b00      	cmp	r3, #0
70001fd8:	d02d      	beq.n	70002036 <HAL_RCC_GetSysClockFreq+0x17a>
            {
              hsivalue = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70001fda:	4b64      	ldr	r3, [pc, #400]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70001fdc:	681b      	ldr	r3, [r3, #0]
70001fde:	08db      	lsrs	r3, r3, #3
70001fe0:	f003 0303 	and.w	r3, r3, #3
70001fe4:	4a62      	ldr	r2, [pc, #392]	@ (70002170 <HAL_RCC_GetSysClockFreq+0x2b4>)
70001fe6:	fa22 f303 	lsr.w	r3, r2, r3
70001fea:	60fb      	str	r3, [r7, #12]
              pllvco = ((float_t)hsivalue / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
70001fec:	68fb      	ldr	r3, [r7, #12]
70001fee:	ee07 3a90 	vmov	s15, r3
70001ff2:	eef8 6a67 	vcvt.f32.u32	s13, s15
70001ff6:	69bb      	ldr	r3, [r7, #24]
70001ff8:	ee07 3a90 	vmov	s15, r3
70001ffc:	eef8 7a67 	vcvt.f32.u32	s15, s15
70002000:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70002004:	4b59      	ldr	r3, [pc, #356]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70002006:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70002008:	f3c3 0308 	ubfx	r3, r3, #0, #9
7000200c:	ee07 3a90 	vmov	s15, r3
70002010:	eef8 6a67 	vcvt.f32.u32	s13, s15
70002014:	ed97 6a04 	vldr	s12, [r7, #16]
70002018:	eddf 5a58 	vldr	s11, [pc, #352]	@ 7000217c <HAL_RCC_GetSysClockFreq+0x2c0>
7000201c:	eec6 7a25 	vdiv.f32	s15, s12, s11
70002020:	ee76 7aa7 	vadd.f32	s15, s13, s15
70002024:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70002028:	ee77 7aa6 	vadd.f32	s15, s15, s13
7000202c:	ee67 7a27 	vmul.f32	s15, s14, s15
70002030:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            else
            {
              /* Can't retrieve HSIDIV value */
              pllvco = (float_t)0;
            }
            break;
70002034:	e069      	b.n	7000210a <HAL_RCC_GetSysClockFreq+0x24e>
              pllvco = (float_t)0;
70002036:	f04f 0300 	mov.w	r3, #0
7000203a:	627b      	str	r3, [r7, #36]	@ 0x24
            break;
7000203c:	e065      	b.n	7000210a <HAL_RCC_GetSysClockFreq+0x24e>

          case RCC_PLLSOURCE_CSI:  /* CSI used as PLL clock source */
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
7000203e:	69bb      	ldr	r3, [r7, #24]
70002040:	ee07 3a90 	vmov	s15, r3
70002044:	eef8 7a67 	vcvt.f32.u32	s15, s15
70002048:	eddf 6a4d 	vldr	s13, [pc, #308]	@ 70002180 <HAL_RCC_GetSysClockFreq+0x2c4>
7000204c:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70002050:	4b46      	ldr	r3, [pc, #280]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70002052:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70002054:	f3c3 0308 	ubfx	r3, r3, #0, #9
70002058:	ee07 3a90 	vmov	s15, r3
7000205c:	eef8 6a67 	vcvt.f32.u32	s13, s15
70002060:	ed97 6a04 	vldr	s12, [r7, #16]
70002064:	eddf 5a45 	vldr	s11, [pc, #276]	@ 7000217c <HAL_RCC_GetSysClockFreq+0x2c0>
70002068:	eec6 7a25 	vdiv.f32	s15, s12, s11
7000206c:	ee76 7aa7 	vadd.f32	s15, s13, s15
70002070:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
70002074:	ee77 7aa6 	vadd.f32	s15, s15, s13
70002078:	ee67 7a27 	vmul.f32	s15, s14, s15
7000207c:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
70002080:	e043      	b.n	7000210a <HAL_RCC_GetSysClockFreq+0x24e>

          case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
            pllvco = ((float_t)HSE_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
70002082:	69bb      	ldr	r3, [r7, #24]
70002084:	ee07 3a90 	vmov	s15, r3
70002088:	eef8 7a67 	vcvt.f32.u32	s15, s15
7000208c:	eddf 6a3d 	vldr	s13, [pc, #244]	@ 70002184 <HAL_RCC_GetSysClockFreq+0x2c8>
70002090:	ee86 7aa7 	vdiv.f32	s14, s13, s15
70002094:	4b35      	ldr	r3, [pc, #212]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70002096:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70002098:	f3c3 0308 	ubfx	r3, r3, #0, #9
7000209c:	ee07 3a90 	vmov	s15, r3
700020a0:	eef8 6a67 	vcvt.f32.u32	s13, s15
700020a4:	ed97 6a04 	vldr	s12, [r7, #16]
700020a8:	eddf 5a34 	vldr	s11, [pc, #208]	@ 7000217c <HAL_RCC_GetSysClockFreq+0x2c0>
700020ac:	eec6 7a25 	vdiv.f32	s15, s12, s11
700020b0:	ee76 7aa7 	vadd.f32	s15, s13, s15
700020b4:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
700020b8:	ee77 7aa6 	vadd.f32	s15, s15, s13
700020bc:	ee67 7a27 	vmul.f32	s15, s14, s15
700020c0:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
700020c4:	e021      	b.n	7000210a <HAL_RCC_GetSysClockFreq+0x24e>

          default:
            pllvco = ((float_t)CSI_VALUE / (float_t)pllm) * ((float_t)(uint32_t)(RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVN) + (fracn1 / (float_t)0x2000) + (float_t)1);
700020c6:	69bb      	ldr	r3, [r7, #24]
700020c8:	ee07 3a90 	vmov	s15, r3
700020cc:	eef8 7a67 	vcvt.f32.u32	s15, s15
700020d0:	eddf 6a2b 	vldr	s13, [pc, #172]	@ 70002180 <HAL_RCC_GetSysClockFreq+0x2c4>
700020d4:	ee86 7aa7 	vdiv.f32	s14, s13, s15
700020d8:	4b24      	ldr	r3, [pc, #144]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
700020da:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
700020dc:	f3c3 0308 	ubfx	r3, r3, #0, #9
700020e0:	ee07 3a90 	vmov	s15, r3
700020e4:	eef8 6a67 	vcvt.f32.u32	s13, s15
700020e8:	ed97 6a04 	vldr	s12, [r7, #16]
700020ec:	eddf 5a23 	vldr	s11, [pc, #140]	@ 7000217c <HAL_RCC_GetSysClockFreq+0x2c0>
700020f0:	eec6 7a25 	vdiv.f32	s15, s12, s11
700020f4:	ee76 7aa7 	vadd.f32	s15, s13, s15
700020f8:	eef7 6a00 	vmov.f32	s13, #112	@ 0x3f800000  1.0
700020fc:	ee77 7aa6 	vadd.f32	s15, s15, s13
70002100:	ee67 7a27 	vmul.f32	s15, s14, s15
70002104:	edc7 7a09 	vstr	s15, [r7, #36]	@ 0x24
            break;
70002108:	bf00      	nop
        }
        pllp = (((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVP) >> RCC_PLL1DIVR1_DIVP_Pos) + 1U) ;
7000210a:	4b18      	ldr	r3, [pc, #96]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
7000210c:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
7000210e:	0a5b      	lsrs	r3, r3, #9
70002110:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
70002114:	3301      	adds	r3, #1
70002116:	60bb      	str	r3, [r7, #8]
        sysclockfreq = (uint32_t)(float_t)(pllvco / (float_t)pllp);
70002118:	68bb      	ldr	r3, [r7, #8]
7000211a:	ee07 3a90 	vmov	s15, r3
7000211e:	eeb8 7a67 	vcvt.f32.u32	s14, s15
70002122:	edd7 6a09 	vldr	s13, [r7, #36]	@ 0x24
70002126:	eec6 7a87 	vdiv.f32	s15, s13, s14
7000212a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
7000212e:	ee17 3a90 	vmov	r3, s15
70002132:	623b      	str	r3, [r7, #32]
      }
      else
      {
        sysclockfreq = 0U;
      }
      break;
70002134:	e005      	b.n	70002142 <HAL_RCC_GetSysClockFreq+0x286>
        sysclockfreq = 0U;
70002136:	2300      	movs	r3, #0
70002138:	623b      	str	r3, [r7, #32]
      break;
7000213a:	e002      	b.n	70002142 <HAL_RCC_GetSysClockFreq+0x286>

    default:
      sysclockfreq = CSI_VALUE;
7000213c:	4b0d      	ldr	r3, [pc, #52]	@ (70002174 <HAL_RCC_GetSysClockFreq+0x2b8>)
7000213e:	623b      	str	r3, [r7, #32]
      break;
70002140:	bf00      	nop
  }

  prescaler = RCC->CDCFGR & RCC_CDCFGR_CPRE;
70002142:	4b0a      	ldr	r3, [pc, #40]	@ (7000216c <HAL_RCC_GetSysClockFreq+0x2b0>)
70002144:	699b      	ldr	r3, [r3, #24]
70002146:	f003 030f 	and.w	r3, r3, #15
7000214a:	607b      	str	r3, [r7, #4]
  if (prescaler >= 8U)
7000214c:	687b      	ldr	r3, [r7, #4]
7000214e:	2b07      	cmp	r3, #7
70002150:	d905      	bls.n	7000215e <HAL_RCC_GetSysClockFreq+0x2a2>
  {
    sysclockfreq = sysclockfreq >> (prescaler - RCC_CDCFGR_CPRE_3 + 1U);
70002152:	687b      	ldr	r3, [r7, #4]
70002154:	3b07      	subs	r3, #7
70002156:	6a3a      	ldr	r2, [r7, #32]
70002158:	fa22 f303 	lsr.w	r3, r2, r3
7000215c:	623b      	str	r3, [r7, #32]
  }

  return sysclockfreq;
7000215e:	6a3b      	ldr	r3, [r7, #32]
}
70002160:	4618      	mov	r0, r3
70002162:	372c      	adds	r7, #44	@ 0x2c
70002164:	46bd      	mov	sp, r7
70002166:	f85d 7b04 	ldr.w	r7, [sp], #4
7000216a:	4770      	bx	lr
7000216c:	58024400 	.word	0x58024400
70002170:	03d09000 	.word	0x03d09000
70002174:	003d0900 	.word	0x003d0900
70002178:	016e3600 	.word	0x016e3600
7000217c:	46000000 	.word	0x46000000
70002180:	4a742400 	.word	0x4a742400
70002184:	4bb71b00 	.word	0x4bb71b00

70002188 <HAL_RCC_GetHCLKFreq>:
/**
  * @brief  Return the HCLK frequency.
  * @retval HCLK frequency in Hz
  */
uint32_t HAL_RCC_GetHCLKFreq(void)
{
70002188:	b580      	push	{r7, lr}
7000218a:	b084      	sub	sp, #16
7000218c:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  const uint8_t AHBPrescTable[8] = {1U, 2U, 3U, 4U, 6U, 7U, 8U, 9U};
7000218e:	4a10      	ldr	r2, [pc, #64]	@ (700021d0 <HAL_RCC_GetHCLKFreq+0x48>)
70002190:	463b      	mov	r3, r7
70002192:	e892 0003 	ldmia.w	r2, {r0, r1}
70002196:	e883 0003 	stmia.w	r3, {r0, r1}

  /* SysClk */
  clock = HAL_RCC_GetSysClockFreq();
7000219a:	f7ff fe8f 	bl	70001ebc <HAL_RCC_GetSysClockFreq>
7000219e:	60f8      	str	r0, [r7, #12]
  /* Bus matrix divider */
  prescaler = (RCC->BMCFGR & RCC_BMCFGR_BMPRE) >> RCC_BMCFGR_BMPRE_Pos;
700021a0:	4b0c      	ldr	r3, [pc, #48]	@ (700021d4 <HAL_RCC_GetHCLKFreq+0x4c>)
700021a2:	69db      	ldr	r3, [r3, #28]
700021a4:	f003 030f 	and.w	r3, r3, #15
700021a8:	60bb      	str	r3, [r7, #8]
  if (prescaler >= 8U)
700021aa:	68bb      	ldr	r3, [r7, #8]
700021ac:	2b07      	cmp	r3, #7
700021ae:	d909      	bls.n	700021c4 <HAL_RCC_GetHCLKFreq+0x3c>
  {
    clock = clock >> AHBPrescTable[prescaler - 8U];
700021b0:	68bb      	ldr	r3, [r7, #8]
700021b2:	3b08      	subs	r3, #8
700021b4:	3310      	adds	r3, #16
700021b6:	443b      	add	r3, r7
700021b8:	f813 3c10 	ldrb.w	r3, [r3, #-16]
700021bc:	461a      	mov	r2, r3
700021be:	68fb      	ldr	r3, [r7, #12]
700021c0:	40d3      	lsrs	r3, r2
700021c2:	60fb      	str	r3, [r7, #12]
  }
  return (clock);
700021c4:	68fb      	ldr	r3, [r7, #12]
}
700021c6:	4618      	mov	r0, r3
700021c8:	3710      	adds	r7, #16
700021ca:	46bd      	mov	sp, r7
700021cc:	bd80      	pop	{r7, pc}
700021ce:	bf00      	nop
700021d0:	70009e20 	.word	0x70009e20
700021d4:	58024400 	.word	0x58024400

700021d8 <HAL_RCC_GetPCLK1Freq>:
  * @note   Each time PCLK1 changes, this function must be called to update the
  *         right PCLK1 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK1 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK1Freq(void)
{
700021d8:	b580      	push	{r7, lr}
700021da:	b082      	sub	sp, #8
700021dc:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK1 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
700021de:	f7ff ffd3 	bl	70002188 <HAL_RCC_GetHCLKFreq>
700021e2:	6078      	str	r0, [r7, #4]
  /* APB1 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE1) >> RCC_APBCFGR_PPRE1_Pos;
700021e4:	4b09      	ldr	r3, [pc, #36]	@ (7000220c <HAL_RCC_GetPCLK1Freq+0x34>)
700021e6:	6a1b      	ldr	r3, [r3, #32]
700021e8:	f003 0307 	and.w	r3, r3, #7
700021ec:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
700021ee:	683b      	ldr	r3, [r7, #0]
700021f0:	2b03      	cmp	r3, #3
700021f2:	d905      	bls.n	70002200 <HAL_RCC_GetPCLK1Freq+0x28>
  {
    clock = clock >> (prescaler - 3U);
700021f4:	683b      	ldr	r3, [r7, #0]
700021f6:	3b03      	subs	r3, #3
700021f8:	687a      	ldr	r2, [r7, #4]
700021fa:	fa22 f303 	lsr.w	r3, r2, r3
700021fe:	607b      	str	r3, [r7, #4]
  }
  return (clock);
70002200:	687b      	ldr	r3, [r7, #4]
}
70002202:	4618      	mov	r0, r3
70002204:	3708      	adds	r7, #8
70002206:	46bd      	mov	sp, r7
70002208:	bd80      	pop	{r7, pc}
7000220a:	bf00      	nop
7000220c:	58024400 	.word	0x58024400

70002210 <HAL_RCC_GetPCLK2Freq>:
  * @note   Each time PCLK2 changes, this function must be called to update the
  *         right PCLK2 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK2 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK2Freq(void)
{
70002210:	b580      	push	{r7, lr}
70002212:	b082      	sub	sp, #8
70002214:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK2 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
70002216:	f7ff ffb7 	bl	70002188 <HAL_RCC_GetHCLKFreq>
7000221a:	6078      	str	r0, [r7, #4]
  /* APB2 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE2) >> RCC_APBCFGR_PPRE2_Pos;
7000221c:	4b09      	ldr	r3, [pc, #36]	@ (70002244 <HAL_RCC_GetPCLK2Freq+0x34>)
7000221e:	6a1b      	ldr	r3, [r3, #32]
70002220:	091b      	lsrs	r3, r3, #4
70002222:	f003 0307 	and.w	r3, r3, #7
70002226:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
70002228:	683b      	ldr	r3, [r7, #0]
7000222a:	2b03      	cmp	r3, #3
7000222c:	d905      	bls.n	7000223a <HAL_RCC_GetPCLK2Freq+0x2a>
  {
    clock = clock >> (prescaler - 3U);
7000222e:	683b      	ldr	r3, [r7, #0]
70002230:	3b03      	subs	r3, #3
70002232:	687a      	ldr	r2, [r7, #4]
70002234:	fa22 f303 	lsr.w	r3, r2, r3
70002238:	607b      	str	r3, [r7, #4]
  }
  return (clock);
7000223a:	687b      	ldr	r3, [r7, #4]
}
7000223c:	4618      	mov	r0, r3
7000223e:	3708      	adds	r7, #8
70002240:	46bd      	mov	sp, r7
70002242:	bd80      	pop	{r7, pc}
70002244:	58024400 	.word	0x58024400

70002248 <HAL_RCC_GetPCLK4Freq>:
  * @note   Each time PCLK4 changes, this function must be called to update the
  *         right PCLK4 value. Otherwise, any configuration based on this function will be incorrect.
  * @retval PCLK4 frequency in Hz
  */
uint32_t HAL_RCC_GetPCLK4Freq(void)
{
70002248:	b580      	push	{r7, lr}
7000224a:	b082      	sub	sp, #8
7000224c:	af00      	add	r7, sp, #0
  uint32_t clock;
  uint32_t prescaler;
  /* Get HCLK source and compute PCLK4 frequency ---------------------------*/
  clock = HAL_RCC_GetHCLKFreq();
7000224e:	f7ff ff9b 	bl	70002188 <HAL_RCC_GetHCLKFreq>
70002252:	6078      	str	r0, [r7, #4]
  /* APB4 prescaler */
  prescaler = (RCC->APBCFGR & RCC_APBCFGR_PPRE4) >> RCC_APBCFGR_PPRE4_Pos;
70002254:	4b09      	ldr	r3, [pc, #36]	@ (7000227c <HAL_RCC_GetPCLK4Freq+0x34>)
70002256:	6a1b      	ldr	r3, [r3, #32]
70002258:	0a1b      	lsrs	r3, r3, #8
7000225a:	f003 0307 	and.w	r3, r3, #7
7000225e:	603b      	str	r3, [r7, #0]
  if (prescaler >= 4U)
70002260:	683b      	ldr	r3, [r7, #0]
70002262:	2b03      	cmp	r3, #3
70002264:	d905      	bls.n	70002272 <HAL_RCC_GetPCLK4Freq+0x2a>
  {
    clock = clock >> (prescaler - 3U);
70002266:	683b      	ldr	r3, [r7, #0]
70002268:	3b03      	subs	r3, #3
7000226a:	687a      	ldr	r2, [r7, #4]
7000226c:	fa22 f303 	lsr.w	r3, r2, r3
70002270:	607b      	str	r3, [r7, #4]
  }
  return (clock);
70002272:	687b      	ldr	r3, [r7, #4]
}
70002274:	4618      	mov	r0, r3
70002276:	3708      	adds	r7, #8
70002278:	46bd      	mov	sp, r7
7000227a:	bd80      	pop	{r7, pc}
7000227c:	58024400 	.word	0x58024400

70002280 <HAL_RCC_GetPLL1QFreq>:
/**
  * @brief  Return the PLL1Q frequency.
  * @retval PLL1Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL1QFreq(void)
{
70002280:	b580      	push	{r7, lr}
70002282:	b082      	sub	sp, #8
70002284:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL1Q divider */
  pllq = ((RCC->PLL1DIVR1 & RCC_PLL1DIVR1_DIVQ) >> RCC_PLL1DIVR1_DIVQ_Pos) + 1U;
70002286:	4b08      	ldr	r3, [pc, #32]	@ (700022a8 <HAL_RCC_GetPLL1QFreq+0x28>)
70002288:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
7000228a:	0c1b      	lsrs	r3, r3, #16
7000228c:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
70002290:	3301      	adds	r3, #1
70002292:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL1Q one */
  return ((uint32_t)RCC_PLL1_GetVCOOutputFreq() / pllq);
70002294:	f000 f8d2 	bl	7000243c <RCC_PLL1_GetVCOOutputFreq>
70002298:	4602      	mov	r2, r0
7000229a:	687b      	ldr	r3, [r7, #4]
7000229c:	fbb2 f3f3 	udiv	r3, r2, r3
}
700022a0:	4618      	mov	r0, r3
700022a2:	3708      	adds	r7, #8
700022a4:	46bd      	mov	sp, r7
700022a6:	bd80      	pop	{r7, pc}
700022a8:	58024400 	.word	0x58024400

700022ac <HAL_RCC_GetPLL2PFreq>:
/**
  * @brief  Return the PLL2P frequency.
  * @retval PLL2P frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2PFreq(void)
{
700022ac:	b580      	push	{r7, lr}
700022ae:	b082      	sub	sp, #8
700022b0:	af00      	add	r7, sp, #0
  uint32_t pllp;

  /* PLL2P divider */
  pllp = ((RCC->PLL2DIVR1 & RCC_PLL2DIVR1_DIVP) >> RCC_PLL2DIVR1_DIVP_Pos) + 1U;
700022b2:	4b08      	ldr	r3, [pc, #32]	@ (700022d4 <HAL_RCC_GetPLL2PFreq+0x28>)
700022b4:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
700022b6:	0a5b      	lsrs	r3, r3, #9
700022b8:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
700022bc:	3301      	adds	r3, #1
700022be:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2P one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllp);
700022c0:	f000 f942 	bl	70002548 <RCC_PLL2_GetVCOOutputFreq>
700022c4:	4602      	mov	r2, r0
700022c6:	687b      	ldr	r3, [r7, #4]
700022c8:	fbb2 f3f3 	udiv	r3, r2, r3
}
700022cc:	4618      	mov	r0, r3
700022ce:	3708      	adds	r7, #8
700022d0:	46bd      	mov	sp, r7
700022d2:	bd80      	pop	{r7, pc}
700022d4:	58024400 	.word	0x58024400

700022d8 <HAL_RCC_GetPLL2QFreq>:
/**
  * @brief  Return the PLL2Q frequency.
  * @retval PLL2Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2QFreq(void)
{
700022d8:	b580      	push	{r7, lr}
700022da:	b082      	sub	sp, #8
700022dc:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL2Q divider */
  pllq = ((RCC->PLL2DIVR1 & RCC_PLL2DIVR1_DIVQ) >> RCC_PLL2DIVR1_DIVQ_Pos) + 1U;
700022de:	4b08      	ldr	r3, [pc, #32]	@ (70002300 <HAL_RCC_GetPLL2QFreq+0x28>)
700022e0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
700022e2:	0c1b      	lsrs	r3, r3, #16
700022e4:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
700022e8:	3301      	adds	r3, #1
700022ea:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2Q one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllq);
700022ec:	f000 f92c 	bl	70002548 <RCC_PLL2_GetVCOOutputFreq>
700022f0:	4602      	mov	r2, r0
700022f2:	687b      	ldr	r3, [r7, #4]
700022f4:	fbb2 f3f3 	udiv	r3, r2, r3
}
700022f8:	4618      	mov	r0, r3
700022fa:	3708      	adds	r7, #8
700022fc:	46bd      	mov	sp, r7
700022fe:	bd80      	pop	{r7, pc}
70002300:	58024400 	.word	0x58024400

70002304 <HAL_RCC_GetPLL2RFreq>:
/**
  * @brief  Return the PLL2R frequency.
  * @retval PLL2R frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2RFreq(void)
{
70002304:	b580      	push	{r7, lr}
70002306:	b082      	sub	sp, #8
70002308:	af00      	add	r7, sp, #0
  uint32_t pllr;

  /* PLL2R divider */
  pllr = ((RCC->PLL2DIVR1 & RCC_PLL2DIVR1_DIVR) >> RCC_PLL2DIVR1_DIVR_Pos) + 1U;
7000230a:	4b08      	ldr	r3, [pc, #32]	@ (7000232c <HAL_RCC_GetPLL2RFreq+0x28>)
7000230c:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
7000230e:	0e1b      	lsrs	r3, r3, #24
70002310:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
70002314:	3301      	adds	r3, #1
70002316:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2R one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllr);
70002318:	f000 f916 	bl	70002548 <RCC_PLL2_GetVCOOutputFreq>
7000231c:	4602      	mov	r2, r0
7000231e:	687b      	ldr	r3, [r7, #4]
70002320:	fbb2 f3f3 	udiv	r3, r2, r3
}
70002324:	4618      	mov	r0, r3
70002326:	3708      	adds	r7, #8
70002328:	46bd      	mov	sp, r7
7000232a:	bd80      	pop	{r7, pc}
7000232c:	58024400 	.word	0x58024400

70002330 <HAL_RCC_GetPLL2SFreq>:
/**
  * @brief  Return the PLL2S frequency.
  * @retval PLL2S frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2SFreq(void)
{
70002330:	b580      	push	{r7, lr}
70002332:	b082      	sub	sp, #8
70002334:	af00      	add	r7, sp, #0
  uint32_t plls;

  /* PLL2S divider */
  plls = ((RCC->PLL2DIVR2 & RCC_PLL2DIVR2_DIVS) >> RCC_PLL2DIVR2_DIVS_Pos) + 1U;
70002336:	4b08      	ldr	r3, [pc, #32]	@ (70002358 <HAL_RCC_GetPLL2SFreq+0x28>)
70002338:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
7000233c:	f003 0307 	and.w	r3, r3, #7
70002340:	3301      	adds	r3, #1
70002342:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2R one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / plls);
70002344:	f000 f900 	bl	70002548 <RCC_PLL2_GetVCOOutputFreq>
70002348:	4602      	mov	r2, r0
7000234a:	687b      	ldr	r3, [r7, #4]
7000234c:	fbb2 f3f3 	udiv	r3, r2, r3
}
70002350:	4618      	mov	r0, r3
70002352:	3708      	adds	r7, #8
70002354:	46bd      	mov	sp, r7
70002356:	bd80      	pop	{r7, pc}
70002358:	58024400 	.word	0x58024400

7000235c <HAL_RCC_GetPLL2TFreq>:
/**
  * @brief  Return the PLL2T frequency.
  * @retval PLL2T frequency in Hz
  */
uint32_t HAL_RCC_GetPLL2TFreq(void)
{
7000235c:	b580      	push	{r7, lr}
7000235e:	b082      	sub	sp, #8
70002360:	af00      	add	r7, sp, #0
  uint32_t pllt;

  /* PLL2T divider */
  pllt = ((RCC->PLL2DIVR2 & RCC_PLL2DIVR2_DIVT) >> RCC_PLL2DIVR2_DIVT_Pos) + 1U;
70002362:	4b09      	ldr	r3, [pc, #36]	@ (70002388 <HAL_RCC_GetPLL2TFreq+0x2c>)
70002364:	f8d3 30c4 	ldr.w	r3, [r3, #196]	@ 0xc4
70002368:	0a1b      	lsrs	r3, r3, #8
7000236a:	f003 0307 	and.w	r3, r3, #7
7000236e:	3301      	adds	r3, #1
70002370:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL2T one */
  return ((uint32_t)RCC_PLL2_GetVCOOutputFreq() / pllt);
70002372:	f000 f8e9 	bl	70002548 <RCC_PLL2_GetVCOOutputFreq>
70002376:	4602      	mov	r2, r0
70002378:	687b      	ldr	r3, [r7, #4]
7000237a:	fbb2 f3f3 	udiv	r3, r2, r3
}
7000237e:	4618      	mov	r0, r3
70002380:	3708      	adds	r7, #8
70002382:	46bd      	mov	sp, r7
70002384:	bd80      	pop	{r7, pc}
70002386:	bf00      	nop
70002388:	58024400 	.word	0x58024400

7000238c <HAL_RCC_GetPLL3PFreq>:
/**
  * @brief  Return the PLL3P frequency.
  * @retval PLL3P frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3PFreq(void)
{
7000238c:	b580      	push	{r7, lr}
7000238e:	b082      	sub	sp, #8
70002390:	af00      	add	r7, sp, #0
  uint32_t pllp;

  /* PLL3P divider */
  pllp = ((RCC->PLL3DIVR1 & RCC_PLL3DIVR1_DIVP) >> RCC_PLL3DIVR1_DIVP_Pos) + 1U;
70002392:	4b08      	ldr	r3, [pc, #32]	@ (700023b4 <HAL_RCC_GetPLL3PFreq+0x28>)
70002394:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70002396:	0a5b      	lsrs	r3, r3, #9
70002398:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
7000239c:	3301      	adds	r3, #1
7000239e:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3P one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / pllp);
700023a0:	f000 f958 	bl	70002654 <RCC_PLL3_GetVCOOutputFreq>
700023a4:	4602      	mov	r2, r0
700023a6:	687b      	ldr	r3, [r7, #4]
700023a8:	fbb2 f3f3 	udiv	r3, r2, r3
}
700023ac:	4618      	mov	r0, r3
700023ae:	3708      	adds	r7, #8
700023b0:	46bd      	mov	sp, r7
700023b2:	bd80      	pop	{r7, pc}
700023b4:	58024400 	.word	0x58024400

700023b8 <HAL_RCC_GetPLL3QFreq>:
/**
  * @brief  Return the PLL3Q frequency.
  * @retval PLL3Q frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3QFreq(void)
{
700023b8:	b580      	push	{r7, lr}
700023ba:	b082      	sub	sp, #8
700023bc:	af00      	add	r7, sp, #0
  uint32_t pllq;

  /* PLL3Q divider */
  pllq = ((RCC->PLL3DIVR1 & RCC_PLL3DIVR1_DIVQ) >> RCC_PLL3DIVR1_DIVQ_Pos) + 1U;
700023be:	4b08      	ldr	r3, [pc, #32]	@ (700023e0 <HAL_RCC_GetPLL3QFreq+0x28>)
700023c0:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
700023c2:	0c1b      	lsrs	r3, r3, #16
700023c4:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
700023c8:	3301      	adds	r3, #1
700023ca:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3Q one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / pllq);
700023cc:	f000 f942 	bl	70002654 <RCC_PLL3_GetVCOOutputFreq>
700023d0:	4602      	mov	r2, r0
700023d2:	687b      	ldr	r3, [r7, #4]
700023d4:	fbb2 f3f3 	udiv	r3, r2, r3
}
700023d8:	4618      	mov	r0, r3
700023da:	3708      	adds	r7, #8
700023dc:	46bd      	mov	sp, r7
700023de:	bd80      	pop	{r7, pc}
700023e0:	58024400 	.word	0x58024400

700023e4 <HAL_RCC_GetPLL3RFreq>:
/**
  * @brief  Return the PLL3R frequency.
  * @retval PLL3R frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3RFreq(void)
{
700023e4:	b580      	push	{r7, lr}
700023e6:	b082      	sub	sp, #8
700023e8:	af00      	add	r7, sp, #0
  uint32_t pllr;

  /* PLL3R divider */
  pllr = ((RCC->PLL3DIVR1 & RCC_PLL3DIVR1_DIVR) >> RCC_PLL3DIVR1_DIVR_Pos) + 1U;
700023ea:	4b08      	ldr	r3, [pc, #32]	@ (7000240c <HAL_RCC_GetPLL3RFreq+0x28>)
700023ec:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
700023ee:	0e1b      	lsrs	r3, r3, #24
700023f0:	f003 037f 	and.w	r3, r3, #127	@ 0x7f
700023f4:	3301      	adds	r3, #1
700023f6:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3R one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / pllr);
700023f8:	f000 f92c 	bl	70002654 <RCC_PLL3_GetVCOOutputFreq>
700023fc:	4602      	mov	r2, r0
700023fe:	687b      	ldr	r3, [r7, #4]
70002400:	fbb2 f3f3 	udiv	r3, r2, r3
}
70002404:	4618      	mov	r0, r3
70002406:	3708      	adds	r7, #8
70002408:	46bd      	mov	sp, r7
7000240a:	bd80      	pop	{r7, pc}
7000240c:	58024400 	.word	0x58024400

70002410 <HAL_RCC_GetPLL3SFreq>:
/**
  * @brief  Return the PLL3S frequency.
  * @retval PLL3S frequency in Hz
  */
uint32_t HAL_RCC_GetPLL3SFreq(void)
{
70002410:	b580      	push	{r7, lr}
70002412:	b082      	sub	sp, #8
70002414:	af00      	add	r7, sp, #0
  uint32_t plls;

  /* PLL3S divider */
  plls = ((RCC->PLL3DIVR2 & RCC_PLL3DIVR2_DIVS) >> RCC_PLL3DIVR2_DIVS_Pos) + 1U;
70002416:	4b08      	ldr	r3, [pc, #32]	@ (70002438 <HAL_RCC_GetPLL3SFreq+0x28>)
70002418:	f8d3 30c8 	ldr.w	r3, [r3, #200]	@ 0xc8
7000241c:	f003 0307 	and.w	r3, r3, #7
70002420:	3301      	adds	r3, #1
70002422:	607b      	str	r3, [r7, #4]

  /* Compute VCO output frequency and return PLL3S one */
  return ((uint32_t)RCC_PLL3_GetVCOOutputFreq() / plls);
70002424:	f000 f916 	bl	70002654 <RCC_PLL3_GetVCOOutputFreq>
70002428:	4602      	mov	r2, r0
7000242a:	687b      	ldr	r3, [r7, #4]
7000242c:	fbb2 f3f3 	udiv	r3, r2, r3
}
70002430:	4618      	mov	r0, r3
70002432:	3708      	adds	r7, #8
70002434:	46bd      	mov	sp, r7
70002436:	bd80      	pop	{r7, pc}
70002438:	58024400 	.word	0x58024400

7000243c <RCC_PLL1_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL1 VCO output frequency
  * @retval Value of PLL1 VCO output frequency
  */
static uint32_t RCC_PLL1_GetVCOOutputFreq(void)
{
7000243c:	b480      	push	{r7}
7000243e:	b089      	sub	sp, #36	@ 0x24
70002440:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL1 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
70002442:	4b3c      	ldr	r3, [pc, #240]	@ (70002534 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
70002444:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002446:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL1DIVR1;
70002448:	4b3a      	ldr	r3, [pc, #232]	@ (70002534 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
7000244a:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
7000244c:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL1 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM1) >> RCC_PLLCKSELR_DIVM1_Pos;
7000244e:	697b      	ldr	r3, [r7, #20]
70002450:	091b      	lsrs	r3, r3, #4
70002452:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70002456:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL1DIVR1_DIVN) + 1U;
70002458:	693b      	ldr	r3, [r7, #16]
7000245a:	f3c3 0308 	ubfx	r3, r3, #0, #9
7000245e:	3301      	adds	r3, #1
70002460:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
70002462:	68fb      	ldr	r3, [r7, #12]
70002464:	2b00      	cmp	r3, #0
70002466:	d101      	bne.n	7000246c <RCC_PLL1_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
70002468:	2300      	movs	r3, #0
7000246a:	e05c      	b.n	70002526 <RCC_PLL1_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL1FRACEN) != 0U)
7000246c:	4b31      	ldr	r3, [pc, #196]	@ (70002534 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
7000246e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002470:	f003 0301 	and.w	r3, r3, #1
70002474:	2b00      	cmp	r3, #0
70002476:	d006      	beq.n	70002486 <RCC_PLL1_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL1FRACR & RCC_PLL1FRACR_FRACN) >> RCC_PLL1FRACR_FRACN_Pos;
70002478:	4b2e      	ldr	r3, [pc, #184]	@ (70002534 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
7000247a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
7000247c:	08db      	lsrs	r3, r3, #3
7000247e:	f3c3 030c 	ubfx	r3, r3, #0, #13
70002482:	61bb      	str	r3, [r7, #24]
70002484:	e001      	b.n	7000248a <RCC_PLL1_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
70002486:	2300      	movs	r3, #0
70002488:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
7000248a:	697b      	ldr	r3, [r7, #20]
7000248c:	f003 0303 	and.w	r3, r3, #3
70002490:	2b02      	cmp	r3, #2
70002492:	d019      	beq.n	700024c8 <RCC_PLL1_GetVCOOutputFreq+0x8c>
70002494:	2b02      	cmp	r3, #2
70002496:	d81d      	bhi.n	700024d4 <RCC_PLL1_GetVCOOutputFreq+0x98>
70002498:	2b00      	cmp	r3, #0
7000249a:	d002      	beq.n	700024a2 <RCC_PLL1_GetVCOOutputFreq+0x66>
7000249c:	2b01      	cmp	r3, #1
7000249e:	d016      	beq.n	700024ce <RCC_PLL1_GetVCOOutputFreq+0x92>
700024a0:	e018      	b.n	700024d4 <RCC_PLL1_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL1 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
700024a2:	4b24      	ldr	r3, [pc, #144]	@ (70002534 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
700024a4:	681b      	ldr	r3, [r3, #0]
700024a6:	f003 0320 	and.w	r3, r3, #32
700024aa:	2b00      	cmp	r3, #0
700024ac:	d009      	beq.n	700024c2 <RCC_PLL1_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
700024ae:	4b21      	ldr	r3, [pc, #132]	@ (70002534 <RCC_PLL1_GetVCOOutputFreq+0xf8>)
700024b0:	681b      	ldr	r3, [r3, #0]
700024b2:	08db      	lsrs	r3, r3, #3
700024b4:	f003 0303 	and.w	r3, r3, #3
700024b8:	4a1f      	ldr	r2, [pc, #124]	@ (70002538 <RCC_PLL1_GetVCOOutputFreq+0xfc>)
700024ba:	fa22 f303 	lsr.w	r3, r2, r3
700024be:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
700024c0:	e00b      	b.n	700024da <RCC_PLL1_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
700024c2:	2300      	movs	r3, #0
700024c4:	61fb      	str	r3, [r7, #28]
      break;
700024c6:	e008      	b.n	700024da <RCC_PLL1_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL1 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
700024c8:	4b1c      	ldr	r3, [pc, #112]	@ (7000253c <RCC_PLL1_GetVCOOutputFreq+0x100>)
700024ca:	61fb      	str	r3, [r7, #28]
      break;
700024cc:	e005      	b.n	700024da <RCC_PLL1_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL1 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
700024ce:	4b1c      	ldr	r3, [pc, #112]	@ (70002540 <RCC_PLL1_GetVCOOutputFreq+0x104>)
700024d0:	61fb      	str	r3, [r7, #28]
      break;
700024d2:	e002      	b.n	700024da <RCC_PLL1_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
700024d4:	2300      	movs	r3, #0
700024d6:	61fb      	str	r3, [r7, #28]
      break;
700024d8:	bf00      	nop
  }
  
  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
700024da:	69fb      	ldr	r3, [r7, #28]
700024dc:	ee07 3a90 	vmov	s15, r3
700024e0:	eef8 6a67 	vcvt.f32.u32	s13, s15
700024e4:	68fb      	ldr	r3, [r7, #12]
700024e6:	ee07 3a90 	vmov	s15, r3
700024ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
700024ee:	ee86 7aa7 	vdiv.f32	s14, s13, s15
700024f2:	68bb      	ldr	r3, [r7, #8]
700024f4:	ee07 3a90 	vmov	s15, r3
700024f8:	eef8 6a67 	vcvt.f32.u32	s13, s15
700024fc:	69bb      	ldr	r3, [r7, #24]
700024fe:	ee07 3a90 	vmov	s15, r3
70002502:	eeb8 6a67 	vcvt.f32.u32	s12, s15
70002506:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 70002544 <RCC_PLL1_GetVCOOutputFreq+0x108>
7000250a:	eec6 7a25 	vdiv.f32	s15, s12, s11
7000250e:	ee76 7aa7 	vadd.f32	s15, s13, s15
70002512:	ee67 7a27 	vmul.f32	s15, s14, s15
70002516:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
7000251a:	edd7 7a01 	vldr	s15, [r7, #4]
7000251e:	eefc 7ae7 	vcvt.u32.f32	s15, s15
70002522:	ee17 3a90 	vmov	r3, s15
}
70002526:	4618      	mov	r0, r3
70002528:	3724      	adds	r7, #36	@ 0x24
7000252a:	46bd      	mov	sp, r7
7000252c:	f85d 7b04 	ldr.w	r7, [sp], #4
70002530:	4770      	bx	lr
70002532:	bf00      	nop
70002534:	58024400 	.word	0x58024400
70002538:	03d09000 	.word	0x03d09000
7000253c:	016e3600 	.word	0x016e3600
70002540:	003d0900 	.word	0x003d0900
70002544:	46000000 	.word	0x46000000

70002548 <RCC_PLL2_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL2 VCO output frequency
  * @retval Value of PLL2 VCO output frequency
  */
static uint32_t RCC_PLL2_GetVCOOutputFreq(void)
{
70002548:	b480      	push	{r7}
7000254a:	b089      	sub	sp, #36	@ 0x24
7000254c:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL2 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
7000254e:	4b3c      	ldr	r3, [pc, #240]	@ (70002640 <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70002550:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002552:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL2DIVR1;
70002554:	4b3a      	ldr	r3, [pc, #232]	@ (70002640 <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70002556:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70002558:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL2 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM2) >> RCC_PLLCKSELR_DIVM2_Pos;
7000255a:	697b      	ldr	r3, [r7, #20]
7000255c:	0b1b      	lsrs	r3, r3, #12
7000255e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70002562:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL2DIVR1_DIVN) + 1U;
70002564:	693b      	ldr	r3, [r7, #16]
70002566:	f3c3 0308 	ubfx	r3, r3, #0, #9
7000256a:	3301      	adds	r3, #1
7000256c:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
7000256e:	68fb      	ldr	r3, [r7, #12]
70002570:	2b00      	cmp	r3, #0
70002572:	d101      	bne.n	70002578 <RCC_PLL2_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
70002574:	2300      	movs	r3, #0
70002576:	e05c      	b.n	70002632 <RCC_PLL2_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL2FRACEN) != 0U)
70002578:	4b31      	ldr	r3, [pc, #196]	@ (70002640 <RCC_PLL2_GetVCOOutputFreq+0xf8>)
7000257a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000257c:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
70002580:	2b00      	cmp	r3, #0
70002582:	d006      	beq.n	70002592 <RCC_PLL2_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL2FRACR & RCC_PLL2FRACR_FRACN) >> RCC_PLL2FRACR_FRACN_Pos;
70002584:	4b2e      	ldr	r3, [pc, #184]	@ (70002640 <RCC_PLL2_GetVCOOutputFreq+0xf8>)
70002586:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
70002588:	08db      	lsrs	r3, r3, #3
7000258a:	f3c3 030c 	ubfx	r3, r3, #0, #13
7000258e:	61bb      	str	r3, [r7, #24]
70002590:	e001      	b.n	70002596 <RCC_PLL2_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
70002592:	2300      	movs	r3, #0
70002594:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
70002596:	697b      	ldr	r3, [r7, #20]
70002598:	f003 0303 	and.w	r3, r3, #3
7000259c:	2b02      	cmp	r3, #2
7000259e:	d019      	beq.n	700025d4 <RCC_PLL2_GetVCOOutputFreq+0x8c>
700025a0:	2b02      	cmp	r3, #2
700025a2:	d81d      	bhi.n	700025e0 <RCC_PLL2_GetVCOOutputFreq+0x98>
700025a4:	2b00      	cmp	r3, #0
700025a6:	d002      	beq.n	700025ae <RCC_PLL2_GetVCOOutputFreq+0x66>
700025a8:	2b01      	cmp	r3, #1
700025aa:	d016      	beq.n	700025da <RCC_PLL2_GetVCOOutputFreq+0x92>
700025ac:	e018      	b.n	700025e0 <RCC_PLL2_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL2 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
700025ae:	4b24      	ldr	r3, [pc, #144]	@ (70002640 <RCC_PLL2_GetVCOOutputFreq+0xf8>)
700025b0:	681b      	ldr	r3, [r3, #0]
700025b2:	f003 0320 	and.w	r3, r3, #32
700025b6:	2b00      	cmp	r3, #0
700025b8:	d009      	beq.n	700025ce <RCC_PLL2_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
700025ba:	4b21      	ldr	r3, [pc, #132]	@ (70002640 <RCC_PLL2_GetVCOOutputFreq+0xf8>)
700025bc:	681b      	ldr	r3, [r3, #0]
700025be:	08db      	lsrs	r3, r3, #3
700025c0:	f003 0303 	and.w	r3, r3, #3
700025c4:	4a1f      	ldr	r2, [pc, #124]	@ (70002644 <RCC_PLL2_GetVCOOutputFreq+0xfc>)
700025c6:	fa22 f303 	lsr.w	r3, r2, r3
700025ca:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
700025cc:	e00b      	b.n	700025e6 <RCC_PLL2_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
700025ce:	2300      	movs	r3, #0
700025d0:	61fb      	str	r3, [r7, #28]
      break;
700025d2:	e008      	b.n	700025e6 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL2 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
700025d4:	4b1c      	ldr	r3, [pc, #112]	@ (70002648 <RCC_PLL2_GetVCOOutputFreq+0x100>)
700025d6:	61fb      	str	r3, [r7, #28]
      break;
700025d8:	e005      	b.n	700025e6 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL2 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
700025da:	4b1c      	ldr	r3, [pc, #112]	@ (7000264c <RCC_PLL2_GetVCOOutputFreq+0x104>)
700025dc:	61fb      	str	r3, [r7, #28]
      break;
700025de:	e002      	b.n	700025e6 <RCC_PLL2_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
700025e0:	2300      	movs	r3, #0
700025e2:	61fb      	str	r3, [r7, #28]
      break;
700025e4:	bf00      	nop
  }

  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
700025e6:	69fb      	ldr	r3, [r7, #28]
700025e8:	ee07 3a90 	vmov	s15, r3
700025ec:	eef8 6a67 	vcvt.f32.u32	s13, s15
700025f0:	68fb      	ldr	r3, [r7, #12]
700025f2:	ee07 3a90 	vmov	s15, r3
700025f6:	eef8 7a67 	vcvt.f32.u32	s15, s15
700025fa:	ee86 7aa7 	vdiv.f32	s14, s13, s15
700025fe:	68bb      	ldr	r3, [r7, #8]
70002600:	ee07 3a90 	vmov	s15, r3
70002604:	eef8 6a67 	vcvt.f32.u32	s13, s15
70002608:	69bb      	ldr	r3, [r7, #24]
7000260a:	ee07 3a90 	vmov	s15, r3
7000260e:	eeb8 6a67 	vcvt.f32.u32	s12, s15
70002612:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 70002650 <RCC_PLL2_GetVCOOutputFreq+0x108>
70002616:	eec6 7a25 	vdiv.f32	s15, s12, s11
7000261a:	ee76 7aa7 	vadd.f32	s15, s13, s15
7000261e:	ee67 7a27 	vmul.f32	s15, s14, s15
70002622:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
70002626:	edd7 7a01 	vldr	s15, [r7, #4]
7000262a:	eefc 7ae7 	vcvt.u32.f32	s15, s15
7000262e:	ee17 3a90 	vmov	r3, s15
}
70002632:	4618      	mov	r0, r3
70002634:	3724      	adds	r7, #36	@ 0x24
70002636:	46bd      	mov	sp, r7
70002638:	f85d 7b04 	ldr.w	r7, [sp], #4
7000263c:	4770      	bx	lr
7000263e:	bf00      	nop
70002640:	58024400 	.word	0x58024400
70002644:	03d09000 	.word	0x03d09000
70002648:	016e3600 	.word	0x016e3600
7000264c:	003d0900 	.word	0x003d0900
70002650:	46000000 	.word	0x46000000

70002654 <RCC_PLL3_GetVCOOutputFreq>:
/**
  * @brief  Compute PLL3 VCO output frequency
  * @retval Value of PLL3 VCO output frequency
  */
static uint32_t RCC_PLL3_GetVCOOutputFreq(void)
{
70002654:	b480      	push	{r7}
70002656:	b089      	sub	sp, #36	@ 0x24
70002658:	af00      	add	r7, sp, #0
  uint32_t plln;
  uint32_t pllfracn;
  float_t frequency;

  /* Get PLL3 CKSELR and DIVR register values */
  tmpreg1 = RCC->PLLCKSELR;
7000265a:	4b3c      	ldr	r3, [pc, #240]	@ (7000274c <RCC_PLL3_GetVCOOutputFreq+0xf8>)
7000265c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
7000265e:	617b      	str	r3, [r7, #20]
  tmpreg2 = RCC->PLL3DIVR1;
70002660:	4b3a      	ldr	r3, [pc, #232]	@ (7000274c <RCC_PLL3_GetVCOOutputFreq+0xf8>)
70002662:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70002664:	613b      	str	r3, [r7, #16]

  /* Retrieve PLL3 multiplication factor and divider */
  pllm = (tmpreg1 & RCC_PLLCKSELR_DIVM3) >> RCC_PLLCKSELR_DIVM3_Pos;
70002666:	697b      	ldr	r3, [r7, #20]
70002668:	0d1b      	lsrs	r3, r3, #20
7000266a:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
7000266e:	60fb      	str	r3, [r7, #12]
  plln = (tmpreg2 & RCC_PLL3DIVR1_DIVN) + 1U;
70002670:	693b      	ldr	r3, [r7, #16]
70002672:	f3c3 0308 	ubfx	r3, r3, #0, #9
70002676:	3301      	adds	r3, #1
70002678:	60bb      	str	r3, [r7, #8]

  if (pllm == 0U)
7000267a:	68fb      	ldr	r3, [r7, #12]
7000267c:	2b00      	cmp	r3, #0
7000267e:	d101      	bne.n	70002684 <RCC_PLL3_GetVCOOutputFreq+0x30>
  {
    /* Prescaler disabled */
    return 0U;
70002680:	2300      	movs	r3, #0
70002682:	e05c      	b.n	7000273e <RCC_PLL3_GetVCOOutputFreq+0xea>
  }

  /* Check if fractional part is enable */
  if ((RCC->PLLCFGR & RCC_PLLCFGR_PLL3FRACEN) != 0U)
70002684:	4b31      	ldr	r3, [pc, #196]	@ (7000274c <RCC_PLL3_GetVCOOutputFreq+0xf8>)
70002686:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002688:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
7000268c:	2b00      	cmp	r3, #0
7000268e:	d006      	beq.n	7000269e <RCC_PLL3_GetVCOOutputFreq+0x4a>
  {
    pllfracn = (RCC->PLL3FRACR & RCC_PLL3FRACR_FRACN) >> RCC_PLL3FRACR_FRACN_Pos;
70002690:	4b2e      	ldr	r3, [pc, #184]	@ (7000274c <RCC_PLL3_GetVCOOutputFreq+0xf8>)
70002692:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
70002694:	08db      	lsrs	r3, r3, #3
70002696:	f3c3 030c 	ubfx	r3, r3, #0, #13
7000269a:	61bb      	str	r3, [r7, #24]
7000269c:	e001      	b.n	700026a2 <RCC_PLL3_GetVCOOutputFreq+0x4e>
  }
  else
  {
    pllfracn = 0U;
7000269e:	2300      	movs	r3, #0
700026a0:	61bb      	str	r3, [r7, #24]
  }

  /* determine PLL source */
  switch (tmpreg1 & RCC_PLLCKSELR_PLLSRC)
700026a2:	697b      	ldr	r3, [r7, #20]
700026a4:	f003 0303 	and.w	r3, r3, #3
700026a8:	2b02      	cmp	r3, #2
700026aa:	d019      	beq.n	700026e0 <RCC_PLL3_GetVCOOutputFreq+0x8c>
700026ac:	2b02      	cmp	r3, #2
700026ae:	d81d      	bhi.n	700026ec <RCC_PLL3_GetVCOOutputFreq+0x98>
700026b0:	2b00      	cmp	r3, #0
700026b2:	d002      	beq.n	700026ba <RCC_PLL3_GetVCOOutputFreq+0x66>
700026b4:	2b01      	cmp	r3, #1
700026b6:	d016      	beq.n	700026e6 <RCC_PLL3_GetVCOOutputFreq+0x92>
700026b8:	e018      	b.n	700026ec <RCC_PLL3_GetVCOOutputFreq+0x98>
  {
    /* HSI used as PLL3 clock source */
    case RCC_PLLSOURCE_HSI:
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
700026ba:	4b24      	ldr	r3, [pc, #144]	@ (7000274c <RCC_PLL3_GetVCOOutputFreq+0xf8>)
700026bc:	681b      	ldr	r3, [r3, #0]
700026be:	f003 0320 	and.w	r3, r3, #32
700026c2:	2b00      	cmp	r3, #0
700026c4:	d009      	beq.n	700026da <RCC_PLL3_GetVCOOutputFreq+0x86>
      {
        pllsrc = HSI_VALUE >> ((RCC->CR & RCC_CR_HSIDIV) >> RCC_CR_HSIDIV_Pos);
700026c6:	4b21      	ldr	r3, [pc, #132]	@ (7000274c <RCC_PLL3_GetVCOOutputFreq+0xf8>)
700026c8:	681b      	ldr	r3, [r3, #0]
700026ca:	08db      	lsrs	r3, r3, #3
700026cc:	f003 0303 	and.w	r3, r3, #3
700026d0:	4a1f      	ldr	r2, [pc, #124]	@ (70002750 <RCC_PLL3_GetVCOOutputFreq+0xfc>)
700026d2:	fa22 f303 	lsr.w	r3, r2, r3
700026d6:	61fb      	str	r3, [r7, #28]
      else
      {
        /* Can't retrieve HSIDIV value */
        pllsrc = 0U;
      }
      break;
700026d8:	e00b      	b.n	700026f2 <RCC_PLL3_GetVCOOutputFreq+0x9e>
        pllsrc = 0U;
700026da:	2300      	movs	r3, #0
700026dc:	61fb      	str	r3, [r7, #28]
      break;
700026de:	e008      	b.n	700026f2 <RCC_PLL3_GetVCOOutputFreq+0x9e>

    /* HSE used as PLL3 clock source */
    case RCC_PLLSOURCE_HSE:
      pllsrc = HSE_VALUE;
700026e0:	4b1c      	ldr	r3, [pc, #112]	@ (70002754 <RCC_PLL3_GetVCOOutputFreq+0x100>)
700026e2:	61fb      	str	r3, [r7, #28]
      break;
700026e4:	e005      	b.n	700026f2 <RCC_PLL3_GetVCOOutputFreq+0x9e>

    /* CSI used as PLL3 clock source */
    case RCC_PLLSOURCE_CSI:
      pllsrc = CSI_VALUE;
700026e6:	4b1c      	ldr	r3, [pc, #112]	@ (70002758 <RCC_PLL3_GetVCOOutputFreq+0x104>)
700026e8:	61fb      	str	r3, [r7, #28]
      break;
700026ea:	e002      	b.n	700026f2 <RCC_PLL3_GetVCOOutputFreq+0x9e>

    default:
      pllsrc = 0U;
700026ec:	2300      	movs	r3, #0
700026ee:	61fb      	str	r3, [r7, #28]
      break;
700026f0:	bf00      	nop
  }

  /* Compute VCO output frequency */
  frequency = ((float_t)pllsrc / (float_t)pllm) * ((float_t)plln + ((float_t)pllfracn / (float_t)0x2000U));
700026f2:	69fb      	ldr	r3, [r7, #28]
700026f4:	ee07 3a90 	vmov	s15, r3
700026f8:	eef8 6a67 	vcvt.f32.u32	s13, s15
700026fc:	68fb      	ldr	r3, [r7, #12]
700026fe:	ee07 3a90 	vmov	s15, r3
70002702:	eef8 7a67 	vcvt.f32.u32	s15, s15
70002706:	ee86 7aa7 	vdiv.f32	s14, s13, s15
7000270a:	68bb      	ldr	r3, [r7, #8]
7000270c:	ee07 3a90 	vmov	s15, r3
70002710:	eef8 6a67 	vcvt.f32.u32	s13, s15
70002714:	69bb      	ldr	r3, [r7, #24]
70002716:	ee07 3a90 	vmov	s15, r3
7000271a:	eeb8 6a67 	vcvt.f32.u32	s12, s15
7000271e:	eddf 5a0f 	vldr	s11, [pc, #60]	@ 7000275c <RCC_PLL3_GetVCOOutputFreq+0x108>
70002722:	eec6 7a25 	vdiv.f32	s15, s12, s11
70002726:	ee76 7aa7 	vadd.f32	s15, s13, s15
7000272a:	ee67 7a27 	vmul.f32	s15, s14, s15
7000272e:	edc7 7a01 	vstr	s15, [r7, #4]
  
  return (uint32_t)frequency;
70002732:	edd7 7a01 	vldr	s15, [r7, #4]
70002736:	eefc 7ae7 	vcvt.u32.f32	s15, s15
7000273a:	ee17 3a90 	vmov	r3, s15
}
7000273e:	4618      	mov	r0, r3
70002740:	3724      	adds	r7, #36	@ 0x24
70002742:	46bd      	mov	sp, r7
70002744:	f85d 7b04 	ldr.w	r7, [sp], #4
70002748:	4770      	bx	lr
7000274a:	bf00      	nop
7000274c:	58024400 	.word	0x58024400
70002750:	03d09000 	.word	0x03d09000
70002754:	016e3600 	.word	0x016e3600
70002758:	003d0900 	.word	0x003d0900
7000275c:	46000000 	.word	0x46000000

70002760 <HAL_RCCEx_PeriphCLKConfig>:
  *         the backup registers) are set to their reset values.
  *
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_RCCEx_PeriphCLKConfig(const RCC_PeriphCLKInitTypeDef  *PeriphClkInit)
{
70002760:	b580      	push	{r7, lr}
70002762:	b086      	sub	sp, #24
70002764:	af00      	add	r7, sp, #0
70002766:	6078      	str	r0, [r7, #4]
  uint32_t tmpreg;
  uint32_t tickstart;
  HAL_StatusTypeDef ret = HAL_OK;      /* Intermediate status */
70002768:	2300      	movs	r3, #0
7000276a:	75fb      	strb	r3, [r7, #23]
  HAL_StatusTypeDef status = HAL_OK;   /* Final status */
7000276c:	2300      	movs	r3, #0
7000276e:	75bb      	strb	r3, [r7, #22]

  /* Check the parameters */
  assert_param(IS_RCC_PERIPHCLOCK(PeriphClkInit->PeriphClockSelection));

  /*---------------------------- RTC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
70002770:	687b      	ldr	r3, [r7, #4]
70002772:	681b      	ldr	r3, [r3, #0]
70002774:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
70002778:	2b00      	cmp	r3, #0
7000277a:	f000 8081 	beq.w	70002880 <HAL_RCCEx_PeriphCLKConfig+0x120>
    /* check for RTC Parameters used to output RTCCLK */
    assert_param(IS_RCC_RTCCLKSOURCE(PeriphClkInit->RTCClockSelection));

    /* As the RTC clock source selection can be changed only if the Backup Domain is reset */
    /* reset the Backup domain only if the RTC Clock source selection is modified from default reset value */
    tmpreg = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
7000277e:	4b8c      	ldr	r3, [pc, #560]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002780:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70002782:	f403 7340 	and.w	r3, r3, #768	@ 0x300
70002786:	613b      	str	r3, [r7, #16]

    if ((tmpreg != RCC_RTCCLKSOURCE_DISABLE) && (tmpreg != (PeriphClkInit->RTCClockSelection & RCC_BDCR_RTCSEL)))
70002788:	693b      	ldr	r3, [r7, #16]
7000278a:	2b00      	cmp	r3, #0
7000278c:	d029      	beq.n	700027e2 <HAL_RCCEx_PeriphCLKConfig+0x82>
7000278e:	687b      	ldr	r3, [r7, #4]
70002790:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
70002792:	f403 7340 	and.w	r3, r3, #768	@ 0x300
70002796:	693a      	ldr	r2, [r7, #16]
70002798:	429a      	cmp	r2, r3
7000279a:	d022      	beq.n	700027e2 <HAL_RCCEx_PeriphCLKConfig+0x82>
    {
      /* Enable write access to Backup domain */
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
7000279c:	4b85      	ldr	r3, [pc, #532]	@ (700029b4 <HAL_RCCEx_PeriphCLKConfig+0x254>)
7000279e:	681b      	ldr	r3, [r3, #0]
700027a0:	4a84      	ldr	r2, [pc, #528]	@ (700029b4 <HAL_RCCEx_PeriphCLKConfig+0x254>)
700027a2:	f443 7380 	orr.w	r3, r3, #256	@ 0x100
700027a6:	6013      	str	r3, [r2, #0]

      /* Read back to check Backup domain enabled */
      if (READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
700027a8:	4b82      	ldr	r3, [pc, #520]	@ (700029b4 <HAL_RCCEx_PeriphCLKConfig+0x254>)
700027aa:	681b      	ldr	r3, [r3, #0]
700027ac:	f403 7380 	and.w	r3, r3, #256	@ 0x100
700027b0:	2b00      	cmp	r3, #0
700027b2:	d102      	bne.n	700027ba <HAL_RCCEx_PeriphCLKConfig+0x5a>
      {
        ret = HAL_ERROR;
700027b4:	2301      	movs	r3, #1
700027b6:	75fb      	strb	r3, [r7, #23]
700027b8:	e013      	b.n	700027e2 <HAL_RCCEx_PeriphCLKConfig+0x82>
      }
      else
      {
        /* Store the content of BDCR register before the reset of Backup Domain */
        /* excepted the RTC clock source selection that will be changed */
        tmpreg = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
700027ba:	4b7d      	ldr	r3, [pc, #500]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700027bc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
700027be:	f423 7340 	bic.w	r3, r3, #768	@ 0x300
700027c2:	613b      	str	r3, [r7, #16]
        __HAL_RCC_BACKUPRESET_FORCE();
700027c4:	4b7a      	ldr	r3, [pc, #488]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700027c6:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
700027c8:	4a79      	ldr	r2, [pc, #484]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700027ca:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
700027ce:	6713      	str	r3, [r2, #112]	@ 0x70
        __HAL_RCC_BACKUPRESET_RELEASE();
700027d0:	4b77      	ldr	r3, [pc, #476]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700027d2:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
700027d4:	4a76      	ldr	r2, [pc, #472]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700027d6:	f423 3380 	bic.w	r3, r3, #65536	@ 0x10000
700027da:	6713      	str	r3, [r2, #112]	@ 0x70
        /* Restore the content of BDCR register */
        WRITE_REG(RCC->BDCR, tmpreg);
700027dc:	4a74      	ldr	r2, [pc, #464]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700027de:	693b      	ldr	r3, [r7, #16]
700027e0:	6713      	str	r3, [r2, #112]	@ 0x70
      }
    }

    if (ret == HAL_OK)
700027e2:	7dfb      	ldrb	r3, [r7, #23]
700027e4:	2b00      	cmp	r3, #0
700027e6:	d149      	bne.n	7000287c <HAL_RCCEx_PeriphCLKConfig+0x11c>
    {
      /* If LSE is selected as RTC clock source (and enabled prior to Backup Domain reset), wait for LSE reactivation */
      if (PeriphClkInit->RTCClockSelection == RCC_RTCCLKSOURCE_LSE)
700027e8:	687b      	ldr	r3, [r7, #4]
700027ea:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
700027ec:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
700027f0:	d115      	bne.n	7000281e <HAL_RCCEx_PeriphCLKConfig+0xbe>
      {
        /* Get Start Tick*/
        tickstart = HAL_GetTick();
700027f2:	f7fe ffa7 	bl	70001744 <HAL_GetTick>
700027f6:	60f8      	str	r0, [r7, #12]

        /* Wait till LSE is ready */
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
700027f8:	e00b      	b.n	70002812 <HAL_RCCEx_PeriphCLKConfig+0xb2>
        {
          if ((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
700027fa:	f7fe ffa3 	bl	70001744 <HAL_GetTick>
700027fe:	4602      	mov	r2, r0
70002800:	68fb      	ldr	r3, [r7, #12]
70002802:	1ad3      	subs	r3, r2, r3
70002804:	f241 3288 	movw	r2, #5000	@ 0x1388
70002808:	4293      	cmp	r3, r2
7000280a:	d902      	bls.n	70002812 <HAL_RCCEx_PeriphCLKConfig+0xb2>
          {
            ret = HAL_TIMEOUT;
7000280c:	2303      	movs	r3, #3
7000280e:	75fb      	strb	r3, [r7, #23]
            break;
70002810:	e005      	b.n	7000281e <HAL_RCCEx_PeriphCLKConfig+0xbe>
        while (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
70002812:	4b67      	ldr	r3, [pc, #412]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002814:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70002816:	f003 0302 	and.w	r3, r3, #2
7000281a:	2b00      	cmp	r3, #0
7000281c:	d0ed      	beq.n	700027fa <HAL_RCCEx_PeriphCLKConfig+0x9a>
          }
        }
      }

      if (ret == HAL_OK)
7000281e:	7dfb      	ldrb	r3, [r7, #23]
70002820:	2b00      	cmp	r3, #0
70002822:	d128      	bne.n	70002876 <HAL_RCCEx_PeriphCLKConfig+0x116>
      {
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
70002824:	687b      	ldr	r3, [r7, #4]
70002826:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
70002828:	f403 337c 	and.w	r3, r3, #258048	@ 0x3f000
7000282c:	2b00      	cmp	r3, #0
7000282e:	d00c      	beq.n	7000284a <HAL_RCCEx_PeriphCLKConfig+0xea>
70002830:	4b5f      	ldr	r3, [pc, #380]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002832:	691b      	ldr	r3, [r3, #16]
70002834:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
70002838:	687b      	ldr	r3, [r7, #4]
7000283a:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
7000283c:	0919      	lsrs	r1, r3, #4
7000283e:	4b5e      	ldr	r3, [pc, #376]	@ (700029b8 <HAL_RCCEx_PeriphCLKConfig+0x258>)
70002840:	400b      	ands	r3, r1
70002842:	495b      	ldr	r1, [pc, #364]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002844:	4313      	orrs	r3, r2
70002846:	610b      	str	r3, [r1, #16]
70002848:	e005      	b.n	70002856 <HAL_RCCEx_PeriphCLKConfig+0xf6>
7000284a:	4b59      	ldr	r3, [pc, #356]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
7000284c:	691b      	ldr	r3, [r3, #16]
7000284e:	4a58      	ldr	r2, [pc, #352]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002850:	f423 537c 	bic.w	r3, r3, #16128	@ 0x3f00
70002854:	6113      	str	r3, [r2, #16]
70002856:	4b56      	ldr	r3, [pc, #344]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002858:	6f1a      	ldr	r2, [r3, #112]	@ 0x70
7000285a:	687b      	ldr	r3, [r7, #4]
7000285c:	6fdb      	ldr	r3, [r3, #124]	@ 0x7c
7000285e:	f403 7340 	and.w	r3, r3, #768	@ 0x300
70002862:	4953      	ldr	r1, [pc, #332]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002864:	4313      	orrs	r3, r2
70002866:	670b      	str	r3, [r1, #112]	@ 0x70
        __HAL_RCC_RTC_ENABLE();
70002868:	4b51      	ldr	r3, [pc, #324]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
7000286a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
7000286c:	4a50      	ldr	r2, [pc, #320]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
7000286e:	f443 4300 	orr.w	r3, r3, #32768	@ 0x8000
70002872:	6713      	str	r3, [r2, #112]	@ 0x70
70002874:	e004      	b.n	70002880 <HAL_RCCEx_PeriphCLKConfig+0x120>
      }
      else
      {
        /* set overall return value */
        status = ret;
70002876:	7dfb      	ldrb	r3, [r7, #23]
70002878:	75bb      	strb	r3, [r7, #22]
7000287a:	e001      	b.n	70002880 <HAL_RCCEx_PeriphCLKConfig+0x120>
      }
    }
    else
    {
      /* set overall return value */
      status = ret;
7000287c:	7dfb      	ldrb	r3, [r7, #23]
7000287e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- FMC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FMC) == RCC_PERIPHCLK_FMC)
70002880:	687b      	ldr	r3, [r7, #4]
70002882:	681b      	ldr	r3, [r3, #0]
70002884:	f003 0301 	and.w	r3, r3, #1
70002888:	2b00      	cmp	r3, #0
7000288a:	d030      	beq.n	700028ee <HAL_RCCEx_PeriphCLKConfig+0x18e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FMCCLKSOURCE(PeriphClkInit->FmcClockSelection));

    switch (PeriphClkInit->FmcClockSelection)
7000288c:	687b      	ldr	r3, [r7, #4]
7000288e:	685b      	ldr	r3, [r3, #4]
70002890:	2b03      	cmp	r3, #3
70002892:	d819      	bhi.n	700028c8 <HAL_RCCEx_PeriphCLKConfig+0x168>
70002894:	a201      	add	r2, pc, #4	@ (adr r2, 7000289c <HAL_RCCEx_PeriphCLKConfig+0x13c>)
70002896:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
7000289a:	bf00      	nop
7000289c:	700028cf 	.word	0x700028cf
700028a0:	700028ad 	.word	0x700028ad
700028a4:	700028bb 	.word	0x700028bb
700028a8:	700028cf 	.word	0x700028cf
      case RCC_FMCCLKSOURCE_HCLK:   /* HCLK  clock selected as FMC kernel peripheral clock */
        break;

      case RCC_FMCCLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for FMC kernel */
        /* Enable FMC kernel clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
700028ac:	4b40      	ldr	r3, [pc, #256]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700028ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700028b0:	4a3f      	ldr	r2, [pc, #252]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700028b2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
700028b6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FMC kernel clock source configuration done later after clock selection check */
        break;
700028b8:	e00a      	b.n	700028d0 <HAL_RCCEx_PeriphCLKConfig+0x170>

      case RCC_FMCCLKSOURCE_PLL2R:  /* PLL2_R is used as clock source for FMC kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_RCLK);
700028ba:	4b3d      	ldr	r3, [pc, #244]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700028bc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700028be:	4a3c      	ldr	r2, [pc, #240]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700028c0:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
700028c4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FMC kernel clock source configuration done later after clock selection check */
        break;
700028c6:	e003      	b.n	700028d0 <HAL_RCCEx_PeriphCLKConfig+0x170>
      case RCC_FMCCLKSOURCE_HSI:   /* HSI oscillator is used as clock source for FMC kernel */
        /* FMC kernel clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
700028c8:	2301      	movs	r3, #1
700028ca:	75fb      	strb	r3, [r7, #23]
        break;
700028cc:	e000      	b.n	700028d0 <HAL_RCCEx_PeriphCLKConfig+0x170>
        break;
700028ce:	bf00      	nop
    }

    if (ret == HAL_OK)
700028d0:	7dfb      	ldrb	r3, [r7, #23]
700028d2:	2b00      	cmp	r3, #0
700028d4:	d109      	bne.n	700028ea <HAL_RCCEx_PeriphCLKConfig+0x18a>
    {
      /* Set the source of FMC kernel clock*/
      __HAL_RCC_FMC_CONFIG(PeriphClkInit->FmcClockSelection);
700028d6:	4b36      	ldr	r3, [pc, #216]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700028d8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
700028da:	f023 0203 	bic.w	r2, r3, #3
700028de:	687b      	ldr	r3, [r7, #4]
700028e0:	685b      	ldr	r3, [r3, #4]
700028e2:	4933      	ldr	r1, [pc, #204]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700028e4:	4313      	orrs	r3, r2
700028e6:	64cb      	str	r3, [r1, #76]	@ 0x4c
700028e8:	e001      	b.n	700028ee <HAL_RCCEx_PeriphCLKConfig+0x18e>
    }
    else
    {
      /* set overall return value */
      status = ret;
700028ea:	7dfb      	ldrb	r3, [r7, #23]
700028ec:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- XSPI1 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI1) == RCC_PERIPHCLK_XSPI1)
700028ee:	687b      	ldr	r3, [r7, #4]
700028f0:	681b      	ldr	r3, [r3, #0]
700028f2:	f003 0302 	and.w	r3, r3, #2
700028f6:	2b00      	cmp	r3, #0
700028f8:	d02a      	beq.n	70002950 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI1CLKSOURCE(PeriphClkInit->Xspi1ClockSelection));

    switch (PeriphClkInit->Xspi1ClockSelection)
700028fa:	687b      	ldr	r3, [r7, #4]
700028fc:	689b      	ldr	r3, [r3, #8]
700028fe:	2b20      	cmp	r3, #32
70002900:	d00c      	beq.n	7000291c <HAL_RCCEx_PeriphCLKConfig+0x1bc>
70002902:	2b20      	cmp	r3, #32
70002904:	d811      	bhi.n	7000292a <HAL_RCCEx_PeriphCLKConfig+0x1ca>
70002906:	2b00      	cmp	r3, #0
70002908:	d012      	beq.n	70002930 <HAL_RCCEx_PeriphCLKConfig+0x1d0>
7000290a:	2b10      	cmp	r3, #16
7000290c:	d10d      	bne.n	7000292a <HAL_RCCEx_PeriphCLKConfig+0x1ca>
      case RCC_XSPI1CLKSOURCE_HCLK:   /* HCLK is used as clock source for Xspi1 */
        /* Nothing to do */
        break;

      case RCC_XSPI1CLKSOURCE_PLL2S:  /* PLL2_S is used as clock source for Xspi1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_SCLK);
7000290e:	4b28      	ldr	r3, [pc, #160]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002910:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002912:	4a27      	ldr	r2, [pc, #156]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002914:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
70002918:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI1 clock source configuration done later after clock selection check */
        break;
7000291a:	e00a      	b.n	70002932 <HAL_RCCEx_PeriphCLKConfig+0x1d2>

      case RCC_XSPI1CLKSOURCE_PLL2T:  /* PLL2_T is used as clock source for Xspi1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_TCLK);
7000291c:	4b24      	ldr	r3, [pc, #144]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
7000291e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002920:	4a23      	ldr	r2, [pc, #140]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002922:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
70002926:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI1 clock source configuration done later after clock selection check */
        break;
70002928:	e003      	b.n	70002932 <HAL_RCCEx_PeriphCLKConfig+0x1d2>

      default:
        ret = HAL_ERROR;
7000292a:	2301      	movs	r3, #1
7000292c:	75fb      	strb	r3, [r7, #23]
        break;
7000292e:	e000      	b.n	70002932 <HAL_RCCEx_PeriphCLKConfig+0x1d2>
        break;
70002930:	bf00      	nop
    }

    if (ret == HAL_OK)
70002932:	7dfb      	ldrb	r3, [r7, #23]
70002934:	2b00      	cmp	r3, #0
70002936:	d109      	bne.n	7000294c <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    {
      /* Configure the XSPI1 clock source */
      __HAL_RCC_XSPI1_CONFIG(PeriphClkInit->Xspi1ClockSelection);
70002938:	4b1d      	ldr	r3, [pc, #116]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
7000293a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
7000293c:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
70002940:	687b      	ldr	r3, [r7, #4]
70002942:	689b      	ldr	r3, [r3, #8]
70002944:	491a      	ldr	r1, [pc, #104]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002946:	4313      	orrs	r3, r2
70002948:	64cb      	str	r3, [r1, #76]	@ 0x4c
7000294a:	e001      	b.n	70002950 <HAL_RCCEx_PeriphCLKConfig+0x1f0>
    }
    else
    {
      /* set overall return value */
      status = ret;
7000294c:	7dfb      	ldrb	r3, [r7, #23]
7000294e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- XSPI2 clock source configuration ----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_XSPI2) == RCC_PERIPHCLK_XSPI2)
70002950:	687b      	ldr	r3, [r7, #4]
70002952:	681b      	ldr	r3, [r3, #0]
70002954:	f003 0304 	and.w	r3, r3, #4
70002958:	2b00      	cmp	r3, #0
7000295a:	d031      	beq.n	700029c0 <HAL_RCCEx_PeriphCLKConfig+0x260>
  {
    /* Check the parameters */
    assert_param(IS_RCC_XSPI2CLKSOURCE(PeriphClkInit->Xspi2ClockSelection));

    switch (PeriphClkInit->Xspi2ClockSelection)
7000295c:	687b      	ldr	r3, [r7, #4]
7000295e:	68db      	ldr	r3, [r3, #12]
70002960:	2b80      	cmp	r3, #128	@ 0x80
70002962:	d00c      	beq.n	7000297e <HAL_RCCEx_PeriphCLKConfig+0x21e>
70002964:	2b80      	cmp	r3, #128	@ 0x80
70002966:	d811      	bhi.n	7000298c <HAL_RCCEx_PeriphCLKConfig+0x22c>
70002968:	2b00      	cmp	r3, #0
7000296a:	d012      	beq.n	70002992 <HAL_RCCEx_PeriphCLKConfig+0x232>
7000296c:	2b40      	cmp	r3, #64	@ 0x40
7000296e:	d10d      	bne.n	7000298c <HAL_RCCEx_PeriphCLKConfig+0x22c>
      case RCC_XSPI2CLKSOURCE_HCLK:   /* HCLK is used as clock source for Xspi2 */
        /* Nothing to do */
        break;

      case RCC_XSPI2CLKSOURCE_PLL2S:  /* PLL2_S is used as clock source for Xspi2 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_SCLK);
70002970:	4b0f      	ldr	r3, [pc, #60]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002972:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002974:	4a0e      	ldr	r2, [pc, #56]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002976:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
7000297a:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI2 clock source configuration done later after clock selection check */
        break;
7000297c:	e00a      	b.n	70002994 <HAL_RCCEx_PeriphCLKConfig+0x234>

      case RCC_XSPI2CLKSOURCE_PLL2T:  /* PLL2_T is used as clock source for Xspi2 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_TCLK);
7000297e:	4b0c      	ldr	r3, [pc, #48]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002980:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002982:	4a0b      	ldr	r2, [pc, #44]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
70002984:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
70002988:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* XSPI2 clock source configuration done later after clock selection check */
        break;
7000298a:	e003      	b.n	70002994 <HAL_RCCEx_PeriphCLKConfig+0x234>

      default:
        ret = HAL_ERROR;
7000298c:	2301      	movs	r3, #1
7000298e:	75fb      	strb	r3, [r7, #23]
        break;
70002990:	e000      	b.n	70002994 <HAL_RCCEx_PeriphCLKConfig+0x234>
        break;
70002992:	bf00      	nop
    }

    if (ret == HAL_OK)
70002994:	7dfb      	ldrb	r3, [r7, #23]
70002996:	2b00      	cmp	r3, #0
70002998:	d110      	bne.n	700029bc <HAL_RCCEx_PeriphCLKConfig+0x25c>
    {
      /* Configure the XSPI2 clock source */
      __HAL_RCC_XSPI2_CONFIG(PeriphClkInit->Xspi2ClockSelection);
7000299a:	4b05      	ldr	r3, [pc, #20]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
7000299c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
7000299e:	f023 02c0 	bic.w	r2, r3, #192	@ 0xc0
700029a2:	687b      	ldr	r3, [r7, #4]
700029a4:	68db      	ldr	r3, [r3, #12]
700029a6:	4902      	ldr	r1, [pc, #8]	@ (700029b0 <HAL_RCCEx_PeriphCLKConfig+0x250>)
700029a8:	4313      	orrs	r3, r2
700029aa:	64cb      	str	r3, [r1, #76]	@ 0x4c
700029ac:	e008      	b.n	700029c0 <HAL_RCCEx_PeriphCLKConfig+0x260>
700029ae:	bf00      	nop
700029b0:	58024400 	.word	0x58024400
700029b4:	58024800 	.word	0x58024800
700029b8:	0fffffcf 	.word	0x0fffffcf
    }
    else
    {
      /* set overall return value */
      status = ret;
700029bc:	7dfb      	ldrb	r3, [r7, #23]
700029be:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------------ CKPER configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CKPER) == RCC_PERIPHCLK_CKPER)
700029c0:	687b      	ldr	r3, [r7, #4]
700029c2:	681b      	ldr	r3, [r3, #0]
700029c4:	f003 0308 	and.w	r3, r3, #8
700029c8:	2b00      	cmp	r3, #0
700029ca:	d008      	beq.n	700029de <HAL_RCCEx_PeriphCLKConfig+0x27e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CKPERCLKSOURCE(PeriphClkInit->CkperClockSelection));

    /* Configure the CKPER clock source */
    __HAL_RCC_CLKP_CONFIG(PeriphClkInit->CkperClockSelection);
700029cc:	4b93      	ldr	r3, [pc, #588]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
700029ce:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
700029d0:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
700029d4:	687b      	ldr	r3, [r7, #4]
700029d6:	691b      	ldr	r3, [r3, #16]
700029d8:	4990      	ldr	r1, [pc, #576]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
700029da:	4313      	orrs	r3, r2
700029dc:	64cb      	str	r3, [r1, #76]	@ 0x4c
  }

  /*------------------------------------- SDMMC12 Configuration ------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SDMMC12) == RCC_PERIPHCLK_SDMMC12)
700029de:	687b      	ldr	r3, [r7, #4]
700029e0:	681b      	ldr	r3, [r3, #0]
700029e2:	f403 1300 	and.w	r3, r3, #2097152	@ 0x200000
700029e6:	2b00      	cmp	r3, #0
700029e8:	d026      	beq.n	70002a38 <HAL_RCCEx_PeriphCLKConfig+0x2d8>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SDMMC12CLKSOURCE(PeriphClkInit->Sdmmc12ClockSelection));

    switch (PeriphClkInit->Sdmmc12ClockSelection)
700029ea:	687b      	ldr	r3, [r7, #4]
700029ec:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
700029ee:	2b00      	cmp	r3, #0
700029f0:	d002      	beq.n	700029f8 <HAL_RCCEx_PeriphCLKConfig+0x298>
700029f2:	2b04      	cmp	r3, #4
700029f4:	d007      	beq.n	70002a06 <HAL_RCCEx_PeriphCLKConfig+0x2a6>
700029f6:	e00d      	b.n	70002a14 <HAL_RCCEx_PeriphCLKConfig+0x2b4>
    {
      case RCC_SDMMC12CLKSOURCE_PLL2S:  /* PLL2_S is used as clock source for SDMMC12 kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_SCLK);
700029f8:	4b88      	ldr	r3, [pc, #544]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
700029fa:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700029fc:	4a87      	ldr	r2, [pc, #540]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
700029fe:	f443 2300 	orr.w	r3, r3, #524288	@ 0x80000
70002a02:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SDMMC12 kernel clock source configuration done later after clock selection check */
        break;
70002a04:	e009      	b.n	70002a1a <HAL_RCCEx_PeriphCLKConfig+0x2ba>

      case RCC_SDMMC12CLKSOURCE_PLL2T:  /* PLL2_T is used as clock source for SDMMC12 kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_TCLK);
70002a06:	4b85      	ldr	r3, [pc, #532]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a08:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002a0a:	4a84      	ldr	r2, [pc, #528]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a0c:	f443 1380 	orr.w	r3, r3, #1048576	@ 0x100000
70002a10:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SDMMC12 kernel clock source configuration done later after clock selection check */
        break;
70002a12:	e002      	b.n	70002a1a <HAL_RCCEx_PeriphCLKConfig+0x2ba>

      default:
        ret = HAL_ERROR;
70002a14:	2301      	movs	r3, #1
70002a16:	75fb      	strb	r3, [r7, #23]
        break;
70002a18:	bf00      	nop
    }

    if (ret == HAL_OK)
70002a1a:	7dfb      	ldrb	r3, [r7, #23]
70002a1c:	2b00      	cmp	r3, #0
70002a1e:	d109      	bne.n	70002a34 <HAL_RCCEx_PeriphCLKConfig+0x2d4>
    {
      /* Set the source of SDMMC12 clock*/
      __HAL_RCC_SDMMC12_CONFIG(PeriphClkInit->Sdmmc12ClockSelection);
70002a20:	4b7e      	ldr	r3, [pc, #504]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a22:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70002a24:	f023 0204 	bic.w	r2, r3, #4
70002a28:	687b      	ldr	r3, [r7, #4]
70002a2a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70002a2c:	497b      	ldr	r1, [pc, #492]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a2e:	4313      	orrs	r3, r2
70002a30:	64cb      	str	r3, [r1, #76]	@ 0x4c
70002a32:	e001      	b.n	70002a38 <HAL_RCCEx_PeriphCLKConfig+0x2d8>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002a34:	7dfb      	ldrb	r3, [r7, #23]
70002a36:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- ADC configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
70002a38:	687b      	ldr	r3, [r7, #4]
70002a3a:	681b      	ldr	r3, [r3, #0]
70002a3c:	f003 0310 	and.w	r3, r3, #16
70002a40:	2b00      	cmp	r3, #0
70002a42:	d02e      	beq.n	70002aa2 <HAL_RCCEx_PeriphCLKConfig+0x342>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADCCLKSOURCE(PeriphClkInit->AdcClockSelection));

    switch (PeriphClkInit->AdcClockSelection)
70002a44:	687b      	ldr	r3, [r7, #4]
70002a46:	695b      	ldr	r3, [r3, #20]
70002a48:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
70002a4c:	d019      	beq.n	70002a82 <HAL_RCCEx_PeriphCLKConfig+0x322>
70002a4e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
70002a52:	d813      	bhi.n	70002a7c <HAL_RCCEx_PeriphCLKConfig+0x31c>
70002a54:	2b00      	cmp	r3, #0
70002a56:	d003      	beq.n	70002a60 <HAL_RCCEx_PeriphCLKConfig+0x300>
70002a58:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
70002a5c:	d007      	beq.n	70002a6e <HAL_RCCEx_PeriphCLKConfig+0x30e>
70002a5e:	e00d      	b.n	70002a7c <HAL_RCCEx_PeriphCLKConfig+0x31c>
    {

      case RCC_ADCCLKSOURCE_PLL2P: /* PLL2_P is used as clock source for ADC */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70002a60:	4b6e      	ldr	r3, [pc, #440]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a62:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002a64:	4a6d      	ldr	r2, [pc, #436]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a66:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70002a6a:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADC clock source configuration done later after clock selection check */
        break;
70002a6c:	e00a      	b.n	70002a84 <HAL_RCCEx_PeriphCLKConfig+0x324>

      case RCC_ADCCLKSOURCE_PLL3R: /* PLL3_R is used as clock source for ADC */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002a6e:	4b6b      	ldr	r3, [pc, #428]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a70:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002a72:	4a6a      	ldr	r2, [pc, #424]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a74:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002a78:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADC clock source configuration done later after clock selection check */
        break;
70002a7a:	e003      	b.n	70002a84 <HAL_RCCEx_PeriphCLKConfig+0x324>
        /* HSI, HSE, or CSI oscillator is used as source of ADC clock */
        /* ADC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002a7c:	2301      	movs	r3, #1
70002a7e:	75fb      	strb	r3, [r7, #23]
        break;
70002a80:	e000      	b.n	70002a84 <HAL_RCCEx_PeriphCLKConfig+0x324>
        break;
70002a82:	bf00      	nop
    }

    if (ret == HAL_OK)
70002a84:	7dfb      	ldrb	r3, [r7, #23]
70002a86:	2b00      	cmp	r3, #0
70002a88:	d109      	bne.n	70002a9e <HAL_RCCEx_PeriphCLKConfig+0x33e>
    {
      /* Set the source of ADC clock*/
      __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
70002a8a:	4b64      	ldr	r3, [pc, #400]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a8c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70002a8e:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
70002a92:	687b      	ldr	r3, [r7, #4]
70002a94:	695b      	ldr	r3, [r3, #20]
70002a96:	4961      	ldr	r1, [pc, #388]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002a98:	4313      	orrs	r3, r2
70002a9a:	64cb      	str	r3, [r1, #76]	@ 0x4c
70002a9c:	e001      	b.n	70002aa2 <HAL_RCCEx_PeriphCLKConfig+0x342>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002a9e:	7dfb      	ldrb	r3, [r7, #23]
70002aa0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- ADF1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ADF1) == RCC_PERIPHCLK_ADF1)
70002aa2:	687b      	ldr	r3, [r7, #4]
70002aa4:	681b      	ldr	r3, [r3, #0]
70002aa6:	f003 0320 	and.w	r3, r3, #32
70002aaa:	2b00      	cmp	r3, #0
70002aac:	d03f      	beq.n	70002b2e <HAL_RCCEx_PeriphCLKConfig+0x3ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ADF1CLKSOURCE(PeriphClkInit->Adf1ClockSelection));

    switch (PeriphClkInit->Adf1ClockSelection)
70002aae:	687b      	ldr	r3, [r7, #4]
70002ab0:	699b      	ldr	r3, [r3, #24]
70002ab2:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
70002ab6:	d02a      	beq.n	70002b0e <HAL_RCCEx_PeriphCLKConfig+0x3ae>
70002ab8:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
70002abc:	d824      	bhi.n	70002b08 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
70002abe:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70002ac2:	d024      	beq.n	70002b0e <HAL_RCCEx_PeriphCLKConfig+0x3ae>
70002ac4:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70002ac8:	d81e      	bhi.n	70002b08 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
70002aca:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
70002ace:	d01e      	beq.n	70002b0e <HAL_RCCEx_PeriphCLKConfig+0x3ae>
70002ad0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
70002ad4:	d818      	bhi.n	70002b08 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
70002ad6:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
70002ada:	d00e      	beq.n	70002afa <HAL_RCCEx_PeriphCLKConfig+0x39a>
70002adc:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
70002ae0:	d812      	bhi.n	70002b08 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
70002ae2:	2b00      	cmp	r3, #0
70002ae4:	d013      	beq.n	70002b0e <HAL_RCCEx_PeriphCLKConfig+0x3ae>
70002ae6:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
70002aea:	d10d      	bne.n	70002b08 <HAL_RCCEx_PeriphCLKConfig+0x3a8>
    {
      case RCC_ADF1CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for ADF1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70002aec:	4b4b      	ldr	r3, [pc, #300]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002aee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002af0:	4a4a      	ldr	r2, [pc, #296]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002af2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70002af6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADF1 clock source configuration done later after clock selection check */
        break;
70002af8:	e00a      	b.n	70002b10 <HAL_RCCEx_PeriphCLKConfig+0x3b0>

      case RCC_ADF1CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for ADF1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
70002afa:	4b48      	ldr	r3, [pc, #288]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002afc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002afe:	4a47      	ldr	r2, [pc, #284]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b00:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
70002b04:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ADF1 clock source configuration done later after clock selection check */
        break;
70002b06:	e003      	b.n	70002b10 <HAL_RCCEx_PeriphCLKConfig+0x3b0>
      case RCC_ADF1CLKSOURCE_HSI:    /* HSI is used as clock source for ADF1 */
        /* ADF1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002b08:	2301      	movs	r3, #1
70002b0a:	75fb      	strb	r3, [r7, #23]
        break;
70002b0c:	e000      	b.n	70002b10 <HAL_RCCEx_PeriphCLKConfig+0x3b0>
        break;
70002b0e:	bf00      	nop
    }

    if (ret == HAL_OK)
70002b10:	7dfb      	ldrb	r3, [r7, #23]
70002b12:	2b00      	cmp	r3, #0
70002b14:	d109      	bne.n	70002b2a <HAL_RCCEx_PeriphCLKConfig+0x3ca>
    {
      /* Set the source of ADF1 clock*/
      __HAL_RCC_ADF1_CONFIG(PeriphClkInit->Adf1ClockSelection);
70002b16:	4b41      	ldr	r3, [pc, #260]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b18:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70002b1a:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
70002b1e:	687b      	ldr	r3, [r7, #4]
70002b20:	699b      	ldr	r3, [r3, #24]
70002b22:	493e      	ldr	r1, [pc, #248]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b24:	4313      	orrs	r3, r2
70002b26:	64cb      	str	r3, [r1, #76]	@ 0x4c
70002b28:	e001      	b.n	70002b2e <HAL_RCCEx_PeriphCLKConfig+0x3ce>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002b2a:	7dfb      	ldrb	r3, [r7, #23]
70002b2c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------- CEC configuration ---------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_CEC) == RCC_PERIPHCLK_CEC)
70002b2e:	687b      	ldr	r3, [r7, #4]
70002b30:	681b      	ldr	r3, [r3, #0]
70002b32:	f003 0340 	and.w	r3, r3, #64	@ 0x40
70002b36:	2b00      	cmp	r3, #0
70002b38:	d008      	beq.n	70002b4c <HAL_RCCEx_PeriphCLKConfig+0x3ec>
  {
    /* Check the parameters */
    assert_param(IS_RCC_CECCLKSOURCE(PeriphClkInit->CecClockSelection));

    /* Configure the CEC clock source */
    __HAL_RCC_CEC_CONFIG(PeriphClkInit->CecClockSelection);
70002b3a:	4b38      	ldr	r3, [pc, #224]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b3c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70002b3e:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
70002b42:	687b      	ldr	r3, [r7, #4]
70002b44:	69db      	ldr	r3, [r3, #28]
70002b46:	4935      	ldr	r1, [pc, #212]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b48:	4313      	orrs	r3, r2
70002b4a:	650b      	str	r3, [r1, #80]	@ 0x50
  }

  /*---------------------- ETH1 REF configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1REF) == RCC_PERIPHCLK_ETH1REF)
70002b4c:	687b      	ldr	r3, [r7, #4]
70002b4e:	681b      	ldr	r3, [r3, #0]
70002b50:	f003 0380 	and.w	r3, r3, #128	@ 0x80
70002b54:	2b00      	cmp	r3, #0
70002b56:	d008      	beq.n	70002b6a <HAL_RCCEx_PeriphCLKConfig+0x40a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1REFCLKSOURCE(PeriphClkInit->Eth1RefClockSelection));

    /* Configure the ETH1 REF clock source */
    __HAL_RCC_ETH1REF_CONFIG(PeriphClkInit->Eth1RefClockSelection);
70002b58:	4b30      	ldr	r3, [pc, #192]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b5a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70002b5c:	f423 3240 	bic.w	r2, r3, #196608	@ 0x30000
70002b60:	687b      	ldr	r3, [r7, #4]
70002b62:	6a1b      	ldr	r3, [r3, #32]
70002b64:	492d      	ldr	r1, [pc, #180]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b66:	4313      	orrs	r3, r2
70002b68:	64cb      	str	r3, [r1, #76]	@ 0x4c
  }

  /*---------------------- ETH1PHY configuration --------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_ETH1PHY) == RCC_PERIPHCLK_ETH1PHY)
70002b6a:	687b      	ldr	r3, [r7, #4]
70002b6c:	681b      	ldr	r3, [r3, #0]
70002b6e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70002b72:	2b00      	cmp	r3, #0
70002b74:	d020      	beq.n	70002bb8 <HAL_RCCEx_PeriphCLKConfig+0x458>
  {
    /* Check the parameters */
    assert_param(IS_RCC_ETH1PHYCLKSOURCE(PeriphClkInit->Eth1PhyClockSelection));

    switch (PeriphClkInit->Eth1PhyClockSelection)
70002b76:	687b      	ldr	r3, [r7, #4]
70002b78:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
70002b7a:	2b00      	cmp	r3, #0
70002b7c:	d00c      	beq.n	70002b98 <HAL_RCCEx_PeriphCLKConfig+0x438>
70002b7e:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70002b82:	d106      	bne.n	70002b92 <HAL_RCCEx_PeriphCLKConfig+0x432>
      case RCC_ETH1PHYCLKSOURCE_HSE:    /* HSE is used as clock source for ETH PHY */
        /* ETH PHY clock source configuration done later after clock selection check */
        break;

      case RCC_ETH1PHYCLKSOURCE_PLL3S:  /* PLL3_S is used as clock source for ETH PHY */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_SCLK);
70002b84:	4b25      	ldr	r3, [pc, #148]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b86:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002b88:	4a24      	ldr	r2, [pc, #144]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002b8a:	f043 4380 	orr.w	r3, r3, #1073741824	@ 0x40000000
70002b8e:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* ETH PHY clock source configuration done later after clock selection check */
        break;
70002b90:	e003      	b.n	70002b9a <HAL_RCCEx_PeriphCLKConfig+0x43a>

      default:
        ret = HAL_ERROR;
70002b92:	2301      	movs	r3, #1
70002b94:	75fb      	strb	r3, [r7, #23]
        break;
70002b96:	e000      	b.n	70002b9a <HAL_RCCEx_PeriphCLKConfig+0x43a>
        break;
70002b98:	bf00      	nop
    }

    if (ret == HAL_OK)
70002b9a:	7dfb      	ldrb	r3, [r7, #23]
70002b9c:	2b00      	cmp	r3, #0
70002b9e:	d109      	bne.n	70002bb4 <HAL_RCCEx_PeriphCLKConfig+0x454>
    {
      /* Set the source of ETH PHY clock*/
      __HAL_RCC_ETH1PHY_CONFIG(PeriphClkInit->Eth1PhyClockSelection);
70002ba0:	4b1e      	ldr	r3, [pc, #120]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002ba2:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70002ba4:	f423 2280 	bic.w	r2, r3, #262144	@ 0x40000
70002ba8:	687b      	ldr	r3, [r7, #4]
70002baa:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
70002bac:	491b      	ldr	r1, [pc, #108]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002bae:	4313      	orrs	r3, r2
70002bb0:	64cb      	str	r3, [r1, #76]	@ 0x4c
70002bb2:	e001      	b.n	70002bb8 <HAL_RCCEx_PeriphCLKConfig+0x458>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002bb4:	7dfb      	ldrb	r3, [r7, #23]
70002bb6:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------- FDCAN configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_FDCAN) == RCC_PERIPHCLK_FDCAN)
70002bb8:	687b      	ldr	r3, [r7, #4]
70002bba:	681b      	ldr	r3, [r3, #0]
70002bbc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
70002bc0:	2b00      	cmp	r3, #0
70002bc2:	d02f      	beq.n	70002c24 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
  {
    /* Check the parameters */
    assert_param(IS_RCC_FDCANCLKSOURCE(PeriphClkInit->FdcanClockSelection));

    switch (PeriphClkInit->FdcanClockSelection)
70002bc4:	687b      	ldr	r3, [r7, #4]
70002bc6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002bc8:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
70002bcc:	d00e      	beq.n	70002bec <HAL_RCCEx_PeriphCLKConfig+0x48c>
70002bce:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
70002bd2:	d812      	bhi.n	70002bfa <HAL_RCCEx_PeriphCLKConfig+0x49a>
70002bd4:	2b00      	cmp	r3, #0
70002bd6:	d013      	beq.n	70002c00 <HAL_RCCEx_PeriphCLKConfig+0x4a0>
70002bd8:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70002bdc:	d10d      	bne.n	70002bfa <HAL_RCCEx_PeriphCLKConfig+0x49a>
    {
      case RCC_FDCANCLKSOURCE_PLL1Q: /* PLL1_Q is used as clock source for FDCAN kernel */
        /* Enable FDCAN Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
70002bde:	4b0f      	ldr	r3, [pc, #60]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002be0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002be2:	4a0e      	ldr	r2, [pc, #56]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002be4:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70002be8:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FDCAN clock source configuration done later after clock selection check */
        break;
70002bea:	e00a      	b.n	70002c02 <HAL_RCCEx_PeriphCLKConfig+0x4a2>

      case RCC_FDCANCLKSOURCE_PLL2P: /* PLL2_P is used as clock source for FDCAN kernel */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70002bec:	4b0b      	ldr	r3, [pc, #44]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002bee:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002bf0:	4a0a      	ldr	r2, [pc, #40]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002bf2:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70002bf6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* FDCAN clock source configuration done later after clock selection check */
        break;
70002bf8:	e003      	b.n	70002c02 <HAL_RCCEx_PeriphCLKConfig+0x4a2>
      case RCC_FDCANCLKSOURCE_HSE:   /* HSE is used as clock source for FDCAN kernel */
        /* FDCAN clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002bfa:	2301      	movs	r3, #1
70002bfc:	75fb      	strb	r3, [r7, #23]
        break;
70002bfe:	e000      	b.n	70002c02 <HAL_RCCEx_PeriphCLKConfig+0x4a2>
        break;
70002c00:	bf00      	nop
    }

    if (ret == HAL_OK)
70002c02:	7dfb      	ldrb	r3, [r7, #23]
70002c04:	2b00      	cmp	r3, #0
70002c06:	d10b      	bne.n	70002c20 <HAL_RCCEx_PeriphCLKConfig+0x4c0>
    {
      /* Set the source of FDCAN clock*/
      __HAL_RCC_FDCAN_CONFIG(PeriphClkInit->FdcanClockSelection);
70002c08:	4b04      	ldr	r3, [pc, #16]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002c0a:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70002c0c:	f423 0240 	bic.w	r2, r3, #12582912	@ 0xc00000
70002c10:	687b      	ldr	r3, [r7, #4]
70002c12:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70002c14:	4901      	ldr	r1, [pc, #4]	@ (70002c1c <HAL_RCCEx_PeriphCLKConfig+0x4bc>)
70002c16:	4313      	orrs	r3, r2
70002c18:	650b      	str	r3, [r1, #80]	@ 0x50
70002c1a:	e003      	b.n	70002c24 <HAL_RCCEx_PeriphCLKConfig+0x4c4>
70002c1c:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
70002c20:	7dfb      	ldrb	r3, [r7, #23]
70002c22:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ I2C1/I3C1 Configuration ------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C1_I3C1) == RCC_PERIPHCLK_I2C1_I3C1)
70002c24:	687b      	ldr	r3, [r7, #4]
70002c26:	681b      	ldr	r3, [r3, #0]
70002c28:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
70002c2c:	2b00      	cmp	r3, #0
70002c2e:	d02c      	beq.n	70002c8a <HAL_RCCEx_PeriphCLKConfig+0x52a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C1_I3C1CLKSOURCE(PeriphClkInit->I2c1_I3c1ClockSelection));

    switch (PeriphClkInit->I2c1_I3c1ClockSelection)
70002c30:	687b      	ldr	r3, [r7, #4]
70002c32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002c34:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70002c38:	d017      	beq.n	70002c6a <HAL_RCCEx_PeriphCLKConfig+0x50a>
70002c3a:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70002c3e:	d811      	bhi.n	70002c64 <HAL_RCCEx_PeriphCLKConfig+0x504>
70002c40:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70002c44:	d011      	beq.n	70002c6a <HAL_RCCEx_PeriphCLKConfig+0x50a>
70002c46:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70002c4a:	d80b      	bhi.n	70002c64 <HAL_RCCEx_PeriphCLKConfig+0x504>
70002c4c:	2b00      	cmp	r3, #0
70002c4e:	d00c      	beq.n	70002c6a <HAL_RCCEx_PeriphCLKConfig+0x50a>
70002c50:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
70002c54:	d106      	bne.n	70002c64 <HAL_RCCEx_PeriphCLKConfig+0x504>
    {
      case RCC_I2C1_I3C1CLKSOURCE_PLL3R:   /* PLL3_R is used as clock source for I2C1/I3C1*/
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002c56:	4b97      	ldr	r3, [pc, #604]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002c58:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002c5a:	4a96      	ldr	r2, [pc, #600]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002c5c:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002c60:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* I2C1/I3C1 clock source configuration done later after clock selection check */
        break;
70002c62:	e003      	b.n	70002c6c <HAL_RCCEx_PeriphCLKConfig+0x50c>
      case RCC_I2C1_I3C1CLKSOURCE_CSI:     /* CSI is used as clock source for I2C1/I3C1*/
        /* I2C1/I3C1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002c64:	2301      	movs	r3, #1
70002c66:	75fb      	strb	r3, [r7, #23]
        break;
70002c68:	e000      	b.n	70002c6c <HAL_RCCEx_PeriphCLKConfig+0x50c>
        break;
70002c6a:	bf00      	nop
    }

    if (ret == HAL_OK)
70002c6c:	7dfb      	ldrb	r3, [r7, #23]
70002c6e:	2b00      	cmp	r3, #0
70002c70:	d109      	bne.n	70002c86 <HAL_RCCEx_PeriphCLKConfig+0x526>
    {
      /* Set the source of I2C1/I3C1 clock*/
      __HAL_RCC_I2C1_I3C1_CONFIG(PeriphClkInit->I2c1_I3c1ClockSelection);
70002c72:	4b90      	ldr	r3, [pc, #576]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002c74:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70002c76:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
70002c7a:	687b      	ldr	r3, [r7, #4]
70002c7c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002c7e:	498d      	ldr	r1, [pc, #564]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002c80:	4313      	orrs	r3, r2
70002c82:	650b      	str	r3, [r1, #80]	@ 0x50
70002c84:	e001      	b.n	70002c8a <HAL_RCCEx_PeriphCLKConfig+0x52a>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002c86:	7dfb      	ldrb	r3, [r7, #23]
70002c88:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ I2C2/I2C3 Configuration -------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_I2C23) == RCC_PERIPHCLK_I2C23)
70002c8a:	687b      	ldr	r3, [r7, #4]
70002c8c:	681b      	ldr	r3, [r3, #0]
70002c8e:	f403 6380 	and.w	r3, r3, #1024	@ 0x400
70002c92:	2b00      	cmp	r3, #0
70002c94:	d02c      	beq.n	70002cf0 <HAL_RCCEx_PeriphCLKConfig+0x590>
  {
    /* Check the parameters */
    assert_param(IS_RCC_I2C23CLKSOURCE(PeriphClkInit->I2c23ClockSelection));

    switch (PeriphClkInit->I2c23ClockSelection)
70002c96:	687b      	ldr	r3, [r7, #4]
70002c98:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70002c9a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70002c9e:	d017      	beq.n	70002cd0 <HAL_RCCEx_PeriphCLKConfig+0x570>
70002ca0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70002ca4:	d811      	bhi.n	70002cca <HAL_RCCEx_PeriphCLKConfig+0x56a>
70002ca6:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70002caa:	d011      	beq.n	70002cd0 <HAL_RCCEx_PeriphCLKConfig+0x570>
70002cac:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70002cb0:	d80b      	bhi.n	70002cca <HAL_RCCEx_PeriphCLKConfig+0x56a>
70002cb2:	2b00      	cmp	r3, #0
70002cb4:	d00c      	beq.n	70002cd0 <HAL_RCCEx_PeriphCLKConfig+0x570>
70002cb6:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
70002cba:	d106      	bne.n	70002cca <HAL_RCCEx_PeriphCLKConfig+0x56a>
    {
      case RCC_I2C23CLKSOURCE_PLL3R:   /* PLL3_R is used as clock source for I2C2/I2C3 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002cbc:	4b7d      	ldr	r3, [pc, #500]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002cbe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002cc0:	4a7c      	ldr	r2, [pc, #496]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002cc2:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002cc6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* I2C2/I2C3 clock source configuration done later after clock selection check */
        break;
70002cc8:	e003      	b.n	70002cd2 <HAL_RCCEx_PeriphCLKConfig+0x572>
      case RCC_I2C23CLKSOURCE_CSI:     /* CSI is used as clock source for I2C2/I2C3 */
        /* I2C2/I2C3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002cca:	2301      	movs	r3, #1
70002ccc:	75fb      	strb	r3, [r7, #23]
        break;
70002cce:	e000      	b.n	70002cd2 <HAL_RCCEx_PeriphCLKConfig+0x572>
        break;
70002cd0:	bf00      	nop
    }

    if (ret == HAL_OK)
70002cd2:	7dfb      	ldrb	r3, [r7, #23]
70002cd4:	2b00      	cmp	r3, #0
70002cd6:	d109      	bne.n	70002cec <HAL_RCCEx_PeriphCLKConfig+0x58c>
    {
      /* Set the source of I2C2/I2C3 clock*/
      __HAL_RCC_I2C23_CONFIG(PeriphClkInit->I2c23ClockSelection);
70002cd8:	4b76      	ldr	r3, [pc, #472]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002cda:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70002cdc:	f423 7240 	bic.w	r2, r3, #768	@ 0x300
70002ce0:	687b      	ldr	r3, [r7, #4]
70002ce2:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70002ce4:	4973      	ldr	r1, [pc, #460]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002ce6:	4313      	orrs	r3, r2
70002ce8:	650b      	str	r3, [r1, #80]	@ 0x50
70002cea:	e001      	b.n	70002cf0 <HAL_RCCEx_PeriphCLKConfig+0x590>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002cec:	7dfb      	ldrb	r3, [r7, #23]
70002cee:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM1 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM1) == RCC_PERIPHCLK_LPTIM1)
70002cf0:	687b      	ldr	r3, [r7, #4]
70002cf2:	681b      	ldr	r3, [r3, #0]
70002cf4:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
70002cf8:	2b00      	cmp	r3, #0
70002cfa:	d045      	beq.n	70002d88 <HAL_RCCEx_PeriphCLKConfig+0x628>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPTIM1CLKSOURCE(PeriphClkInit->Lptim1ClockSelection));

    switch (PeriphClkInit->Lptim1ClockSelection)
70002cfc:	687b      	ldr	r3, [r7, #4]
70002cfe:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
70002d00:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
70002d04:	d02a      	beq.n	70002d5c <HAL_RCCEx_PeriphCLKConfig+0x5fc>
70002d06:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
70002d0a:	d824      	bhi.n	70002d56 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
70002d0c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70002d10:	d026      	beq.n	70002d60 <HAL_RCCEx_PeriphCLKConfig+0x600>
70002d12:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70002d16:	d81e      	bhi.n	70002d56 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
70002d18:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
70002d1c:	d022      	beq.n	70002d64 <HAL_RCCEx_PeriphCLKConfig+0x604>
70002d1e:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
70002d22:	d818      	bhi.n	70002d56 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
70002d24:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70002d28:	d00e      	beq.n	70002d48 <HAL_RCCEx_PeriphCLKConfig+0x5e8>
70002d2a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70002d2e:	d812      	bhi.n	70002d56 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
70002d30:	2b00      	cmp	r3, #0
70002d32:	d019      	beq.n	70002d68 <HAL_RCCEx_PeriphCLKConfig+0x608>
70002d34:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
70002d38:	d10d      	bne.n	70002d56 <HAL_RCCEx_PeriphCLKConfig+0x5f6>
      case RCC_LPTIM1CLKSOURCE_PCLK1: /* PCLK1 as clock source for LPTIM1 */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM1CLKSOURCE_PLL2P: /* PLL2_P is used as clock source for LPTIM1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70002d3a:	4b5e      	ldr	r3, [pc, #376]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002d3c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002d3e:	4a5d      	ldr	r2, [pc, #372]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002d40:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70002d44:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
70002d46:	e010      	b.n	70002d6a <HAL_RCCEx_PeriphCLKConfig+0x60a>

      case RCC_LPTIM1CLKSOURCE_PLL3R:  /* PLL3_R is used as clock source for LPTIM1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002d48:	4b5a      	ldr	r3, [pc, #360]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002d4a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002d4c:	4a59      	ldr	r2, [pc, #356]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002d4e:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002d52:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;
70002d54:	e009      	b.n	70002d6a <HAL_RCCEx_PeriphCLKConfig+0x60a>
        /* HSI, HSE, or CSI oscillator is used as clock source for LPTIM1 */
        /* LPTIM1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002d56:	2301      	movs	r3, #1
70002d58:	75fb      	strb	r3, [r7, #23]
        break;
70002d5a:	e006      	b.n	70002d6a <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
70002d5c:	bf00      	nop
70002d5e:	e004      	b.n	70002d6a <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
70002d60:	bf00      	nop
70002d62:	e002      	b.n	70002d6a <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
70002d64:	bf00      	nop
70002d66:	e000      	b.n	70002d6a <HAL_RCCEx_PeriphCLKConfig+0x60a>
        break;
70002d68:	bf00      	nop
    }

    if (ret == HAL_OK)
70002d6a:	7dfb      	ldrb	r3, [r7, #23]
70002d6c:	2b00      	cmp	r3, #0
70002d6e:	d109      	bne.n	70002d84 <HAL_RCCEx_PeriphCLKConfig+0x624>
    {
      /* Set the source of LPTIM1 clock*/
      __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
70002d70:	4b50      	ldr	r3, [pc, #320]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002d72:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70002d74:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
70002d78:	687b      	ldr	r3, [r7, #4]
70002d7a:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
70002d7c:	494d      	ldr	r1, [pc, #308]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002d7e:	4313      	orrs	r3, r2
70002d80:	650b      	str	r3, [r1, #80]	@ 0x50
70002d82:	e001      	b.n	70002d88 <HAL_RCCEx_PeriphCLKConfig+0x628>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002d84:	7dfb      	ldrb	r3, [r7, #23]
70002d86:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM2/LPTIM3 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM23) == RCC_PERIPHCLK_LPTIM23)
70002d88:	687b      	ldr	r3, [r7, #4]
70002d8a:	681b      	ldr	r3, [r3, #0]
70002d8c:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
70002d90:	2b00      	cmp	r3, #0
70002d92:	d045      	beq.n	70002e20 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
  {
    switch (PeriphClkInit->Lptim23ClockSelection)
70002d94:	687b      	ldr	r3, [r7, #4]
70002d96:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70002d98:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
70002d9c:	d02a      	beq.n	70002df4 <HAL_RCCEx_PeriphCLKConfig+0x694>
70002d9e:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
70002da2:	d824      	bhi.n	70002dee <HAL_RCCEx_PeriphCLKConfig+0x68e>
70002da4:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70002da8:	d026      	beq.n	70002df8 <HAL_RCCEx_PeriphCLKConfig+0x698>
70002daa:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70002dae:	d81e      	bhi.n	70002dee <HAL_RCCEx_PeriphCLKConfig+0x68e>
70002db0:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70002db4:	d022      	beq.n	70002dfc <HAL_RCCEx_PeriphCLKConfig+0x69c>
70002db6:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70002dba:	d818      	bhi.n	70002dee <HAL_RCCEx_PeriphCLKConfig+0x68e>
70002dbc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70002dc0:	d00e      	beq.n	70002de0 <HAL_RCCEx_PeriphCLKConfig+0x680>
70002dc2:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70002dc6:	d812      	bhi.n	70002dee <HAL_RCCEx_PeriphCLKConfig+0x68e>
70002dc8:	2b00      	cmp	r3, #0
70002dca:	d019      	beq.n	70002e00 <HAL_RCCEx_PeriphCLKConfig+0x6a0>
70002dcc:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
70002dd0:	d10d      	bne.n	70002dee <HAL_RCCEx_PeriphCLKConfig+0x68e>
      case RCC_LPTIM23CLKSOURCE_PCLK4: /* PCLK4 as clock source for LPTIM2/LPTIM3 */
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM23CLKSOURCE_PLL2P: /* PLL2_P is used as clock source for LPTIM2/LPTIM3 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70002dd2:	4b38      	ldr	r3, [pc, #224]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002dd4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002dd6:	4a37      	ldr	r2, [pc, #220]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002dd8:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70002ddc:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;
70002dde:	e010      	b.n	70002e02 <HAL_RCCEx_PeriphCLKConfig+0x6a2>

      case RCC_LPTIM23CLKSOURCE_PLL3R: /* PLL3_R is used as clock source for LPTIM2/LPTIM3 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002de0:	4b34      	ldr	r3, [pc, #208]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002de2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002de4:	4a33      	ldr	r2, [pc, #204]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002de6:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002dea:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;
70002dec:	e009      	b.n	70002e02 <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM2 clock */
        /* LPTIM2/LPTIM3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002dee:	2301      	movs	r3, #1
70002df0:	75fb      	strb	r3, [r7, #23]
        break;
70002df2:	e006      	b.n	70002e02 <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
70002df4:	bf00      	nop
70002df6:	e004      	b.n	70002e02 <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
70002df8:	bf00      	nop
70002dfa:	e002      	b.n	70002e02 <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
70002dfc:	bf00      	nop
70002dfe:	e000      	b.n	70002e02 <HAL_RCCEx_PeriphCLKConfig+0x6a2>
        break;
70002e00:	bf00      	nop
    }

    if (ret == HAL_OK)
70002e02:	7dfb      	ldrb	r3, [r7, #23]
70002e04:	2b00      	cmp	r3, #0
70002e06:	d109      	bne.n	70002e1c <HAL_RCCEx_PeriphCLKConfig+0x6bc>
    {
      /* Set the source of LPTIM2/LPTIM3 clock*/
      __HAL_RCC_LPTIM23_CONFIG(PeriphClkInit->Lptim23ClockSelection);
70002e08:	4b2a      	ldr	r3, [pc, #168]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002e0a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
70002e0c:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
70002e10:	687b      	ldr	r3, [r7, #4]
70002e12:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70002e14:	4927      	ldr	r1, [pc, #156]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002e16:	4313      	orrs	r3, r2
70002e18:	658b      	str	r3, [r1, #88]	@ 0x58
70002e1a:	e001      	b.n	70002e20 <HAL_RCCEx_PeriphCLKConfig+0x6c0>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002e1c:	7dfb      	ldrb	r3, [r7, #23]
70002e1e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- LPTIM4/LPTIM5 configuration -----------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPTIM45) == RCC_PERIPHCLK_LPTIM45)
70002e20:	687b      	ldr	r3, [r7, #4]
70002e22:	681b      	ldr	r3, [r3, #0]
70002e24:	f403 4380 	and.w	r3, r3, #16384	@ 0x4000
70002e28:	2b00      	cmp	r3, #0
70002e2a:	d047      	beq.n	70002ebc <HAL_RCCEx_PeriphCLKConfig+0x75c>
  {
    switch (PeriphClkInit->Lptim45ClockSelection)
70002e2c:	687b      	ldr	r3, [r7, #4]
70002e2e:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
70002e30:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
70002e34:	d02a      	beq.n	70002e8c <HAL_RCCEx_PeriphCLKConfig+0x72c>
70002e36:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
70002e3a:	d824      	bhi.n	70002e86 <HAL_RCCEx_PeriphCLKConfig+0x726>
70002e3c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
70002e40:	d026      	beq.n	70002e90 <HAL_RCCEx_PeriphCLKConfig+0x730>
70002e42:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
70002e46:	d81e      	bhi.n	70002e86 <HAL_RCCEx_PeriphCLKConfig+0x726>
70002e48:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70002e4c:	d022      	beq.n	70002e94 <HAL_RCCEx_PeriphCLKConfig+0x734>
70002e4e:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70002e52:	d818      	bhi.n	70002e86 <HAL_RCCEx_PeriphCLKConfig+0x726>
70002e54:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70002e58:	d00e      	beq.n	70002e78 <HAL_RCCEx_PeriphCLKConfig+0x718>
70002e5a:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70002e5e:	d812      	bhi.n	70002e86 <HAL_RCCEx_PeriphCLKConfig+0x726>
70002e60:	2b00      	cmp	r3, #0
70002e62:	d019      	beq.n	70002e98 <HAL_RCCEx_PeriphCLKConfig+0x738>
70002e64:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
70002e68:	d10d      	bne.n	70002e86 <HAL_RCCEx_PeriphCLKConfig+0x726>
      case RCC_LPTIM45CLKSOURCE_PCLK4:  /* PCLK4 as clock source for LPTIM4/LPTIM5 */
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;

      case RCC_LPTIM45CLKSOURCE_PLL2P: /* PLL2 is used as clock source for LPTIM4/LPTIM5 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70002e6a:	4b12      	ldr	r3, [pc, #72]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002e6c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002e6e:	4a11      	ldr	r2, [pc, #68]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002e70:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70002e74:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;
70002e76:	e010      	b.n	70002e9a <HAL_RCCEx_PeriphCLKConfig+0x73a>

      case RCC_LPTIM45CLKSOURCE_PLL3R:  /* PLL3 is used as clock source for LPTIM4/LPTIM5 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002e78:	4b0e      	ldr	r3, [pc, #56]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002e7a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002e7c:	4a0d      	ldr	r2, [pc, #52]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002e7e:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002e82:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;
70002e84:	e009      	b.n	70002e9a <HAL_RCCEx_PeriphCLKConfig+0x73a>
        /* HSI, HSE, or CSI oscillator is used as source of LPTIM4/LPTIM5 clock */
        /* LPTIM4/LPTIM5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002e86:	2301      	movs	r3, #1
70002e88:	75fb      	strb	r3, [r7, #23]
        break;
70002e8a:	e006      	b.n	70002e9a <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
70002e8c:	bf00      	nop
70002e8e:	e004      	b.n	70002e9a <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
70002e90:	bf00      	nop
70002e92:	e002      	b.n	70002e9a <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
70002e94:	bf00      	nop
70002e96:	e000      	b.n	70002e9a <HAL_RCCEx_PeriphCLKConfig+0x73a>
        break;
70002e98:	bf00      	nop
    }

    if (ret == HAL_OK)
70002e9a:	7dfb      	ldrb	r3, [r7, #23]
70002e9c:	2b00      	cmp	r3, #0
70002e9e:	d10b      	bne.n	70002eb8 <HAL_RCCEx_PeriphCLKConfig+0x758>
    {
      /* Set the source of LPTIM4/LPTIM5 clock */
      __HAL_RCC_LPTIM45_CONFIG(PeriphClkInit->Lptim45ClockSelection);
70002ea0:	4b04      	ldr	r3, [pc, #16]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002ea2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
70002ea4:	f423 42e0 	bic.w	r2, r3, #28672	@ 0x7000
70002ea8:	687b      	ldr	r3, [r7, #4]
70002eaa:	6bdb      	ldr	r3, [r3, #60]	@ 0x3c
70002eac:	4901      	ldr	r1, [pc, #4]	@ (70002eb4 <HAL_RCCEx_PeriphCLKConfig+0x754>)
70002eae:	4313      	orrs	r3, r2
70002eb0:	658b      	str	r3, [r1, #88]	@ 0x58
70002eb2:	e003      	b.n	70002ebc <HAL_RCCEx_PeriphCLKConfig+0x75c>
70002eb4:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
70002eb8:	7dfb      	ldrb	r3, [r7, #23]
70002eba:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LPUART1 Configuration -------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
70002ebc:	687b      	ldr	r3, [r7, #4]
70002ebe:	681b      	ldr	r3, [r3, #0]
70002ec0:	f403 4300 	and.w	r3, r3, #32768	@ 0x8000
70002ec4:	2b00      	cmp	r3, #0
70002ec6:	d034      	beq.n	70002f32 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
  {
    /* Check the parameters */
    assert_param(IS_RCC_LPUART1CLKSOURCE(PeriphClkInit->Lpuart1ClockSelection));

    switch (PeriphClkInit->Lpuart1ClockSelection)
70002ec8:	687b      	ldr	r3, [r7, #4]
70002eca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70002ecc:	2b05      	cmp	r3, #5
70002ece:	d81d      	bhi.n	70002f0c <HAL_RCCEx_PeriphCLKConfig+0x7ac>
70002ed0:	a201      	add	r2, pc, #4	@ (adr r2, 70002ed8 <HAL_RCCEx_PeriphCLKConfig+0x778>)
70002ed2:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70002ed6:	bf00      	nop
70002ed8:	70002f13 	.word	0x70002f13
70002edc:	70002ef1 	.word	0x70002ef1
70002ee0:	70002eff 	.word	0x70002eff
70002ee4:	70002f13 	.word	0x70002f13
70002ee8:	70002f13 	.word	0x70002f13
70002eec:	70002f13 	.word	0x70002f13
      case RCC_LPUART1CLKSOURCE_PCLK4: /* PCLK4 selected as clock source for LPUART1 */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      case RCC_LPUART1CLKSOURCE_PLL2Q: /* PLL2_Q is used as clock source for LPUART1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
70002ef0:	4b91      	ldr	r3, [pc, #580]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002ef2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002ef4:	4a90      	ldr	r2, [pc, #576]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002ef6:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
70002efa:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
70002efc:	e00a      	b.n	70002f14 <HAL_RCCEx_PeriphCLKConfig+0x7b4>

      case RCC_LPUART1CLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for LPUART1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
70002efe:	4b8e      	ldr	r3, [pc, #568]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f00:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002f02:	4a8d      	ldr	r2, [pc, #564]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f04:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
70002f08:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* LPUART1 clock source configuration done later after clock selection check */
        break;
70002f0a:	e003      	b.n	70002f14 <HAL_RCCEx_PeriphCLKConfig+0x7b4>
        /* LSE,  oscillator is used as source of LPUART1 clock */
        /* LPUART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002f0c:	2301      	movs	r3, #1
70002f0e:	75fb      	strb	r3, [r7, #23]
        break;
70002f10:	e000      	b.n	70002f14 <HAL_RCCEx_PeriphCLKConfig+0x7b4>
        break;
70002f12:	bf00      	nop
    }

    if (ret == HAL_OK)
70002f14:	7dfb      	ldrb	r3, [r7, #23]
70002f16:	2b00      	cmp	r3, #0
70002f18:	d109      	bne.n	70002f2e <HAL_RCCEx_PeriphCLKConfig+0x7ce>
    {
      /* Set the source of LPUART1 clock */
      __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
70002f1a:	4b87      	ldr	r3, [pc, #540]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f1c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
70002f1e:	f023 0207 	bic.w	r2, r3, #7
70002f22:	687b      	ldr	r3, [r7, #4]
70002f24:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70002f26:	4984      	ldr	r1, [pc, #528]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f28:	4313      	orrs	r3, r2
70002f2a:	658b      	str	r3, [r1, #88]	@ 0x58
70002f2c:	e001      	b.n	70002f32 <HAL_RCCEx_PeriphCLKConfig+0x7d2>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002f2e:	7dfb      	ldrb	r3, [r7, #23]
70002f30:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- LTDC Configuration ----------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_LTDC) == RCC_PERIPHCLK_LTDC)
70002f32:	687b      	ldr	r3, [r7, #4]
70002f34:	681b      	ldr	r3, [r3, #0]
70002f36:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70002f3a:	2b00      	cmp	r3, #0
70002f3c:	d005      	beq.n	70002f4a <HAL_RCCEx_PeriphCLKConfig+0x7ea>
  {
    /* LTDC internally connected to PLL3_R output clock */
    __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002f3e:	4b7e      	ldr	r3, [pc, #504]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f40:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002f42:	4a7d      	ldr	r2, [pc, #500]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f44:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002f48:	62d3      	str	r3, [r2, #44]	@ 0x2c
  }

  /*---------------------------- PSSI configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_PSSI) == RCC_PERIPHCLK_PSSI)
70002f4a:	687b      	ldr	r3, [r7, #4]
70002f4c:	681b      	ldr	r3, [r3, #0]
70002f4e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70002f52:	2b00      	cmp	r3, #0
70002f54:	d021      	beq.n	70002f9a <HAL_RCCEx_PeriphCLKConfig+0x83a>
  {
    /* Check the parameters */
    assert_param(IS_RCC_PSSICLKSOURCE(PeriphClkInit->PssiClockSelection));

    switch (PeriphClkInit->PssiClockSelection)
70002f56:	687b      	ldr	r3, [r7, #4]
70002f58:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
70002f5a:	2b00      	cmp	r3, #0
70002f5c:	d003      	beq.n	70002f66 <HAL_RCCEx_PeriphCLKConfig+0x806>
70002f5e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
70002f62:	d00a      	beq.n	70002f7a <HAL_RCCEx_PeriphCLKConfig+0x81a>
70002f64:	e006      	b.n	70002f74 <HAL_RCCEx_PeriphCLKConfig+0x814>
    {
      case RCC_PSSICLKSOURCE_PLL3R:  /* PLL3_R is used as clock source for PSSI */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70002f66:	4b74      	ldr	r3, [pc, #464]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f68:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002f6a:	4a73      	ldr	r2, [pc, #460]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f6c:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
70002f70:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* PSSI clock source configuration done later after clock selection check */
        break;
70002f72:	e003      	b.n	70002f7c <HAL_RCCEx_PeriphCLKConfig+0x81c>
        /* HSI, HSE, or CSI oscillator is used as source of PSSI clock */
        /* PSSI clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70002f74:	2301      	movs	r3, #1
70002f76:	75fb      	strb	r3, [r7, #23]
        break;
70002f78:	e000      	b.n	70002f7c <HAL_RCCEx_PeriphCLKConfig+0x81c>
        break;
70002f7a:	bf00      	nop
    }

    if (ret == HAL_OK)
70002f7c:	7dfb      	ldrb	r3, [r7, #23]
70002f7e:	2b00      	cmp	r3, #0
70002f80:	d109      	bne.n	70002f96 <HAL_RCCEx_PeriphCLKConfig+0x836>
    {
      /* Set the source of PSSI clock*/
      __HAL_RCC_PSSI_CONFIG(PeriphClkInit->PssiClockSelection);
70002f82:	4b6d      	ldr	r3, [pc, #436]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f84:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70002f86:	f023 6200 	bic.w	r2, r3, #134217728	@ 0x8000000
70002f8a:	687b      	ldr	r3, [r7, #4]
70002f8c:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
70002f8e:	496a      	ldr	r1, [pc, #424]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002f90:	4313      	orrs	r3, r2
70002f92:	64cb      	str	r3, [r1, #76]	@ 0x4c
70002f94:	e001      	b.n	70002f9a <HAL_RCCEx_PeriphCLKConfig+0x83a>
    }
    else
    {
      /* set overall return value */
      status = ret;
70002f96:	7dfb      	ldrb	r3, [r7, #23]
70002f98:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1)
70002f9a:	687b      	ldr	r3, [r7, #4]
70002f9c:	681b      	ldr	r3, [r3, #0]
70002f9e:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
70002fa2:	2b00      	cmp	r3, #0
70002fa4:	d043      	beq.n	7000302e <HAL_RCCEx_PeriphCLKConfig+0x8ce>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI1CLKSOURCE(PeriphClkInit->Sai1ClockSelection));

    switch (PeriphClkInit->Sai1ClockSelection)
70002fa6:	687b      	ldr	r3, [r7, #4]
70002fa8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70002faa:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70002fae:	d02c      	beq.n	7000300a <HAL_RCCEx_PeriphCLKConfig+0x8aa>
70002fb0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70002fb4:	d826      	bhi.n	70003004 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
70002fb6:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
70002fba:	d028      	beq.n	7000300e <HAL_RCCEx_PeriphCLKConfig+0x8ae>
70002fbc:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
70002fc0:	d820      	bhi.n	70003004 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
70002fc2:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70002fc6:	d016      	beq.n	70002ff6 <HAL_RCCEx_PeriphCLKConfig+0x896>
70002fc8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70002fcc:	d81a      	bhi.n	70003004 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
70002fce:	2b00      	cmp	r3, #0
70002fd0:	d003      	beq.n	70002fda <HAL_RCCEx_PeriphCLKConfig+0x87a>
70002fd2:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
70002fd6:	d007      	beq.n	70002fe8 <HAL_RCCEx_PeriphCLKConfig+0x888>
70002fd8:	e014      	b.n	70003004 <HAL_RCCEx_PeriphCLKConfig+0x8a4>
    {
      case RCC_SAI1CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SAI1 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
70002fda:	4b57      	ldr	r3, [pc, #348]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002fdc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002fde:	4a56      	ldr	r2, [pc, #344]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002fe0:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70002fe4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI1 clock source configuration done later after clock selection check */
        break;
70002fe6:	e013      	b.n	70003010 <HAL_RCCEx_PeriphCLKConfig+0x8b0>

      case RCC_SAI1CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SAI1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70002fe8:	4b53      	ldr	r3, [pc, #332]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002fea:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002fec:	4a52      	ldr	r2, [pc, #328]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002fee:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70002ff2:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI1 clock source configuration done later after clock selection check */
        break;
70002ff4:	e00c      	b.n	70003010 <HAL_RCCEx_PeriphCLKConfig+0x8b0>

      case RCC_SAI1CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SAI1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
70002ff6:	4b50      	ldr	r3, [pc, #320]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002ff8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70002ffa:	4a4f      	ldr	r2, [pc, #316]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70002ffc:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
70003000:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI1 clock source configuration done later after clock selection check */
        break;
70003002:	e005      	b.n	70003010 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
        /* HSI, HSE, or CSI oscillator is used as source of SAI1 clock */
        /* SAI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70003004:	2301      	movs	r3, #1
70003006:	75fb      	strb	r3, [r7, #23]
        break;
70003008:	e002      	b.n	70003010 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
        break;
7000300a:	bf00      	nop
7000300c:	e000      	b.n	70003010 <HAL_RCCEx_PeriphCLKConfig+0x8b0>
        break;
7000300e:	bf00      	nop
    }

    if (ret == HAL_OK)
70003010:	7dfb      	ldrb	r3, [r7, #23]
70003012:	2b00      	cmp	r3, #0
70003014:	d109      	bne.n	7000302a <HAL_RCCEx_PeriphCLKConfig+0x8ca>
    {
      /* Set the source of SAI1 clock*/
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
70003016:	4b48      	ldr	r3, [pc, #288]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003018:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
7000301a:	f423 22e0 	bic.w	r2, r3, #458752	@ 0x70000
7000301e:	687b      	ldr	r3, [r7, #4]
70003020:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70003022:	4945      	ldr	r1, [pc, #276]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003024:	4313      	orrs	r3, r2
70003026:	654b      	str	r3, [r1, #84]	@ 0x54
70003028:	e001      	b.n	7000302e <HAL_RCCEx_PeriphCLKConfig+0x8ce>
    }
    else
    {
      /* set overall return value */
      status = ret;
7000302a:	7dfb      	ldrb	r3, [r7, #23]
7000302c:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SAI2 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2)
7000302e:	687b      	ldr	r3, [r7, #4]
70003030:	681b      	ldr	r3, [r3, #0]
70003032:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
70003036:	2b00      	cmp	r3, #0
70003038:	d04b      	beq.n	700030d2 <HAL_RCCEx_PeriphCLKConfig+0x972>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SAI2CLKSOURCE(PeriphClkInit->Sai2ClockSelection));

    switch (PeriphClkInit->Sai2ClockSelection)
7000303a:	687b      	ldr	r3, [r7, #4]
7000303c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
7000303e:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
70003042:	d032      	beq.n	700030aa <HAL_RCCEx_PeriphCLKConfig+0x94a>
70003044:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
70003048:	d82c      	bhi.n	700030a4 <HAL_RCCEx_PeriphCLKConfig+0x944>
7000304a:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
7000304e:	d02e      	beq.n	700030ae <HAL_RCCEx_PeriphCLKConfig+0x94e>
70003050:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70003054:	d826      	bhi.n	700030a4 <HAL_RCCEx_PeriphCLKConfig+0x944>
70003056:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
7000305a:	d02a      	beq.n	700030b2 <HAL_RCCEx_PeriphCLKConfig+0x952>
7000305c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
70003060:	d820      	bhi.n	700030a4 <HAL_RCCEx_PeriphCLKConfig+0x944>
70003062:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
70003066:	d016      	beq.n	70003096 <HAL_RCCEx_PeriphCLKConfig+0x936>
70003068:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
7000306c:	d81a      	bhi.n	700030a4 <HAL_RCCEx_PeriphCLKConfig+0x944>
7000306e:	2b00      	cmp	r3, #0
70003070:	d003      	beq.n	7000307a <HAL_RCCEx_PeriphCLKConfig+0x91a>
70003072:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
70003076:	d007      	beq.n	70003088 <HAL_RCCEx_PeriphCLKConfig+0x928>
70003078:	e014      	b.n	700030a4 <HAL_RCCEx_PeriphCLKConfig+0x944>
    {
      case RCC_SAI2CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SAI2 */
        /* Enable SAI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
7000307a:	4b2f      	ldr	r3, [pc, #188]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
7000307c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000307e:	4a2e      	ldr	r2, [pc, #184]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003080:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70003084:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI2 clock source configuration done later after clock selection check */
        break;
70003086:	e015      	b.n	700030b4 <HAL_RCCEx_PeriphCLKConfig+0x954>

      case RCC_SAI2CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SAI2 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70003088:	4b2b      	ldr	r3, [pc, #172]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
7000308a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000308c:	4a2a      	ldr	r2, [pc, #168]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
7000308e:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
70003092:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI2 clock source configuration done later after clock selection check */
        break;
70003094:	e00e      	b.n	700030b4 <HAL_RCCEx_PeriphCLKConfig+0x954>

      case RCC_SAI2CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SAI2 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
70003096:	4b28      	ldr	r3, [pc, #160]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003098:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000309a:	4a27      	ldr	r2, [pc, #156]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
7000309c:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
700030a0:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SAI2 clock source configuration done later after clock selection check */
        break;
700030a2:	e007      	b.n	700030b4 <HAL_RCCEx_PeriphCLKConfig+0x954>
      case RCC_SAI2CLKSOURCE_SPDIF: /* SPDIF clock is used as source of SAI2 clock */
        /* SAI2 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
700030a4:	2301      	movs	r3, #1
700030a6:	75fb      	strb	r3, [r7, #23]
        break;
700030a8:	e004      	b.n	700030b4 <HAL_RCCEx_PeriphCLKConfig+0x954>
        break;
700030aa:	bf00      	nop
700030ac:	e002      	b.n	700030b4 <HAL_RCCEx_PeriphCLKConfig+0x954>
        break;
700030ae:	bf00      	nop
700030b0:	e000      	b.n	700030b4 <HAL_RCCEx_PeriphCLKConfig+0x954>
        break;
700030b2:	bf00      	nop
    }

    if (ret == HAL_OK)
700030b4:	7dfb      	ldrb	r3, [r7, #23]
700030b6:	2b00      	cmp	r3, #0
700030b8:	d109      	bne.n	700030ce <HAL_RCCEx_PeriphCLKConfig+0x96e>
    {
      /* Set the source of SAI2 clock*/
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
700030ba:	4b1f      	ldr	r3, [pc, #124]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
700030bc:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
700030be:	f423 02e0 	bic.w	r2, r3, #7340032	@ 0x700000
700030c2:	687b      	ldr	r3, [r7, #4]
700030c4:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
700030c6:	491c      	ldr	r1, [pc, #112]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
700030c8:	4313      	orrs	r3, r2
700030ca:	654b      	str	r3, [r1, #84]	@ 0x54
700030cc:	e001      	b.n	700030d2 <HAL_RCCEx_PeriphCLKConfig+0x972>
    }
    else
    {
      /* set overall return value */
      status = ret;
700030ce:	7dfb      	ldrb	r3, [r7, #23]
700030d0:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPDIFRX configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPDIFRX) == RCC_PERIPHCLK_SPDIFRX)
700030d2:	687b      	ldr	r3, [r7, #4]
700030d4:	681b      	ldr	r3, [r3, #0]
700030d6:	f403 0380 	and.w	r3, r3, #4194304	@ 0x400000
700030da:	2b00      	cmp	r3, #0
700030dc:	d03e      	beq.n	7000315c <HAL_RCCEx_PeriphCLKConfig+0x9fc>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPDIFRXCLKSOURCE(PeriphClkInit->SpdifrxClockSelection));

    switch (PeriphClkInit->SpdifrxClockSelection)
700030de:	687b      	ldr	r3, [r7, #4]
700030e0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
700030e2:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
700030e6:	d029      	beq.n	7000313c <HAL_RCCEx_PeriphCLKConfig+0x9dc>
700030e8:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
700030ec:	d820      	bhi.n	70003130 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
700030ee:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
700030f2:	d016      	beq.n	70003122 <HAL_RCCEx_PeriphCLKConfig+0x9c2>
700030f4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
700030f8:	d81a      	bhi.n	70003130 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
700030fa:	2b00      	cmp	r3, #0
700030fc:	d003      	beq.n	70003106 <HAL_RCCEx_PeriphCLKConfig+0x9a6>
700030fe:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
70003102:	d007      	beq.n	70003114 <HAL_RCCEx_PeriphCLKConfig+0x9b4>
70003104:	e014      	b.n	70003130 <HAL_RCCEx_PeriphCLKConfig+0x9d0>
    {
      case RCC_SPDIFRXCLKSOURCE_PLL1Q: /* PLL1_Q is used as clock source for SPDIFRX */
        /* Enable PLL1Q Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
70003106:	4b0c      	ldr	r3, [pc, #48]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003108:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000310a:	4a0b      	ldr	r2, [pc, #44]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
7000310c:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70003110:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
70003112:	e014      	b.n	7000313e <HAL_RCCEx_PeriphCLKConfig+0x9de>

      case RCC_SPDIFRXCLKSOURCE_PLL2R: /* PLL2_R is used as clock source for SPDIFRX */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_RCLK);
70003114:	4b08      	ldr	r3, [pc, #32]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003116:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003118:	4a07      	ldr	r2, [pc, #28]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
7000311a:	f443 2380 	orr.w	r3, r3, #262144	@ 0x40000
7000311e:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
70003120:	e00d      	b.n	7000313e <HAL_RCCEx_PeriphCLKConfig+0x9de>

      case RCC_SPDIFRXCLKSOURCE_PLL3R:  /* PLL3_R is used as clock source for SPDIFRX */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_RCLK);
70003122:	4b05      	ldr	r3, [pc, #20]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003124:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003126:	4a04      	ldr	r2, [pc, #16]	@ (70003138 <HAL_RCCEx_PeriphCLKConfig+0x9d8>)
70003128:	f043 5300 	orr.w	r3, r3, #536870912	@ 0x20000000
7000312c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;
7000312e:	e006      	b.n	7000313e <HAL_RCCEx_PeriphCLKConfig+0x9de>
        /* Internal OSC clock is used as source of SPDIFRX clock*/
        /* SPDIFRX clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70003130:	2301      	movs	r3, #1
70003132:	75fb      	strb	r3, [r7, #23]
        break;
70003134:	e003      	b.n	7000313e <HAL_RCCEx_PeriphCLKConfig+0x9de>
70003136:	bf00      	nop
70003138:	58024400 	.word	0x58024400
        break;
7000313c:	bf00      	nop
    }

    if (ret == HAL_OK)
7000313e:	7dfb      	ldrb	r3, [r7, #23]
70003140:	2b00      	cmp	r3, #0
70003142:	d109      	bne.n	70003158 <HAL_RCCEx_PeriphCLKConfig+0x9f8>
    {
      /* Set the source of SPDIFRX clock */
      __HAL_RCC_SPDIFRX_CONFIG(PeriphClkInit->SpdifrxClockSelection);
70003144:	4b8e      	ldr	r3, [pc, #568]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003146:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70003148:	f023 7240 	bic.w	r2, r3, #50331648	@ 0x3000000
7000314c:	687b      	ldr	r3, [r7, #4]
7000314e:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
70003150:	498b      	ldr	r1, [pc, #556]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003152:	4313      	orrs	r3, r2
70003154:	650b      	str	r3, [r1, #80]	@ 0x50
70003156:	e001      	b.n	7000315c <HAL_RCCEx_PeriphCLKConfig+0x9fc>
    }
    else
    {
      /* set overall return value */
      status = ret;
70003158:	7dfb      	ldrb	r3, [r7, #23]
7000315a:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI1) == RCC_PERIPHCLK_SPI1)
7000315c:	687b      	ldr	r3, [r7, #4]
7000315e:	681b      	ldr	r3, [r3, #0]
70003160:	f403 0300 	and.w	r3, r3, #8388608	@ 0x800000
70003164:	2b00      	cmp	r3, #0
70003166:	d043      	beq.n	700031f0 <HAL_RCCEx_PeriphCLKConfig+0xa90>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI1CLKSOURCE(PeriphClkInit->Spi1ClockSelection));

    switch (PeriphClkInit->Spi1ClockSelection)
70003168:	687b      	ldr	r3, [r7, #4]
7000316a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
7000316c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70003170:	d02c      	beq.n	700031cc <HAL_RCCEx_PeriphCLKConfig+0xa6c>
70003172:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70003176:	d826      	bhi.n	700031c6 <HAL_RCCEx_PeriphCLKConfig+0xa66>
70003178:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
7000317c:	d028      	beq.n	700031d0 <HAL_RCCEx_PeriphCLKConfig+0xa70>
7000317e:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70003182:	d820      	bhi.n	700031c6 <HAL_RCCEx_PeriphCLKConfig+0xa66>
70003184:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70003188:	d016      	beq.n	700031b8 <HAL_RCCEx_PeriphCLKConfig+0xa58>
7000318a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
7000318e:	d81a      	bhi.n	700031c6 <HAL_RCCEx_PeriphCLKConfig+0xa66>
70003190:	2b00      	cmp	r3, #0
70003192:	d003      	beq.n	7000319c <HAL_RCCEx_PeriphCLKConfig+0xa3c>
70003194:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
70003198:	d007      	beq.n	700031aa <HAL_RCCEx_PeriphCLKConfig+0xa4a>
7000319a:	e014      	b.n	700031c6 <HAL_RCCEx_PeriphCLKConfig+0xa66>
    {
      case RCC_SPI1CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SPI1 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
7000319c:	4b78      	ldr	r3, [pc, #480]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
7000319e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700031a0:	4a77      	ldr	r2, [pc, #476]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700031a2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
700031a6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI1 clock source configuration done later after clock selection check */
        break;
700031a8:	e013      	b.n	700031d2 <HAL_RCCEx_PeriphCLKConfig+0xa72>

      case RCC_SPI1CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SPI1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
700031aa:	4b75      	ldr	r3, [pc, #468]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700031ac:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700031ae:	4a74      	ldr	r2, [pc, #464]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700031b0:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
700031b4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI1 clock source configuration done later after clock selection check */
        break;
700031b6:	e00c      	b.n	700031d2 <HAL_RCCEx_PeriphCLKConfig+0xa72>

      case RCC_SPI1CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SPI1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
700031b8:	4b71      	ldr	r3, [pc, #452]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700031ba:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700031bc:	4a70      	ldr	r2, [pc, #448]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700031be:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
700031c2:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI1 clock source configuration done later after clock selection check */
        break;
700031c4:	e005      	b.n	700031d2 <HAL_RCCEx_PeriphCLKConfig+0xa72>
      case RCC_SPI1CLKSOURCE_CLKP:  /* HSI, HSE, or CSI oscillator is used as source of SPI1 clock */
        /* SPI1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
700031c6:	2301      	movs	r3, #1
700031c8:	75fb      	strb	r3, [r7, #23]
        break;
700031ca:	e002      	b.n	700031d2 <HAL_RCCEx_PeriphCLKConfig+0xa72>
        break;
700031cc:	bf00      	nop
700031ce:	e000      	b.n	700031d2 <HAL_RCCEx_PeriphCLKConfig+0xa72>
        break;
700031d0:	bf00      	nop
    }

    if (ret == HAL_OK)
700031d2:	7dfb      	ldrb	r3, [r7, #23]
700031d4:	2b00      	cmp	r3, #0
700031d6:	d109      	bne.n	700031ec <HAL_RCCEx_PeriphCLKConfig+0xa8c>
    {
      /* Set the source of SPI1 clock*/
      __HAL_RCC_SPI1_CONFIG(PeriphClkInit->Spi1ClockSelection);
700031d8:	4b69      	ldr	r3, [pc, #420]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700031da:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
700031dc:	f423 62e0 	bic.w	r2, r3, #1792	@ 0x700
700031e0:	687b      	ldr	r3, [r7, #4]
700031e2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
700031e4:	4966      	ldr	r1, [pc, #408]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700031e6:	4313      	orrs	r3, r2
700031e8:	654b      	str	r3, [r1, #84]	@ 0x54
700031ea:	e001      	b.n	700031f0 <HAL_RCCEx_PeriphCLKConfig+0xa90>
    }
    else
    {
      /* set overall return value */
      status = ret;
700031ec:	7dfb      	ldrb	r3, [r7, #23]
700031ee:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI2/SPI3 configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI23) == RCC_PERIPHCLK_SPI23)
700031f0:	687b      	ldr	r3, [r7, #4]
700031f2:	681b      	ldr	r3, [r3, #0]
700031f4:	f003 7380 	and.w	r3, r3, #16777216	@ 0x1000000
700031f8:	2b00      	cmp	r3, #0
700031fa:	d03c      	beq.n	70003276 <HAL_RCCEx_PeriphCLKConfig+0xb16>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI23CLKSOURCE(PeriphClkInit->Spi23ClockSelection));

    switch (PeriphClkInit->Spi23ClockSelection)
700031fc:	687b      	ldr	r3, [r7, #4]
700031fe:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
70003200:	2b40      	cmp	r3, #64	@ 0x40
70003202:	d026      	beq.n	70003252 <HAL_RCCEx_PeriphCLKConfig+0xaf2>
70003204:	2b40      	cmp	r3, #64	@ 0x40
70003206:	d821      	bhi.n	7000324c <HAL_RCCEx_PeriphCLKConfig+0xaec>
70003208:	2b30      	cmp	r3, #48	@ 0x30
7000320a:	d024      	beq.n	70003256 <HAL_RCCEx_PeriphCLKConfig+0xaf6>
7000320c:	2b30      	cmp	r3, #48	@ 0x30
7000320e:	d81d      	bhi.n	7000324c <HAL_RCCEx_PeriphCLKConfig+0xaec>
70003210:	2b20      	cmp	r3, #32
70003212:	d014      	beq.n	7000323e <HAL_RCCEx_PeriphCLKConfig+0xade>
70003214:	2b20      	cmp	r3, #32
70003216:	d819      	bhi.n	7000324c <HAL_RCCEx_PeriphCLKConfig+0xaec>
70003218:	2b00      	cmp	r3, #0
7000321a:	d002      	beq.n	70003222 <HAL_RCCEx_PeriphCLKConfig+0xac2>
7000321c:	2b10      	cmp	r3, #16
7000321e:	d007      	beq.n	70003230 <HAL_RCCEx_PeriphCLKConfig+0xad0>
70003220:	e014      	b.n	7000324c <HAL_RCCEx_PeriphCLKConfig+0xaec>
    {
      case RCC_SPI23CLKSOURCE_PLL1Q:  /* PLL1_Q is used as clock source for SPI2/SPI3 */
        /* Enable SPI Clock output generated form System PLL . */
        __HAL_RCC_PLL1CLKOUT_ENABLE(RCC_PLL_QCLK);
70003222:	4b57      	ldr	r3, [pc, #348]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003224:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003226:	4a56      	ldr	r2, [pc, #344]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003228:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
7000322c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;
7000322e:	e013      	b.n	70003258 <HAL_RCCEx_PeriphCLKConfig+0xaf8>

      case RCC_SPI23CLKSOURCE_PLL2P:  /* PLL2_P is used as clock source for SPI2/SPI3 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_PCLK);
70003230:	4b53      	ldr	r3, [pc, #332]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003232:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003234:	4a52      	ldr	r2, [pc, #328]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003236:	f443 3380 	orr.w	r3, r3, #65536	@ 0x10000
7000323a:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;
7000323c:	e00c      	b.n	70003258 <HAL_RCCEx_PeriphCLKConfig+0xaf8>

      case RCC_SPI23CLKSOURCE_PLL3P:  /* PLL3_P is used as clock source for SPI2/SPI3 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_PCLK);
7000323e:	4b50      	ldr	r3, [pc, #320]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003240:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003242:	4a4f      	ldr	r2, [pc, #316]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003244:	f043 6300 	orr.w	r3, r3, #134217728	@ 0x8000000
70003248:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;
7000324a:	e005      	b.n	70003258 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
      case RCC_SPI23CLKSOURCE_CLKP:  /* HSI, HSE, or CSI oscillator is used as source of SPI2/SPI3 clock */
        /* SPI2/SPI3 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
7000324c:	2301      	movs	r3, #1
7000324e:	75fb      	strb	r3, [r7, #23]
        break;
70003250:	e002      	b.n	70003258 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
        break;
70003252:	bf00      	nop
70003254:	e000      	b.n	70003258 <HAL_RCCEx_PeriphCLKConfig+0xaf8>
        break;
70003256:	bf00      	nop
    }

    if (ret == HAL_OK)
70003258:	7dfb      	ldrb	r3, [r7, #23]
7000325a:	2b00      	cmp	r3, #0
7000325c:	d109      	bne.n	70003272 <HAL_RCCEx_PeriphCLKConfig+0xb12>
    {
      /* Set the source of SPI2/SPI3 clock*/
      __HAL_RCC_SPI23_CONFIG(PeriphClkInit->Spi23ClockSelection);
7000325e:	4b48      	ldr	r3, [pc, #288]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003260:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70003262:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
70003266:	687b      	ldr	r3, [r7, #4]
70003268:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
7000326a:	4945      	ldr	r1, [pc, #276]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
7000326c:	4313      	orrs	r3, r2
7000326e:	650b      	str	r3, [r1, #80]	@ 0x50
70003270:	e001      	b.n	70003276 <HAL_RCCEx_PeriphCLKConfig+0xb16>
    }
    else
    {
      /* set overall return value */
      status = ret;
70003272:	7dfb      	ldrb	r3, [r7, #23]
70003274:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI4/5 configuration -------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI45) == RCC_PERIPHCLK_SPI45)
70003276:	687b      	ldr	r3, [r7, #4]
70003278:	681b      	ldr	r3, [r3, #0]
7000327a:	f003 7300 	and.w	r3, r3, #33554432	@ 0x2000000
7000327e:	2b00      	cmp	r3, #0
70003280:	d03c      	beq.n	700032fc <HAL_RCCEx_PeriphCLKConfig+0xb9c>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI45CLKSOURCE(PeriphClkInit->Spi45ClockSelection));

    switch (PeriphClkInit->Spi45ClockSelection)
70003282:	687b      	ldr	r3, [r7, #4]
70003284:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
70003286:	2b50      	cmp	r3, #80	@ 0x50
70003288:	d022      	beq.n	700032d0 <HAL_RCCEx_PeriphCLKConfig+0xb70>
7000328a:	2b50      	cmp	r3, #80	@ 0x50
7000328c:	d81d      	bhi.n	700032ca <HAL_RCCEx_PeriphCLKConfig+0xb6a>
7000328e:	2b40      	cmp	r3, #64	@ 0x40
70003290:	d020      	beq.n	700032d4 <HAL_RCCEx_PeriphCLKConfig+0xb74>
70003292:	2b40      	cmp	r3, #64	@ 0x40
70003294:	d819      	bhi.n	700032ca <HAL_RCCEx_PeriphCLKConfig+0xb6a>
70003296:	2b30      	cmp	r3, #48	@ 0x30
70003298:	d01e      	beq.n	700032d8 <HAL_RCCEx_PeriphCLKConfig+0xb78>
7000329a:	2b30      	cmp	r3, #48	@ 0x30
7000329c:	d815      	bhi.n	700032ca <HAL_RCCEx_PeriphCLKConfig+0xb6a>
7000329e:	2b20      	cmp	r3, #32
700032a0:	d00c      	beq.n	700032bc <HAL_RCCEx_PeriphCLKConfig+0xb5c>
700032a2:	2b20      	cmp	r3, #32
700032a4:	d811      	bhi.n	700032ca <HAL_RCCEx_PeriphCLKConfig+0xb6a>
700032a6:	2b00      	cmp	r3, #0
700032a8:	d018      	beq.n	700032dc <HAL_RCCEx_PeriphCLKConfig+0xb7c>
700032aa:	2b10      	cmp	r3, #16
700032ac:	d10d      	bne.n	700032ca <HAL_RCCEx_PeriphCLKConfig+0xb6a>
      case RCC_SPI45CLKSOURCE_PCLK2:  /* PCLK2 as clock source for SPI4/SPI5 */
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI45CLKSOURCE_PLL2Q:  /* PLL2_Q is used as clock source for SPI4/SPI5 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
700032ae:	4b34      	ldr	r3, [pc, #208]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700032b0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700032b2:	4a33      	ldr	r2, [pc, #204]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700032b4:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
700032b8:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;
700032ba:	e010      	b.n	700032de <HAL_RCCEx_PeriphCLKConfig+0xb7e>

      case RCC_SPI45CLKSOURCE_PLL3Q:  /* PLL3_Q is used as clock source for SPI4/SPI5 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
700032bc:	4b30      	ldr	r3, [pc, #192]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700032be:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700032c0:	4a2f      	ldr	r2, [pc, #188]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700032c2:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
700032c6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;
700032c8:	e009      	b.n	700032de <HAL_RCCEx_PeriphCLKConfig+0xb7e>
      case RCC_SPI45CLKSOURCE_HSE: /* HSE oscillator clock is used as source of SPI4/SPI5 */
        /* SPI4/SPI5 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
700032ca:	2301      	movs	r3, #1
700032cc:	75fb      	strb	r3, [r7, #23]
        break;
700032ce:	e006      	b.n	700032de <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
700032d0:	bf00      	nop
700032d2:	e004      	b.n	700032de <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
700032d4:	bf00      	nop
700032d6:	e002      	b.n	700032de <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
700032d8:	bf00      	nop
700032da:	e000      	b.n	700032de <HAL_RCCEx_PeriphCLKConfig+0xb7e>
        break;
700032dc:	bf00      	nop
    }

    if (ret == HAL_OK)
700032de:	7dfb      	ldrb	r3, [r7, #23]
700032e0:	2b00      	cmp	r3, #0
700032e2:	d109      	bne.n	700032f8 <HAL_RCCEx_PeriphCLKConfig+0xb98>
    {
      /* Set the source of SPI4/SPI5 clock */
      __HAL_RCC_SPI45_CONFIG(PeriphClkInit->Spi45ClockSelection);
700032e4:	4b26      	ldr	r3, [pc, #152]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700032e6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
700032e8:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
700032ec:	687b      	ldr	r3, [r7, #4]
700032ee:	6e1b      	ldr	r3, [r3, #96]	@ 0x60
700032f0:	4923      	ldr	r1, [pc, #140]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
700032f2:	4313      	orrs	r3, r2
700032f4:	654b      	str	r3, [r1, #84]	@ 0x54
700032f6:	e001      	b.n	700032fc <HAL_RCCEx_PeriphCLKConfig+0xb9c>
    }
    else
    {
      /* set overall return value */
      status = ret;
700032f8:	7dfb      	ldrb	r3, [r7, #23]
700032fa:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*---------------------------- SPI6 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_SPI6) == RCC_PERIPHCLK_SPI6)
700032fc:	687b      	ldr	r3, [r7, #4]
700032fe:	681b      	ldr	r3, [r3, #0]
70003300:	f003 6380 	and.w	r3, r3, #67108864	@ 0x4000000
70003304:	2b00      	cmp	r3, #0
70003306:	d03f      	beq.n	70003388 <HAL_RCCEx_PeriphCLKConfig+0xc28>
  {
    /* Check the parameters */
    assert_param(IS_RCC_SPI6CLKSOURCE(PeriphClkInit->Spi6ClockSelection));

    switch (PeriphClkInit->Spi6ClockSelection)
70003308:	687b      	ldr	r3, [r7, #4]
7000330a:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
7000330c:	2b50      	cmp	r3, #80	@ 0x50
7000330e:	d022      	beq.n	70003356 <HAL_RCCEx_PeriphCLKConfig+0xbf6>
70003310:	2b50      	cmp	r3, #80	@ 0x50
70003312:	d81d      	bhi.n	70003350 <HAL_RCCEx_PeriphCLKConfig+0xbf0>
70003314:	2b40      	cmp	r3, #64	@ 0x40
70003316:	d020      	beq.n	7000335a <HAL_RCCEx_PeriphCLKConfig+0xbfa>
70003318:	2b40      	cmp	r3, #64	@ 0x40
7000331a:	d819      	bhi.n	70003350 <HAL_RCCEx_PeriphCLKConfig+0xbf0>
7000331c:	2b30      	cmp	r3, #48	@ 0x30
7000331e:	d01e      	beq.n	7000335e <HAL_RCCEx_PeriphCLKConfig+0xbfe>
70003320:	2b30      	cmp	r3, #48	@ 0x30
70003322:	d815      	bhi.n	70003350 <HAL_RCCEx_PeriphCLKConfig+0xbf0>
70003324:	2b20      	cmp	r3, #32
70003326:	d00c      	beq.n	70003342 <HAL_RCCEx_PeriphCLKConfig+0xbe2>
70003328:	2b20      	cmp	r3, #32
7000332a:	d811      	bhi.n	70003350 <HAL_RCCEx_PeriphCLKConfig+0xbf0>
7000332c:	2b00      	cmp	r3, #0
7000332e:	d018      	beq.n	70003362 <HAL_RCCEx_PeriphCLKConfig+0xc02>
70003330:	2b10      	cmp	r3, #16
70003332:	d10d      	bne.n	70003350 <HAL_RCCEx_PeriphCLKConfig+0xbf0>
      case RCC_SPI6CLKSOURCE_PCLK4: /* PCLK4 as clock source for SPI6 */
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      case RCC_SPI6CLKSOURCE_PLL2Q:  /* PLL2_Q is used as clock source for SPI6 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
70003334:	4b12      	ldr	r3, [pc, #72]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003336:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003338:	4a11      	ldr	r2, [pc, #68]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
7000333a:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
7000333e:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI6 clock source configuration done later after clock selection check */
        break;
70003340:	e010      	b.n	70003364 <HAL_RCCEx_PeriphCLKConfig+0xc04>

      case RCC_SPI6CLKSOURCE_PLL3Q:  /* PLL3_Q is used as clock source for SPI6 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
70003342:	4b0f      	ldr	r3, [pc, #60]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003344:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003346:	4a0e      	ldr	r2, [pc, #56]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003348:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
7000334c:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* SPI6 clock source configuration done later after clock selection check */
        break;
7000334e:	e009      	b.n	70003364 <HAL_RCCEx_PeriphCLKConfig+0xc04>
      case RCC_SPI6CLKSOURCE_HSE: /* HSE oscillator is used as source for SPI6 */
        /* SPI6 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
70003350:	2301      	movs	r3, #1
70003352:	75fb      	strb	r3, [r7, #23]
        break;
70003354:	e006      	b.n	70003364 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
70003356:	bf00      	nop
70003358:	e004      	b.n	70003364 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
7000335a:	bf00      	nop
7000335c:	e002      	b.n	70003364 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
7000335e:	bf00      	nop
70003360:	e000      	b.n	70003364 <HAL_RCCEx_PeriphCLKConfig+0xc04>
        break;
70003362:	bf00      	nop
    }

    if (ret == HAL_OK)
70003364:	7dfb      	ldrb	r3, [r7, #23]
70003366:	2b00      	cmp	r3, #0
70003368:	d10c      	bne.n	70003384 <HAL_RCCEx_PeriphCLKConfig+0xc24>
    {
      /* Set the source of SPI6 clock*/
      __HAL_RCC_SPI6_CONFIG(PeriphClkInit->Spi6ClockSelection);
7000336a:	4b05      	ldr	r3, [pc, #20]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
7000336c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
7000336e:	f023 0270 	bic.w	r2, r3, #112	@ 0x70
70003372:	687b      	ldr	r3, [r7, #4]
70003374:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
70003376:	4902      	ldr	r1, [pc, #8]	@ (70003380 <HAL_RCCEx_PeriphCLKConfig+0xc20>)
70003378:	4313      	orrs	r3, r2
7000337a:	658b      	str	r3, [r1, #88]	@ 0x58
7000337c:	e004      	b.n	70003388 <HAL_RCCEx_PeriphCLKConfig+0xc28>
7000337e:	bf00      	nop
70003380:	58024400 	.word	0x58024400
    }
    else
    {
      /* set overall return value */
      status = ret;
70003384:	7dfb      	ldrb	r3, [r7, #23]
70003386:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*-------------------------- USART1 configuration --------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
70003388:	687b      	ldr	r3, [r7, #4]
7000338a:	681b      	ldr	r3, [r3, #0]
7000338c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
70003390:	2b00      	cmp	r3, #0
70003392:	d034      	beq.n	700033fe <HAL_RCCEx_PeriphCLKConfig+0xc9e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART1CLKSOURCE(PeriphClkInit->Usart1ClockSelection));

    switch (PeriphClkInit->Usart1ClockSelection)
70003394:	687b      	ldr	r3, [r7, #4]
70003396:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
70003398:	2b05      	cmp	r3, #5
7000339a:	d81d      	bhi.n	700033d8 <HAL_RCCEx_PeriphCLKConfig+0xc78>
7000339c:	a201      	add	r2, pc, #4	@ (adr r2, 700033a4 <HAL_RCCEx_PeriphCLKConfig+0xc44>)
7000339e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
700033a2:	bf00      	nop
700033a4:	700033df 	.word	0x700033df
700033a8:	700033bd 	.word	0x700033bd
700033ac:	700033cb 	.word	0x700033cb
700033b0:	700033df 	.word	0x700033df
700033b4:	700033df 	.word	0x700033df
700033b8:	700033df 	.word	0x700033df
      case RCC_USART1CLKSOURCE_PCLK2: /* PCLK2 as clock source for USART1 */
        /* USART1 clock source configuration done later after clock selection check */
        break;

      case RCC_USART1CLKSOURCE_PLL2Q: /* PLL2_Q is used as clock source for USART1 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
700033bc:	4b69      	ldr	r3, [pc, #420]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700033be:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700033c0:	4a68      	ldr	r2, [pc, #416]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700033c2:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
700033c6:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART1 clock source configuration done later after clock selection check */
        break;
700033c8:	e00a      	b.n	700033e0 <HAL_RCCEx_PeriphCLKConfig+0xc80>

      case RCC_USART1CLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USART1 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
700033ca:	4b66      	ldr	r3, [pc, #408]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700033cc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700033ce:	4a65      	ldr	r2, [pc, #404]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700033d0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
700033d4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART1 clock source configuration done later after clock selection check */
        break;
700033d6:	e003      	b.n	700033e0 <HAL_RCCEx_PeriphCLKConfig+0xc80>
      case RCC_USART1CLKSOURCE_LSE: /* LSE oscillator is used as source for USART1 */
        /* USART1 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
700033d8:	2301      	movs	r3, #1
700033da:	75fb      	strb	r3, [r7, #23]
        break;
700033dc:	e000      	b.n	700033e0 <HAL_RCCEx_PeriphCLKConfig+0xc80>
        break;
700033de:	bf00      	nop
    }

    if (ret == HAL_OK)
700033e0:	7dfb      	ldrb	r3, [r7, #23]
700033e2:	2b00      	cmp	r3, #0
700033e4:	d109      	bne.n	700033fa <HAL_RCCEx_PeriphCLKConfig+0xc9a>
    {
      /* Set the source of USART1 clock */
      __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
700033e6:	4b5f      	ldr	r3, [pc, #380]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700033e8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
700033ea:	f023 0207 	bic.w	r2, r3, #7
700033ee:	687b      	ldr	r3, [r7, #4]
700033f0:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
700033f2:	495c      	ldr	r1, [pc, #368]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700033f4:	4313      	orrs	r3, r2
700033f6:	654b      	str	r3, [r1, #84]	@ 0x54
700033f8:	e001      	b.n	700033fe <HAL_RCCEx_PeriphCLKConfig+0xc9e>
    }
    else
    {
      /* set overall return value */
      status = ret;
700033fa:	7dfb      	ldrb	r3, [r7, #23]
700033fc:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------- USART2/USART3/UART4/UART5/UART7/UART8 Configuration --------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USART234578) == RCC_PERIPHCLK_USART234578)
700033fe:	687b      	ldr	r3, [r7, #4]
70003400:	681b      	ldr	r3, [r3, #0]
70003402:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
70003406:	2b00      	cmp	r3, #0
70003408:	d033      	beq.n	70003472 <HAL_RCCEx_PeriphCLKConfig+0xd12>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USART234578CLKSOURCE(PeriphClkInit->Usart234578ClockSelection));

    switch (PeriphClkInit->Usart234578ClockSelection)
7000340a:	687b      	ldr	r3, [r7, #4]
7000340c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
7000340e:	2b05      	cmp	r3, #5
70003410:	d81c      	bhi.n	7000344c <HAL_RCCEx_PeriphCLKConfig+0xcec>
70003412:	a201      	add	r2, pc, #4	@ (adr r2, 70003418 <HAL_RCCEx_PeriphCLKConfig+0xcb8>)
70003414:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70003418:	70003453 	.word	0x70003453
7000341c:	70003431 	.word	0x70003431
70003420:	7000343f 	.word	0x7000343f
70003424:	70003453 	.word	0x70003453
70003428:	70003453 	.word	0x70003453
7000342c:	70003453 	.word	0x70003453
      case RCC_USART234578CLKSOURCE_PCLK1: /* PCLK1 as clock source for USART2/USART3/UART4/UART5/UART7/UART8 */
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;

      case RCC_USART234578CLKSOURCE_PLL2Q: /* PLL2_Q is used as clock source for USART2/USART3/UART4/UART5/UART7/UART8 */
        __HAL_RCC_PLL2CLKOUT_ENABLE(RCC_PLL_QCLK);
70003430:	4b4c      	ldr	r3, [pc, #304]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
70003432:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003434:	4a4b      	ldr	r2, [pc, #300]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
70003436:	f443 3300 	orr.w	r3, r3, #131072	@ 0x20000
7000343a:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;
7000343c:	e00a      	b.n	70003454 <HAL_RCCEx_PeriphCLKConfig+0xcf4>

      case RCC_USART234578CLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USART2/USART3/UART4/UART5/UART7/UART8 */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
7000343e:	4b49      	ldr	r3, [pc, #292]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
70003440:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003442:	4a48      	ldr	r2, [pc, #288]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
70003444:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
70003448:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;
7000344a:	e003      	b.n	70003454 <HAL_RCCEx_PeriphCLKConfig+0xcf4>
        /* LSE,  oscillator is used as source of USART2/USART3/UART4/UART5/UART7/UART8 clock */
        /* USART2/USART3/UART4/UART5/UART7/UART8 clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
7000344c:	2301      	movs	r3, #1
7000344e:	75fb      	strb	r3, [r7, #23]
        break;
70003450:	e000      	b.n	70003454 <HAL_RCCEx_PeriphCLKConfig+0xcf4>
        break;
70003452:	bf00      	nop
    }

    if (ret == HAL_OK)
70003454:	7dfb      	ldrb	r3, [r7, #23]
70003456:	2b00      	cmp	r3, #0
70003458:	d109      	bne.n	7000346e <HAL_RCCEx_PeriphCLKConfig+0xd0e>
    {
      /* Set the source of USART2/USART3/UART4/UART5/UART7/UART8 clock */
      __HAL_RCC_USART234578_CONFIG(PeriphClkInit->Usart234578ClockSelection);
7000345a:	4b42      	ldr	r3, [pc, #264]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
7000345c:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
7000345e:	f023 0207 	bic.w	r2, r3, #7
70003462:	687b      	ldr	r3, [r7, #4]
70003464:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70003466:	493f      	ldr	r1, [pc, #252]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
70003468:	4313      	orrs	r3, r2
7000346a:	650b      	str	r3, [r1, #80]	@ 0x50
7000346c:	e001      	b.n	70003472 <HAL_RCCEx_PeriphCLKConfig+0xd12>
    }
    else
    {
      /* set overall return value */
      status = ret;
7000346e:	7dfb      	ldrb	r3, [r7, #23]
70003470:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USBPHYC Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBPHYC) == RCC_PERIPHCLK_USBPHYC)
70003472:	687b      	ldr	r3, [r7, #4]
70003474:	681b      	ldr	r3, [r3, #0]
70003476:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
7000347a:	2b00      	cmp	r3, #0
7000347c:	d027      	beq.n	700034ce <HAL_RCCEx_PeriphCLKConfig+0xd6e>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBPHYCCLKSOURCE(PeriphClkInit->UsbPhycClockSelection));

    switch (PeriphClkInit->UsbPhycClockSelection)
7000347e:	687b      	ldr	r3, [r7, #4]
70003480:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
70003482:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70003486:	d008      	beq.n	7000349a <HAL_RCCEx_PeriphCLKConfig+0xd3a>
70003488:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
7000348c:	d80c      	bhi.n	700034a8 <HAL_RCCEx_PeriphCLKConfig+0xd48>
7000348e:	2b00      	cmp	r3, #0
70003490:	d00d      	beq.n	700034ae <HAL_RCCEx_PeriphCLKConfig+0xd4e>
70003492:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
70003496:	d00a      	beq.n	700034ae <HAL_RCCEx_PeriphCLKConfig+0xd4e>
70003498:	e006      	b.n	700034a8 <HAL_RCCEx_PeriphCLKConfig+0xd48>
    {
      case RCC_USBPHYCCLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USBPHYC */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
7000349a:	4b32      	ldr	r3, [pc, #200]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
7000349c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000349e:	4a31      	ldr	r2, [pc, #196]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700034a0:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
700034a4:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USBPHYC clock source configuration done later after clock selection check */
        break;
700034a6:	e003      	b.n	700034b0 <HAL_RCCEx_PeriphCLKConfig+0xd50>
      case RCC_USBPHYCCLKSOURCE_HSE_DIV2: /* HSE divided by 2 is used as clock source for USBPHYC */
        /* USBPHYC clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
700034a8:	2301      	movs	r3, #1
700034aa:	75fb      	strb	r3, [r7, #23]
        break;
700034ac:	e000      	b.n	700034b0 <HAL_RCCEx_PeriphCLKConfig+0xd50>
        break;
700034ae:	bf00      	nop
    }

    if (ret == HAL_OK)
700034b0:	7dfb      	ldrb	r3, [r7, #23]
700034b2:	2b00      	cmp	r3, #0
700034b4:	d109      	bne.n	700034ca <HAL_RCCEx_PeriphCLKConfig+0xd6a>
    {
      /* Set the source of USBPHYC clock*/
      __HAL_RCC_USBPHYC_CONFIG(PeriphClkInit->UsbPhycClockSelection);
700034b6:	4b2b      	ldr	r3, [pc, #172]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700034b8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
700034ba:	f423 5240 	bic.w	r2, r3, #12288	@ 0x3000
700034be:	687b      	ldr	r3, [r7, #4]
700034c0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
700034c2:	4928      	ldr	r1, [pc, #160]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700034c4:	4313      	orrs	r3, r2
700034c6:	64cb      	str	r3, [r1, #76]	@ 0x4c
700034c8:	e001      	b.n	700034ce <HAL_RCCEx_PeriphCLKConfig+0xd6e>
    }
    else
    {
      /* set overall return value */
      status = ret;
700034ca:	7dfb      	ldrb	r3, [r7, #23]
700034cc:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------ USBOTGFS Configuration ---------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_USBOTGFS) == RCC_PERIPHCLK_USBOTGFS)
700034ce:	687b      	ldr	r3, [r7, #4]
700034d0:	681b      	ldr	r3, [r3, #0]
700034d2:	2b00      	cmp	r3, #0
700034d4:	da2c      	bge.n	70003530 <HAL_RCCEx_PeriphCLKConfig+0xdd0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_USBOTGFSCLKSOURCE(PeriphClkInit->UsbOtgFsClockSelection));

    switch (PeriphClkInit->UsbOtgFsClockSelection)
700034d6:	687b      	ldr	r3, [r7, #4]
700034d8:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
700034da:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
700034de:	d017      	beq.n	70003510 <HAL_RCCEx_PeriphCLKConfig+0xdb0>
700034e0:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
700034e4:	d811      	bhi.n	7000350a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
700034e6:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
700034ea:	d011      	beq.n	70003510 <HAL_RCCEx_PeriphCLKConfig+0xdb0>
700034ec:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
700034f0:	d80b      	bhi.n	7000350a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
700034f2:	2b00      	cmp	r3, #0
700034f4:	d00c      	beq.n	70003510 <HAL_RCCEx_PeriphCLKConfig+0xdb0>
700034f6:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
700034fa:	d106      	bne.n	7000350a <HAL_RCCEx_PeriphCLKConfig+0xdaa>
    {
      case RCC_USBOTGFSCLKSOURCE_PLL3Q: /* PLL3_Q is used as clock source for USB OTG FS */
        __HAL_RCC_PLL3CLKOUT_ENABLE(RCC_PLL_QCLK);
700034fc:	4b19      	ldr	r3, [pc, #100]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
700034fe:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003500:	4a18      	ldr	r2, [pc, #96]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
70003502:	f043 5380 	orr.w	r3, r3, #268435456	@ 0x10000000
70003506:	62d3      	str	r3, [r2, #44]	@ 0x2c
        /* USB OTG FS clock source configuration done later after clock selection check */
        break;
70003508:	e003      	b.n	70003512 <HAL_RCCEx_PeriphCLKConfig+0xdb2>
      case RCC_USBOTGFSCLKSOURCE_CLK48: /* USBPHYC CLK48 is used as clock source for USB OTG FS */
        /* USB OTG FS clock source configuration done later after clock selection check */
        break;

      default:
        ret = HAL_ERROR;
7000350a:	2301      	movs	r3, #1
7000350c:	75fb      	strb	r3, [r7, #23]
        break;
7000350e:	e000      	b.n	70003512 <HAL_RCCEx_PeriphCLKConfig+0xdb2>
        break;
70003510:	bf00      	nop
    }

    if (ret == HAL_OK)
70003512:	7dfb      	ldrb	r3, [r7, #23]
70003514:	2b00      	cmp	r3, #0
70003516:	d109      	bne.n	7000352c <HAL_RCCEx_PeriphCLKConfig+0xdcc>
    {
      /* Set the source of USBPHYC clock*/
      __HAL_RCC_USBOTGFS_CONFIG(PeriphClkInit->UsbOtgFsClockSelection);
70003518:	4b12      	ldr	r3, [pc, #72]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
7000351a:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
7000351c:	f423 4240 	bic.w	r2, r3, #49152	@ 0xc000
70003520:	687b      	ldr	r3, [r7, #4]
70003522:	6f9b      	ldr	r3, [r3, #120]	@ 0x78
70003524:	490f      	ldr	r1, [pc, #60]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
70003526:	4313      	orrs	r3, r2
70003528:	64cb      	str	r3, [r1, #76]	@ 0x4c
7000352a:	e001      	b.n	70003530 <HAL_RCCEx_PeriphCLKConfig+0xdd0>
    }
    else
    {
      /* set overall return value */
      status = ret;
7000352c:	7dfb      	ldrb	r3, [r7, #23]
7000352e:	75bb      	strb	r3, [r7, #22]
    }
  }

  /*------------------------------------ TIM configuration --------------------------------------*/
  if ((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_TIM) == RCC_PERIPHCLK_TIM)
70003530:	687b      	ldr	r3, [r7, #4]
70003532:	681b      	ldr	r3, [r3, #0]
70003534:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
70003538:	2b00      	cmp	r3, #0
7000353a:	d009      	beq.n	70003550 <HAL_RCCEx_PeriphCLKConfig+0xdf0>
  {
    /* Check the parameters */
    assert_param(IS_RCC_TIMCLKPRESCALER(PeriphClkInit->TIMPresSelection));

    /* Configure Timer Prescaler */
    __HAL_RCC_TIMCLKPRESCALER_CONFIG(PeriphClkInit->TIMPresSelection);
7000353c:	4b09      	ldr	r3, [pc, #36]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
7000353e:	691b      	ldr	r3, [r3, #16]
70003540:	f423 4200 	bic.w	r2, r3, #32768	@ 0x8000
70003544:	687b      	ldr	r3, [r7, #4]
70003546:	f8d3 3080 	ldr.w	r3, [r3, #128]	@ 0x80
7000354a:	4906      	ldr	r1, [pc, #24]	@ (70003564 <HAL_RCCEx_PeriphCLKConfig+0xe04>)
7000354c:	4313      	orrs	r3, r2
7000354e:	610b      	str	r3, [r1, #16]
  }

  if (status == HAL_OK)
70003550:	7dbb      	ldrb	r3, [r7, #22]
70003552:	2b00      	cmp	r3, #0
70003554:	d101      	bne.n	7000355a <HAL_RCCEx_PeriphCLKConfig+0xdfa>
  {
    return HAL_OK;
70003556:	2300      	movs	r3, #0
70003558:	e000      	b.n	7000355c <HAL_RCCEx_PeriphCLKConfig+0xdfc>
  }
  return HAL_ERROR;
7000355a:	2301      	movs	r3, #1
}
7000355c:	4618      	mov	r0, r3
7000355e:	3718      	adds	r7, #24
70003560:	46bd      	mov	sp, r7
70003562:	bd80      	pop	{r7, pc}
70003564:	58024400 	.word	0x58024400

70003568 <HAL_RCCEx_GetPeriphCLKFreq>:
  *            @arg RCC_PERIPHCLK_USART234578 : USART2/3/5/7/8 peripheral clock
  *            @arg RCC_PERIPHCLK_USBOTGFS    : USBOTGFS peripheral clock
  * @retval Frequency in KHz
  */
uint32_t HAL_RCCEx_GetPeriphCLKFreq(uint32_t PeriphClk)
{
70003568:	b580      	push	{r7, lr}
7000356a:	b086      	sub	sp, #24
7000356c:	af00      	add	r7, sp, #0
7000356e:	6078      	str	r0, [r7, #4]
  uint32_t frequency = 0; /* Set to 0 for returned value if no source clock */
70003570:	2300      	movs	r3, #0
70003572:	617b      	str	r3, [r7, #20]
  uint32_t clocksource;
  uint32_t ethclocksource;
  uint32_t prescaler;

  switch (PeriphClk)
70003574:	687b      	ldr	r3, [r7, #4]
70003576:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
7000357a:	f001 82db 	beq.w	70004b34 <HAL_RCCEx_GetPeriphCLKFreq+0x15cc>
7000357e:	687b      	ldr	r3, [r7, #4]
70003580:	f1b3 4f00 	cmp.w	r3, #2147483648	@ 0x80000000
70003584:	f201 8326 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003588:	687b      	ldr	r3, [r7, #4]
7000358a:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
7000358e:	f001 8298 	beq.w	70004ac2 <HAL_RCCEx_GetPeriphCLKFreq+0x155a>
70003592:	687b      	ldr	r3, [r7, #4]
70003594:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
70003598:	f201 831c 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
7000359c:	687b      	ldr	r3, [r7, #4]
7000359e:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
700035a2:	f001 822a 	beq.w	700049fa <HAL_RCCEx_GetPeriphCLKFreq+0x1492>
700035a6:	687b      	ldr	r3, [r7, #4]
700035a8:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
700035ac:	f201 8312 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700035b0:	687b      	ldr	r3, [r7, #4]
700035b2:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
700035b6:	f001 81bb 	beq.w	70004930 <HAL_RCCEx_GetPeriphCLKFreq+0x13c8>
700035ba:	687b      	ldr	r3, [r7, #4]
700035bc:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
700035c0:	f201 8308 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700035c4:	687b      	ldr	r3, [r7, #4]
700035c6:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
700035ca:	f001 8139 	beq.w	70004840 <HAL_RCCEx_GetPeriphCLKFreq+0x12d8>
700035ce:	687b      	ldr	r3, [r7, #4]
700035d0:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
700035d4:	f201 82fe 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700035d8:	687b      	ldr	r3, [r7, #4]
700035da:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
700035de:	f001 80bf 	beq.w	70004760 <HAL_RCCEx_GetPeriphCLKFreq+0x11f8>
700035e2:	687b      	ldr	r3, [r7, #4]
700035e4:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
700035e8:	f201 82f4 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700035ec:	687b      	ldr	r3, [r7, #4]
700035ee:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
700035f2:	f001 8069 	beq.w	700046c8 <HAL_RCCEx_GetPeriphCLKFreq+0x1160>
700035f6:	687b      	ldr	r3, [r7, #4]
700035f8:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
700035fc:	f201 82ea 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003600:	687b      	ldr	r3, [r7, #4]
70003602:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
70003606:	f001 8007 	beq.w	70004618 <HAL_RCCEx_GetPeriphCLKFreq+0x10b0>
7000360a:	687b      	ldr	r3, [r7, #4]
7000360c:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
70003610:	f201 82e0 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003614:	687b      	ldr	r3, [r7, #4]
70003616:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
7000361a:	f000 87a2 	beq.w	70004562 <HAL_RCCEx_GetPeriphCLKFreq+0xffa>
7000361e:	687b      	ldr	r3, [r7, #4]
70003620:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70003624:	f201 82d6 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003628:	687b      	ldr	r3, [r7, #4]
7000362a:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
7000362e:	f000 877a 	beq.w	70004526 <HAL_RCCEx_GetPeriphCLKFreq+0xfbe>
70003632:	687b      	ldr	r3, [r7, #4]
70003634:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
70003638:	f201 82cc 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
7000363c:	687b      	ldr	r3, [r7, #4]
7000363e:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
70003642:	f000 8713 	beq.w	7000446c <HAL_RCCEx_GetPeriphCLKFreq+0xf04>
70003646:	687b      	ldr	r3, [r7, #4]
70003648:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
7000364c:	f201 82c2 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003650:	687b      	ldr	r3, [r7, #4]
70003652:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
70003656:	f000 86ad 	beq.w	700043b4 <HAL_RCCEx_GetPeriphCLKFreq+0xe4c>
7000365a:	687b      	ldr	r3, [r7, #4]
7000365c:	f5b3 2f00 	cmp.w	r3, #524288	@ 0x80000
70003660:	f201 82b8 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003664:	687b      	ldr	r3, [r7, #4]
70003666:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
7000366a:	f000 8644 	beq.w	700042f6 <HAL_RCCEx_GetPeriphCLKFreq+0xd8e>
7000366e:	687b      	ldr	r3, [r7, #4]
70003670:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70003674:	f201 82ae 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003678:	687b      	ldr	r3, [r7, #4]
7000367a:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
7000367e:	f000 861c 	beq.w	700042ba <HAL_RCCEx_GetPeriphCLKFreq+0xd52>
70003682:	687b      	ldr	r3, [r7, #4]
70003684:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70003688:	f201 82a4 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
7000368c:	687b      	ldr	r3, [r7, #4]
7000368e:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
70003692:	f000 8606 	beq.w	700042a2 <HAL_RCCEx_GetPeriphCLKFreq+0xd3a>
70003696:	687b      	ldr	r3, [r7, #4]
70003698:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
7000369c:	f201 829a 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700036a0:	687b      	ldr	r3, [r7, #4]
700036a2:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
700036a6:	f000 8592 	beq.w	700041ce <HAL_RCCEx_GetPeriphCLKFreq+0xc66>
700036aa:	687b      	ldr	r3, [r7, #4]
700036ac:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
700036b0:	f201 8290 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700036b4:	687b      	ldr	r3, [r7, #4]
700036b6:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
700036ba:	f000 8519 	beq.w	700040f0 <HAL_RCCEx_GetPeriphCLKFreq+0xb88>
700036be:	687b      	ldr	r3, [r7, #4]
700036c0:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
700036c4:	f201 8286 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700036c8:	687b      	ldr	r3, [r7, #4]
700036ca:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
700036ce:	f000 84a3 	beq.w	70004018 <HAL_RCCEx_GetPeriphCLKFreq+0xab0>
700036d2:	687b      	ldr	r3, [r7, #4]
700036d4:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
700036d8:	f201 827c 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700036dc:	687b      	ldr	r3, [r7, #4]
700036de:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
700036e2:	f000 842d 	beq.w	70003f40 <HAL_RCCEx_GetPeriphCLKFreq+0x9d8>
700036e6:	687b      	ldr	r3, [r7, #4]
700036e8:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
700036ec:	f201 8272 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
700036f0:	687b      	ldr	r3, [r7, #4]
700036f2:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
700036f6:	f000 83c5 	beq.w	70003e84 <HAL_RCCEx_GetPeriphCLKFreq+0x91c>
700036fa:	687b      	ldr	r3, [r7, #4]
700036fc:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
70003700:	f201 8268 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003704:	687b      	ldr	r3, [r7, #4]
70003706:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
7000370a:	f000 8365 	beq.w	70003dd8 <HAL_RCCEx_GetPeriphCLKFreq+0x870>
7000370e:	687b      	ldr	r3, [r7, #4]
70003710:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70003714:	f201 825e 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003718:	687b      	ldr	r3, [r7, #4]
7000371a:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
7000371e:	f000 831d 	beq.w	70003d5c <HAL_RCCEx_GetPeriphCLKFreq+0x7f4>
70003722:	687b      	ldr	r3, [r7, #4]
70003724:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70003728:	f201 8254 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
7000372c:	687b      	ldr	r3, [r7, #4]
7000372e:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
70003732:	f000 82ed 	beq.w	70003d10 <HAL_RCCEx_GetPeriphCLKFreq+0x7a8>
70003736:	687b      	ldr	r3, [r7, #4]
70003738:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
7000373c:	f201 824a 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003740:	687b      	ldr	r3, [r7, #4]
70003742:	2b80      	cmp	r3, #128	@ 0x80
70003744:	f000 8291 	beq.w	70003c6a <HAL_RCCEx_GetPeriphCLKFreq+0x702>
70003748:	687b      	ldr	r3, [r7, #4]
7000374a:	2b80      	cmp	r3, #128	@ 0x80
7000374c:	f201 8242 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003750:	687b      	ldr	r3, [r7, #4]
70003752:	2b20      	cmp	r3, #32
70003754:	d84c      	bhi.n	700037f0 <HAL_RCCEx_GetPeriphCLKFreq+0x288>
70003756:	687b      	ldr	r3, [r7, #4]
70003758:	2b00      	cmp	r3, #0
7000375a:	f001 823b 	beq.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
7000375e:	687b      	ldr	r3, [r7, #4]
70003760:	3b01      	subs	r3, #1
70003762:	2b1f      	cmp	r3, #31
70003764:	f201 8236 	bhi.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
70003768:	a201      	add	r2, pc, #4	@ (adr r2, 70003770 <HAL_RCCEx_GetPeriphCLKFreq+0x208>)
7000376a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
7000376e:	bf00      	nop
70003770:	700037fd 	.word	0x700037fd
70003774:	700038cb 	.word	0x700038cb
70003778:	70004bd5 	.word	0x70004bd5
7000377c:	7000395b 	.word	0x7000395b
70003780:	70004bd5 	.word	0x70004bd5
70003784:	70004bd5 	.word	0x70004bd5
70003788:	70004bd5 	.word	0x70004bd5
7000378c:	700039f3 	.word	0x700039f3
70003790:	70004bd5 	.word	0x70004bd5
70003794:	70004bd5 	.word	0x70004bd5
70003798:	70004bd5 	.word	0x70004bd5
7000379c:	70004bd5 	.word	0x70004bd5
700037a0:	70004bd5 	.word	0x70004bd5
700037a4:	70004bd5 	.word	0x70004bd5
700037a8:	70004bd5 	.word	0x70004bd5
700037ac:	70003a95 	.word	0x70003a95
700037b0:	70004bd5 	.word	0x70004bd5
700037b4:	70004bd5 	.word	0x70004bd5
700037b8:	70004bd5 	.word	0x70004bd5
700037bc:	70004bd5 	.word	0x70004bd5
700037c0:	70004bd5 	.word	0x70004bd5
700037c4:	70004bd5 	.word	0x70004bd5
700037c8:	70004bd5 	.word	0x70004bd5
700037cc:	70004bd5 	.word	0x70004bd5
700037d0:	70004bd5 	.word	0x70004bd5
700037d4:	70004bd5 	.word	0x70004bd5
700037d8:	70004bd5 	.word	0x70004bd5
700037dc:	70004bd5 	.word	0x70004bd5
700037e0:	70004bd5 	.word	0x70004bd5
700037e4:	70004bd5 	.word	0x70004bd5
700037e8:	70004bd5 	.word	0x70004bd5
700037ec:	70003b01 	.word	0x70003b01
700037f0:	687b      	ldr	r3, [r7, #4]
700037f2:	2b40      	cmp	r3, #64	@ 0x40
700037f4:	f000 81fb 	beq.w	70003bee <HAL_RCCEx_GetPeriphCLKFreq+0x686>
      }
      break;

    default:
      /* Nothing to do, frequency is by default set to 0 */
      break;
700037f8:	f001 b9ec 	b.w	70004bd4 <HAL_RCCEx_GetPeriphCLKFreq+0x166c>
      clocksource = __HAL_RCC_GET_FMC_SOURCE();
700037fc:	4ba1      	ldr	r3, [pc, #644]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
700037fe:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
70003802:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
70003806:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
7000380a:	d004      	beq.n	70003816 <HAL_RCCEx_GetPeriphCLKFreq+0x2ae>
7000380c:	4b9d      	ldr	r3, [pc, #628]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
7000380e:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70003810:	f003 0303 	and.w	r3, r3, #3
70003814:	e001      	b.n	7000381a <HAL_RCCEx_GetPeriphCLKFreq+0x2b2>
70003816:	f44f 43a0 	mov.w	r3, #20480	@ 0x5000
7000381a:	613b      	str	r3, [r7, #16]
      switch (clocksource)
7000381c:	693b      	ldr	r3, [r7, #16]
7000381e:	2b03      	cmp	r3, #3
70003820:	d80e      	bhi.n	70003840 <HAL_RCCEx_GetPeriphCLKFreq+0x2d8>
70003822:	693b      	ldr	r3, [r7, #16]
70003824:	2b03      	cmp	r3, #3
70003826:	d844      	bhi.n	700038b2 <HAL_RCCEx_GetPeriphCLKFreq+0x34a>
70003828:	a201      	add	r2, pc, #4	@ (adr r2, 70003830 <HAL_RCCEx_GetPeriphCLKFreq+0x2c8>)
7000382a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
7000382e:	bf00      	nop
70003830:	7000384b 	.word	0x7000384b
70003834:	70003853 	.word	0x70003853
70003838:	70003867 	.word	0x70003867
7000383c:	7000387b 	.word	0x7000387b
70003840:	693b      	ldr	r3, [r7, #16]
70003842:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
70003846:	d02e      	beq.n	700038a6 <HAL_RCCEx_GetPeriphCLKFreq+0x33e>
          break;
70003848:	e033      	b.n	700038b2 <HAL_RCCEx_GetPeriphCLKFreq+0x34a>
          frequency = HAL_RCC_GetHCLKFreq();
7000384a:	f7fe fc9d 	bl	70002188 <HAL_RCC_GetHCLKFreq>
7000384e:	6178      	str	r0, [r7, #20]
          break;
70003850:	e039      	b.n	700038c6 <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70003852:	4b8c      	ldr	r3, [pc, #560]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003854:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003856:	f003 0340 	and.w	r3, r3, #64	@ 0x40
7000385a:	2b00      	cmp	r3, #0
7000385c:	d02c      	beq.n	700038b8 <HAL_RCCEx_GetPeriphCLKFreq+0x350>
            frequency = HAL_RCC_GetPLL1QFreq();
7000385e:	f7fe fd0f 	bl	70002280 <HAL_RCC_GetPLL1QFreq>
70003862:	6178      	str	r0, [r7, #20]
          break;
70003864:	e028      	b.n	700038b8 <HAL_RCCEx_GetPeriphCLKFreq+0x350>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
70003866:	4b87      	ldr	r3, [pc, #540]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003868:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000386a:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
7000386e:	2b00      	cmp	r3, #0
70003870:	d025      	beq.n	700038be <HAL_RCCEx_GetPeriphCLKFreq+0x356>
            frequency = HAL_RCC_GetPLL2RFreq();
70003872:	f7fe fd47 	bl	70002304 <HAL_RCC_GetPLL2RFreq>
70003876:	6178      	str	r0, [r7, #20]
          break;
70003878:	e021      	b.n	700038be <HAL_RCCEx_GetPeriphCLKFreq+0x356>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
7000387a:	4b82      	ldr	r3, [pc, #520]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
7000387c:	681b      	ldr	r3, [r3, #0]
7000387e:	f003 0304 	and.w	r3, r3, #4
70003882:	2b00      	cmp	r3, #0
70003884:	d01e      	beq.n	700038c4 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70003886:	4b7f      	ldr	r3, [pc, #508]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003888:	681b      	ldr	r3, [r3, #0]
7000388a:	f003 0320 	and.w	r3, r3, #32
7000388e:	2b00      	cmp	r3, #0
70003890:	d018      	beq.n	700038c4 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70003892:	4b7c      	ldr	r3, [pc, #496]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003894:	681b      	ldr	r3, [r3, #0]
70003896:	08db      	lsrs	r3, r3, #3
70003898:	f003 0303 	and.w	r3, r3, #3
7000389c:	4a7a      	ldr	r2, [pc, #488]	@ (70003a88 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
7000389e:	fa22 f303 	lsr.w	r3, r2, r3
700038a2:	617b      	str	r3, [r7, #20]
          break;
700038a4:	e00e      	b.n	700038c4 <HAL_RCCEx_GetPeriphCLKFreq+0x35c>
          frequency = (HAL_RCC_GetHCLKFreq() / 4U);
700038a6:	f7fe fc6f 	bl	70002188 <HAL_RCC_GetHCLKFreq>
700038aa:	4603      	mov	r3, r0
700038ac:	089b      	lsrs	r3, r3, #2
700038ae:	617b      	str	r3, [r7, #20]
          break;
700038b0:	e009      	b.n	700038c6 <HAL_RCCEx_GetPeriphCLKFreq+0x35e>
          break;
700038b2:	bf00      	nop
700038b4:	f001 b993 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700038b8:	bf00      	nop
700038ba:	f001 b990 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700038be:	bf00      	nop
700038c0:	f001 b98d 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700038c4:	bf00      	nop
      break;
700038c6:	f001 b98a 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_XSPI1_SOURCE();
700038ca:	4b6e      	ldr	r3, [pc, #440]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
700038cc:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
700038d0:	f003 0370 	and.w	r3, r3, #112	@ 0x70
700038d4:	2b40      	cmp	r3, #64	@ 0x40
700038d6:	d004      	beq.n	700038e2 <HAL_RCCEx_GetPeriphCLKFreq+0x37a>
700038d8:	4b6a      	ldr	r3, [pc, #424]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
700038da:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
700038dc:	f003 0330 	and.w	r3, r3, #48	@ 0x30
700038e0:	e000      	b.n	700038e4 <HAL_RCCEx_GetPeriphCLKFreq+0x37c>
700038e2:	2340      	movs	r3, #64	@ 0x40
700038e4:	613b      	str	r3, [r7, #16]
      switch (clocksource)
700038e6:	693b      	ldr	r3, [r7, #16]
700038e8:	2b40      	cmp	r3, #64	@ 0x40
700038ea:	d027      	beq.n	7000393c <HAL_RCCEx_GetPeriphCLKFreq+0x3d4>
700038ec:	693b      	ldr	r3, [r7, #16]
700038ee:	2b40      	cmp	r3, #64	@ 0x40
700038f0:	d82a      	bhi.n	70003948 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
700038f2:	693b      	ldr	r3, [r7, #16]
700038f4:	2b20      	cmp	r3, #32
700038f6:	d017      	beq.n	70003928 <HAL_RCCEx_GetPeriphCLKFreq+0x3c0>
700038f8:	693b      	ldr	r3, [r7, #16]
700038fa:	2b20      	cmp	r3, #32
700038fc:	d824      	bhi.n	70003948 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
700038fe:	693b      	ldr	r3, [r7, #16]
70003900:	2b00      	cmp	r3, #0
70003902:	d003      	beq.n	7000390c <HAL_RCCEx_GetPeriphCLKFreq+0x3a4>
70003904:	693b      	ldr	r3, [r7, #16]
70003906:	2b10      	cmp	r3, #16
70003908:	d004      	beq.n	70003914 <HAL_RCCEx_GetPeriphCLKFreq+0x3ac>
          break;
7000390a:	e01d      	b.n	70003948 <HAL_RCCEx_GetPeriphCLKFreq+0x3e0>
          frequency = HAL_RCC_GetHCLKFreq();
7000390c:	f7fe fc3c 	bl	70002188 <HAL_RCC_GetHCLKFreq>
70003910:	6178      	str	r0, [r7, #20]
          break;
70003912:	e020      	b.n	70003956 <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
70003914:	4b5b      	ldr	r3, [pc, #364]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003916:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003918:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
7000391c:	2b00      	cmp	r3, #0
7000391e:	d016      	beq.n	7000394e <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
            frequency = HAL_RCC_GetPLL2SFreq();
70003920:	f7fe fd06 	bl	70002330 <HAL_RCC_GetPLL2SFreq>
70003924:	6178      	str	r0, [r7, #20]
          break;
70003926:	e012      	b.n	7000394e <HAL_RCCEx_GetPeriphCLKFreq+0x3e6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_TCLK) != 0U)
70003928:	4b56      	ldr	r3, [pc, #344]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
7000392a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000392c:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
70003930:	2b00      	cmp	r3, #0
70003932:	d00f      	beq.n	70003954 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
            frequency = HAL_RCC_GetPLL2TFreq();
70003934:	f7fe fd12 	bl	7000235c <HAL_RCC_GetPLL2TFreq>
70003938:	6178      	str	r0, [r7, #20]
          break;
7000393a:	e00b      	b.n	70003954 <HAL_RCCEx_GetPeriphCLKFreq+0x3ec>
          frequency = (HAL_RCC_GetHCLKFreq() / 4U);
7000393c:	f7fe fc24 	bl	70002188 <HAL_RCC_GetHCLKFreq>
70003940:	4603      	mov	r3, r0
70003942:	089b      	lsrs	r3, r3, #2
70003944:	617b      	str	r3, [r7, #20]
          break;
70003946:	e006      	b.n	70003956 <HAL_RCCEx_GetPeriphCLKFreq+0x3ee>
          break;
70003948:	bf00      	nop
7000394a:	f001 b948 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000394e:	bf00      	nop
70003950:	f001 b945 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003954:	bf00      	nop
      break;
70003956:	f001 b942 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_XSPI2_SOURCE();
7000395a:	4b4a      	ldr	r3, [pc, #296]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
7000395c:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
70003960:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
70003964:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70003968:	d004      	beq.n	70003974 <HAL_RCCEx_GetPeriphCLKFreq+0x40c>
7000396a:	4b46      	ldr	r3, [pc, #280]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
7000396c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
7000396e:	f003 03c0 	and.w	r3, r3, #192	@ 0xc0
70003972:	e001      	b.n	70003978 <HAL_RCCEx_GetPeriphCLKFreq+0x410>
70003974:	f44f 6380 	mov.w	r3, #1024	@ 0x400
70003978:	613b      	str	r3, [r7, #16]
      switch (clocksource)
7000397a:	693b      	ldr	r3, [r7, #16]
7000397c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70003980:	d028      	beq.n	700039d4 <HAL_RCCEx_GetPeriphCLKFreq+0x46c>
70003982:	693b      	ldr	r3, [r7, #16]
70003984:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70003988:	d82a      	bhi.n	700039e0 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
7000398a:	693b      	ldr	r3, [r7, #16]
7000398c:	2b80      	cmp	r3, #128	@ 0x80
7000398e:	d017      	beq.n	700039c0 <HAL_RCCEx_GetPeriphCLKFreq+0x458>
70003990:	693b      	ldr	r3, [r7, #16]
70003992:	2b80      	cmp	r3, #128	@ 0x80
70003994:	d824      	bhi.n	700039e0 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
70003996:	693b      	ldr	r3, [r7, #16]
70003998:	2b00      	cmp	r3, #0
7000399a:	d003      	beq.n	700039a4 <HAL_RCCEx_GetPeriphCLKFreq+0x43c>
7000399c:	693b      	ldr	r3, [r7, #16]
7000399e:	2b40      	cmp	r3, #64	@ 0x40
700039a0:	d004      	beq.n	700039ac <HAL_RCCEx_GetPeriphCLKFreq+0x444>
          break;
700039a2:	e01d      	b.n	700039e0 <HAL_RCCEx_GetPeriphCLKFreq+0x478>
          frequency = HAL_RCC_GetHCLKFreq();
700039a4:	f7fe fbf0 	bl	70002188 <HAL_RCC_GetHCLKFreq>
700039a8:	6178      	str	r0, [r7, #20]
          break;
700039aa:	e020      	b.n	700039ee <HAL_RCCEx_GetPeriphCLKFreq+0x486>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
700039ac:	4b35      	ldr	r3, [pc, #212]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
700039ae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700039b0:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
700039b4:	2b00      	cmp	r3, #0
700039b6:	d016      	beq.n	700039e6 <HAL_RCCEx_GetPeriphCLKFreq+0x47e>
            frequency = HAL_RCC_GetPLL2SFreq();
700039b8:	f7fe fcba 	bl	70002330 <HAL_RCC_GetPLL2SFreq>
700039bc:	6178      	str	r0, [r7, #20]
          break;
700039be:	e012      	b.n	700039e6 <HAL_RCCEx_GetPeriphCLKFreq+0x47e>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_TCLK) != 0U)
700039c0:	4b30      	ldr	r3, [pc, #192]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
700039c2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700039c4:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
700039c8:	2b00      	cmp	r3, #0
700039ca:	d00f      	beq.n	700039ec <HAL_RCCEx_GetPeriphCLKFreq+0x484>
            frequency = HAL_RCC_GetPLL2TFreq();
700039cc:	f7fe fcc6 	bl	7000235c <HAL_RCC_GetPLL2TFreq>
700039d0:	6178      	str	r0, [r7, #20]
          break;
700039d2:	e00b      	b.n	700039ec <HAL_RCCEx_GetPeriphCLKFreq+0x484>
          frequency = (HAL_RCC_GetHCLKFreq() / 4U);
700039d4:	f7fe fbd8 	bl	70002188 <HAL_RCC_GetHCLKFreq>
700039d8:	4603      	mov	r3, r0
700039da:	089b      	lsrs	r3, r3, #2
700039dc:	617b      	str	r3, [r7, #20]
          break;
700039de:	e006      	b.n	700039ee <HAL_RCCEx_GetPeriphCLKFreq+0x486>
          break;
700039e0:	bf00      	nop
700039e2:	f001 b8fc 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700039e6:	bf00      	nop
700039e8:	f001 b8f9 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700039ec:	bf00      	nop
      break;
700039ee:	f001 b8f6 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_CLKP_SOURCE();
700039f2:	4b24      	ldr	r3, [pc, #144]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
700039f4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
700039f6:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
700039fa:	613b      	str	r3, [r7, #16]
      switch (clocksource)
700039fc:	693b      	ldr	r3, [r7, #16]
700039fe:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
70003a02:	d02a      	beq.n	70003a5a <HAL_RCCEx_GetPeriphCLKFreq+0x4f2>
70003a04:	693b      	ldr	r3, [r7, #16]
70003a06:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
70003a0a:	d82f      	bhi.n	70003a6c <HAL_RCCEx_GetPeriphCLKFreq+0x504>
70003a0c:	693b      	ldr	r3, [r7, #16]
70003a0e:	2b00      	cmp	r3, #0
70003a10:	d004      	beq.n	70003a1c <HAL_RCCEx_GetPeriphCLKFreq+0x4b4>
70003a12:	693b      	ldr	r3, [r7, #16]
70003a14:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
70003a18:	d016      	beq.n	70003a48 <HAL_RCCEx_GetPeriphCLKFreq+0x4e0>
          break;
70003a1a:	e027      	b.n	70003a6c <HAL_RCCEx_GetPeriphCLKFreq+0x504>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
70003a1c:	4b19      	ldr	r3, [pc, #100]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003a1e:	681b      	ldr	r3, [r3, #0]
70003a20:	f003 0304 	and.w	r3, r3, #4
70003a24:	2b00      	cmp	r3, #0
70003a26:	d024      	beq.n	70003a72 <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70003a28:	4b16      	ldr	r3, [pc, #88]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003a2a:	681b      	ldr	r3, [r3, #0]
70003a2c:	f003 0320 	and.w	r3, r3, #32
70003a30:	2b00      	cmp	r3, #0
70003a32:	d01e      	beq.n	70003a72 <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70003a34:	4b13      	ldr	r3, [pc, #76]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003a36:	681b      	ldr	r3, [r3, #0]
70003a38:	08db      	lsrs	r3, r3, #3
70003a3a:	f003 0303 	and.w	r3, r3, #3
70003a3e:	4a12      	ldr	r2, [pc, #72]	@ (70003a88 <HAL_RCCEx_GetPeriphCLKFreq+0x520>)
70003a40:	fa22 f303 	lsr.w	r3, r2, r3
70003a44:	617b      	str	r3, [r7, #20]
          break;
70003a46:	e014      	b.n	70003a72 <HAL_RCCEx_GetPeriphCLKFreq+0x50a>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70003a48:	4b0e      	ldr	r3, [pc, #56]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003a4a:	681b      	ldr	r3, [r3, #0]
70003a4c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70003a50:	2b00      	cmp	r3, #0
70003a52:	d011      	beq.n	70003a78 <HAL_RCCEx_GetPeriphCLKFreq+0x510>
            frequency = CSI_VALUE;
70003a54:	4b0d      	ldr	r3, [pc, #52]	@ (70003a8c <HAL_RCCEx_GetPeriphCLKFreq+0x524>)
70003a56:	617b      	str	r3, [r7, #20]
          break;
70003a58:	e00e      	b.n	70003a78 <HAL_RCCEx_GetPeriphCLKFreq+0x510>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70003a5a:	4b0a      	ldr	r3, [pc, #40]	@ (70003a84 <HAL_RCCEx_GetPeriphCLKFreq+0x51c>)
70003a5c:	681b      	ldr	r3, [r3, #0]
70003a5e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70003a62:	2b00      	cmp	r3, #0
70003a64:	d00b      	beq.n	70003a7e <HAL_RCCEx_GetPeriphCLKFreq+0x516>
            frequency = HSE_VALUE;
70003a66:	4b0a      	ldr	r3, [pc, #40]	@ (70003a90 <HAL_RCCEx_GetPeriphCLKFreq+0x528>)
70003a68:	617b      	str	r3, [r7, #20]
          break;
70003a6a:	e008      	b.n	70003a7e <HAL_RCCEx_GetPeriphCLKFreq+0x516>
          break;
70003a6c:	bf00      	nop
70003a6e:	f001 b8b6 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003a72:	bf00      	nop
70003a74:	f001 b8b3 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003a78:	bf00      	nop
70003a7a:	f001 b8b0 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003a7e:	bf00      	nop
      break;
70003a80:	f001 b8ad 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
70003a84:	58024400 	.word	0x58024400
70003a88:	03d09000 	.word	0x03d09000
70003a8c:	003d0900 	.word	0x003d0900
70003a90:	016e3600 	.word	0x016e3600
      clocksource = __HAL_RCC_GET_ADC_SOURCE();
70003a94:	4b9a      	ldr	r3, [pc, #616]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003a96:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70003a98:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
70003a9c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003a9e:	693b      	ldr	r3, [r7, #16]
70003aa0:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
70003aa4:	d01f      	beq.n	70003ae6 <HAL_RCCEx_GetPeriphCLKFreq+0x57e>
70003aa6:	693b      	ldr	r3, [r7, #16]
70003aa8:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
70003aac:	d81f      	bhi.n	70003aee <HAL_RCCEx_GetPeriphCLKFreq+0x586>
70003aae:	693b      	ldr	r3, [r7, #16]
70003ab0:	2b00      	cmp	r3, #0
70003ab2:	d004      	beq.n	70003abe <HAL_RCCEx_GetPeriphCLKFreq+0x556>
70003ab4:	693b      	ldr	r3, [r7, #16]
70003ab6:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
70003aba:	d00a      	beq.n	70003ad2 <HAL_RCCEx_GetPeriphCLKFreq+0x56a>
          break;
70003abc:	e017      	b.n	70003aee <HAL_RCCEx_GetPeriphCLKFreq+0x586>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70003abe:	4b90      	ldr	r3, [pc, #576]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003ac0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003ac2:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70003ac6:	2b00      	cmp	r3, #0
70003ac8:	d014      	beq.n	70003af4 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>
            frequency = HAL_RCC_GetPLL2PFreq();
70003aca:	f7fe fbef 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70003ace:	6178      	str	r0, [r7, #20]
          break;
70003ad0:	e010      	b.n	70003af4 <HAL_RCCEx_GetPeriphCLKFreq+0x58c>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
70003ad2:	4b8b      	ldr	r3, [pc, #556]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003ad4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003ad6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
70003ada:	2b00      	cmp	r3, #0
70003adc:	d00d      	beq.n	70003afa <HAL_RCCEx_GetPeriphCLKFreq+0x592>
            frequency = HAL_RCC_GetPLL3RFreq();
70003ade:	f7fe fc81 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
70003ae2:	6178      	str	r0, [r7, #20]
          break;
70003ae4:	e009      	b.n	70003afa <HAL_RCCEx_GetPeriphCLKFreq+0x592>
          frequency = RCC_GetCLKPFreq();
70003ae6:	f001 f893 	bl	70004c10 <RCC_GetCLKPFreq>
70003aea:	6178      	str	r0, [r7, #20]
          break;
70003aec:	e006      	b.n	70003afc <HAL_RCCEx_GetPeriphCLKFreq+0x594>
          break;
70003aee:	bf00      	nop
70003af0:	f001 b875 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003af4:	bf00      	nop
70003af6:	f001 b872 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003afa:	bf00      	nop
      break;
70003afc:	f001 b86f 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_ADF1_SOURCE();
70003b00:	4b7f      	ldr	r3, [pc, #508]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003b02:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70003b04:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
70003b08:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003b0a:	693b      	ldr	r3, [r7, #16]
70003b0c:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
70003b10:	d048      	beq.n	70003ba4 <HAL_RCCEx_GetPeriphCLKFreq+0x63c>
70003b12:	693b      	ldr	r3, [r7, #16]
70003b14:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
70003b18:	d85a      	bhi.n	70003bd0 <HAL_RCCEx_GetPeriphCLKFreq+0x668>
70003b1a:	693b      	ldr	r3, [r7, #16]
70003b1c:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70003b20:	d037      	beq.n	70003b92 <HAL_RCCEx_GetPeriphCLKFreq+0x62a>
70003b22:	693b      	ldr	r3, [r7, #16]
70003b24:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70003b28:	d852      	bhi.n	70003bd0 <HAL_RCCEx_GetPeriphCLKFreq+0x668>
70003b2a:	693b      	ldr	r3, [r7, #16]
70003b2c:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
70003b30:	d02b      	beq.n	70003b8a <HAL_RCCEx_GetPeriphCLKFreq+0x622>
70003b32:	693b      	ldr	r3, [r7, #16]
70003b34:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
70003b38:	d84a      	bhi.n	70003bd0 <HAL_RCCEx_GetPeriphCLKFreq+0x668>
70003b3a:	693b      	ldr	r3, [r7, #16]
70003b3c:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
70003b40:	d019      	beq.n	70003b76 <HAL_RCCEx_GetPeriphCLKFreq+0x60e>
70003b42:	693b      	ldr	r3, [r7, #16]
70003b44:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
70003b48:	d842      	bhi.n	70003bd0 <HAL_RCCEx_GetPeriphCLKFreq+0x668>
70003b4a:	693b      	ldr	r3, [r7, #16]
70003b4c:	2b00      	cmp	r3, #0
70003b4e:	d004      	beq.n	70003b5a <HAL_RCCEx_GetPeriphCLKFreq+0x5f2>
70003b50:	693b      	ldr	r3, [r7, #16]
70003b52:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
70003b56:	d004      	beq.n	70003b62 <HAL_RCCEx_GetPeriphCLKFreq+0x5fa>
          break;
70003b58:	e03a      	b.n	70003bd0 <HAL_RCCEx_GetPeriphCLKFreq+0x668>
          frequency = HAL_RCC_GetHCLKFreq();
70003b5a:	f7fe fb15 	bl	70002188 <HAL_RCC_GetHCLKFreq>
70003b5e:	6178      	str	r0, [r7, #20]
          break;
70003b60:	e043      	b.n	70003bea <HAL_RCCEx_GetPeriphCLKFreq+0x682>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70003b62:	4b67      	ldr	r3, [pc, #412]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003b64:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003b66:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70003b6a:	2b00      	cmp	r3, #0
70003b6c:	d033      	beq.n	70003bd6 <HAL_RCCEx_GetPeriphCLKFreq+0x66e>
            frequency = HAL_RCC_GetPLL2PFreq();
70003b6e:	f7fe fb9d 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70003b72:	6178      	str	r0, [r7, #20]
          break;
70003b74:	e02f      	b.n	70003bd6 <HAL_RCCEx_GetPeriphCLKFreq+0x66e>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70003b76:	4b62      	ldr	r3, [pc, #392]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003b78:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003b7a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
70003b7e:	2b00      	cmp	r3, #0
70003b80:	d02c      	beq.n	70003bdc <HAL_RCCEx_GetPeriphCLKFreq+0x674>
            frequency = HAL_RCC_GetPLL3PFreq();
70003b82:	f7fe fc03 	bl	7000238c <HAL_RCC_GetPLL3PFreq>
70003b86:	6178      	str	r0, [r7, #20]
          break;
70003b88:	e028      	b.n	70003bdc <HAL_RCCEx_GetPeriphCLKFreq+0x674>
          frequency = EXTERNAL_CLOCK_VALUE;
70003b8a:	f64b 3380 	movw	r3, #48000	@ 0xbb80
70003b8e:	617b      	str	r3, [r7, #20]
          break;
70003b90:	e02b      	b.n	70003bea <HAL_RCCEx_GetPeriphCLKFreq+0x682>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70003b92:	4b5b      	ldr	r3, [pc, #364]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003b94:	681b      	ldr	r3, [r3, #0]
70003b96:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70003b9a:	2b00      	cmp	r3, #0
70003b9c:	d021      	beq.n	70003be2 <HAL_RCCEx_GetPeriphCLKFreq+0x67a>
            frequency = CSI_VALUE;
70003b9e:	4b59      	ldr	r3, [pc, #356]	@ (70003d04 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>)
70003ba0:	617b      	str	r3, [r7, #20]
          break;
70003ba2:	e01e      	b.n	70003be2 <HAL_RCCEx_GetPeriphCLKFreq+0x67a>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
70003ba4:	4b56      	ldr	r3, [pc, #344]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003ba6:	681b      	ldr	r3, [r3, #0]
70003ba8:	f003 0304 	and.w	r3, r3, #4
70003bac:	2b00      	cmp	r3, #0
70003bae:	d01b      	beq.n	70003be8 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70003bb0:	4b53      	ldr	r3, [pc, #332]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003bb2:	681b      	ldr	r3, [r3, #0]
70003bb4:	f003 0320 	and.w	r3, r3, #32
70003bb8:	2b00      	cmp	r3, #0
70003bba:	d015      	beq.n	70003be8 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70003bbc:	4b50      	ldr	r3, [pc, #320]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003bbe:	681b      	ldr	r3, [r3, #0]
70003bc0:	08db      	lsrs	r3, r3, #3
70003bc2:	f003 0303 	and.w	r3, r3, #3
70003bc6:	4a50      	ldr	r2, [pc, #320]	@ (70003d08 <HAL_RCCEx_GetPeriphCLKFreq+0x7a0>)
70003bc8:	fa22 f303 	lsr.w	r3, r2, r3
70003bcc:	617b      	str	r3, [r7, #20]
          break;
70003bce:	e00b      	b.n	70003be8 <HAL_RCCEx_GetPeriphCLKFreq+0x680>
          break;
70003bd0:	bf00      	nop
70003bd2:	f001 b804 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003bd6:	bf00      	nop
70003bd8:	f001 b801 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003bdc:	bf00      	nop
70003bde:	f000 bffe 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003be2:	bf00      	nop
70003be4:	f000 bffb 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003be8:	bf00      	nop
      break;
70003bea:	f000 bff8 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_CEC_SOURCE();
70003bee:	4b44      	ldr	r3, [pc, #272]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003bf0:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70003bf2:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
70003bf6:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003bf8:	693b      	ldr	r3, [r7, #16]
70003bfa:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
70003bfe:	d01f      	beq.n	70003c40 <HAL_RCCEx_GetPeriphCLKFreq+0x6d8>
70003c00:	693b      	ldr	r3, [r7, #16]
70003c02:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
70003c06:	d824      	bhi.n	70003c52 <HAL_RCCEx_GetPeriphCLKFreq+0x6ea>
70003c08:	693b      	ldr	r3, [r7, #16]
70003c0a:	2b00      	cmp	r3, #0
70003c0c:	d004      	beq.n	70003c18 <HAL_RCCEx_GetPeriphCLKFreq+0x6b0>
70003c0e:	693b      	ldr	r3, [r7, #16]
70003c10:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
70003c14:	d00a      	beq.n	70003c2c <HAL_RCCEx_GetPeriphCLKFreq+0x6c4>
          break;
70003c16:	e01c      	b.n	70003c52 <HAL_RCCEx_GetPeriphCLKFreq+0x6ea>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
70003c18:	4b39      	ldr	r3, [pc, #228]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003c1a:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70003c1c:	f003 0302 	and.w	r3, r3, #2
70003c20:	2b00      	cmp	r3, #0
70003c22:	d019      	beq.n	70003c58 <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
            frequency = LSE_VALUE;
70003c24:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
70003c28:	617b      	str	r3, [r7, #20]
          break;
70003c2a:	e015      	b.n	70003c58 <HAL_RCCEx_GetPeriphCLKFreq+0x6f0>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
70003c2c:	4b34      	ldr	r3, [pc, #208]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003c2e:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
70003c30:	f003 0302 	and.w	r3, r3, #2
70003c34:	2b00      	cmp	r3, #0
70003c36:	d012      	beq.n	70003c5e <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
            frequency = LSI_VALUE;
70003c38:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
70003c3c:	617b      	str	r3, [r7, #20]
          break;
70003c3e:	e00e      	b.n	70003c5e <HAL_RCCEx_GetPeriphCLKFreq+0x6f6>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70003c40:	4b2f      	ldr	r3, [pc, #188]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003c42:	681b      	ldr	r3, [r3, #0]
70003c44:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70003c48:	2b00      	cmp	r3, #0
70003c4a:	d00b      	beq.n	70003c64 <HAL_RCCEx_GetPeriphCLKFreq+0x6fc>
            frequency = CSI_VALUE;
70003c4c:	4b2d      	ldr	r3, [pc, #180]	@ (70003d04 <HAL_RCCEx_GetPeriphCLKFreq+0x79c>)
70003c4e:	617b      	str	r3, [r7, #20]
          break;
70003c50:	e008      	b.n	70003c64 <HAL_RCCEx_GetPeriphCLKFreq+0x6fc>
          break;
70003c52:	bf00      	nop
70003c54:	f000 bfc3 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003c58:	bf00      	nop
70003c5a:	f000 bfc0 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003c5e:	bf00      	nop
70003c60:	f000 bfbd 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003c64:	bf00      	nop
      break;
70003c66:	f000 bfba 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_ETH1REF_SOURCE();
70003c6a:	4b25      	ldr	r3, [pc, #148]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003c6c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70003c6e:	f403 3340 	and.w	r3, r3, #196608	@ 0x30000
70003c72:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003c74:	693b      	ldr	r3, [r7, #16]
70003c76:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70003c7a:	d014      	beq.n	70003ca6 <HAL_RCCEx_GetPeriphCLKFreq+0x73e>
70003c7c:	693b      	ldr	r3, [r7, #16]
70003c7e:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70003c82:	d834      	bhi.n	70003cee <HAL_RCCEx_GetPeriphCLKFreq+0x786>
70003c84:	693b      	ldr	r3, [r7, #16]
70003c86:	2b00      	cmp	r3, #0
70003c88:	d034      	beq.n	70003cf4 <HAL_RCCEx_GetPeriphCLKFreq+0x78c>
70003c8a:	693b      	ldr	r3, [r7, #16]
70003c8c:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
70003c90:	d000      	beq.n	70003c94 <HAL_RCCEx_GetPeriphCLKFreq+0x72c>
          break;
70003c92:	e02c      	b.n	70003cee <HAL_RCCEx_GetPeriphCLKFreq+0x786>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70003c94:	4b1a      	ldr	r3, [pc, #104]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003c96:	681b      	ldr	r3, [r3, #0]
70003c98:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70003c9c:	2b00      	cmp	r3, #0
70003c9e:	d02c      	beq.n	70003cfa <HAL_RCCEx_GetPeriphCLKFreq+0x792>
            frequency = HSE_VALUE;
70003ca0:	4b1a      	ldr	r3, [pc, #104]	@ (70003d0c <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>)
70003ca2:	617b      	str	r3, [r7, #20]
          break;
70003ca4:	e029      	b.n	70003cfa <HAL_RCCEx_GetPeriphCLKFreq+0x792>
          ethclocksource = __HAL_RCC_GET_ETH1PHY_SOURCE();
70003ca6:	4b16      	ldr	r3, [pc, #88]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003ca8:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70003caa:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
70003cae:	60bb      	str	r3, [r7, #8]
          switch (ethclocksource)
70003cb0:	68bb      	ldr	r3, [r7, #8]
70003cb2:	2b00      	cmp	r3, #0
70003cb4:	d004      	beq.n	70003cc0 <HAL_RCCEx_GetPeriphCLKFreq+0x758>
70003cb6:	68bb      	ldr	r3, [r7, #8]
70003cb8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70003cbc:	d009      	beq.n	70003cd2 <HAL_RCCEx_GetPeriphCLKFreq+0x76a>
              break;
70003cbe:	e015      	b.n	70003cec <HAL_RCCEx_GetPeriphCLKFreq+0x784>
              if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70003cc0:	4b0f      	ldr	r3, [pc, #60]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003cc2:	681b      	ldr	r3, [r3, #0]
70003cc4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70003cc8:	2b00      	cmp	r3, #0
70003cca:	d00c      	beq.n	70003ce6 <HAL_RCCEx_GetPeriphCLKFreq+0x77e>
                frequency = HSE_VALUE;
70003ccc:	4b0f      	ldr	r3, [pc, #60]	@ (70003d0c <HAL_RCCEx_GetPeriphCLKFreq+0x7a4>)
70003cce:	617b      	str	r3, [r7, #20]
              break;
70003cd0:	e009      	b.n	70003ce6 <HAL_RCCEx_GetPeriphCLKFreq+0x77e>
              if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
70003cd2:	4b0b      	ldr	r3, [pc, #44]	@ (70003d00 <HAL_RCCEx_GetPeriphCLKFreq+0x798>)
70003cd4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003cd6:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
70003cda:	2b00      	cmp	r3, #0
70003cdc:	d005      	beq.n	70003cea <HAL_RCCEx_GetPeriphCLKFreq+0x782>
                frequency = HAL_RCC_GetPLL3SFreq();
70003cde:	f7fe fb97 	bl	70002410 <HAL_RCC_GetPLL3SFreq>
70003ce2:	6178      	str	r0, [r7, #20]
              break;
70003ce4:	e001      	b.n	70003cea <HAL_RCCEx_GetPeriphCLKFreq+0x782>
              break;
70003ce6:	bf00      	nop
70003ce8:	e008      	b.n	70003cfc <HAL_RCCEx_GetPeriphCLKFreq+0x794>
              break;
70003cea:	bf00      	nop
          break;
70003cec:	e006      	b.n	70003cfc <HAL_RCCEx_GetPeriphCLKFreq+0x794>
          break;
70003cee:	bf00      	nop
70003cf0:	f000 bf75 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003cf4:	bf00      	nop
70003cf6:	f000 bf72 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003cfa:	bf00      	nop
      break;
70003cfc:	f000 bf6f 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
70003d00:	58024400 	.word	0x58024400
70003d04:	003d0900 	.word	0x003d0900
70003d08:	03d09000 	.word	0x03d09000
70003d0c:	016e3600 	.word	0x016e3600
      clocksource = __HAL_RCC_GET_ETH1PHY_SOURCE();
70003d10:	4b87      	ldr	r3, [pc, #540]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003d12:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70003d14:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
70003d18:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003d1a:	693b      	ldr	r3, [r7, #16]
70003d1c:	2b00      	cmp	r3, #0
70003d1e:	d004      	beq.n	70003d2a <HAL_RCCEx_GetPeriphCLKFreq+0x7c2>
70003d20:	693b      	ldr	r3, [r7, #16]
70003d22:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70003d26:	d009      	beq.n	70003d3c <HAL_RCCEx_GetPeriphCLKFreq+0x7d4>
          break;
70003d28:	e016      	b.n	70003d58 <HAL_RCCEx_GetPeriphCLKFreq+0x7f0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70003d2a:	4b81      	ldr	r3, [pc, #516]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003d2c:	681b      	ldr	r3, [r3, #0]
70003d2e:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70003d32:	2b00      	cmp	r3, #0
70003d34:	d00c      	beq.n	70003d50 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
            frequency = HSE_VALUE;
70003d36:	4b7f      	ldr	r3, [pc, #508]	@ (70003f34 <HAL_RCCEx_GetPeriphCLKFreq+0x9cc>)
70003d38:	617b      	str	r3, [r7, #20]
          break;
70003d3a:	e009      	b.n	70003d50 <HAL_RCCEx_GetPeriphCLKFreq+0x7e8>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
70003d3c:	4b7c      	ldr	r3, [pc, #496]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003d3e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003d40:	f003 4380 	and.w	r3, r3, #1073741824	@ 0x40000000
70003d44:	2b00      	cmp	r3, #0
70003d46:	d006      	beq.n	70003d56 <HAL_RCCEx_GetPeriphCLKFreq+0x7ee>
            frequency = HAL_RCC_GetPLL3SFreq();
70003d48:	f7fe fb62 	bl	70002410 <HAL_RCC_GetPLL3SFreq>
70003d4c:	6178      	str	r0, [r7, #20]
          break;
70003d4e:	e002      	b.n	70003d56 <HAL_RCCEx_GetPeriphCLKFreq+0x7ee>
          break;
70003d50:	bf00      	nop
70003d52:	f000 bf44 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003d56:	bf00      	nop
      break;
70003d58:	f000 bf41 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_FDCAN_SOURCE();
70003d5c:	4b74      	ldr	r3, [pc, #464]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003d5e:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70003d60:	f403 0340 	and.w	r3, r3, #12582912	@ 0xc00000
70003d64:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003d66:	693b      	ldr	r3, [r7, #16]
70003d68:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
70003d6c:	d01e      	beq.n	70003dac <HAL_RCCEx_GetPeriphCLKFreq+0x844>
70003d6e:	693b      	ldr	r3, [r7, #16]
70003d70:	f5b3 0f00 	cmp.w	r3, #8388608	@ 0x800000
70003d74:	d824      	bhi.n	70003dc0 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
70003d76:	693b      	ldr	r3, [r7, #16]
70003d78:	2b00      	cmp	r3, #0
70003d7a:	d004      	beq.n	70003d86 <HAL_RCCEx_GetPeriphCLKFreq+0x81e>
70003d7c:	693b      	ldr	r3, [r7, #16]
70003d7e:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70003d82:	d009      	beq.n	70003d98 <HAL_RCCEx_GetPeriphCLKFreq+0x830>
          break;
70003d84:	e01c      	b.n	70003dc0 <HAL_RCCEx_GetPeriphCLKFreq+0x858>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70003d86:	4b6a      	ldr	r3, [pc, #424]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003d88:	681b      	ldr	r3, [r3, #0]
70003d8a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70003d8e:	2b00      	cmp	r3, #0
70003d90:	d019      	beq.n	70003dc6 <HAL_RCCEx_GetPeriphCLKFreq+0x85e>
            frequency = HSE_VALUE;
70003d92:	4b68      	ldr	r3, [pc, #416]	@ (70003f34 <HAL_RCCEx_GetPeriphCLKFreq+0x9cc>)
70003d94:	617b      	str	r3, [r7, #20]
          break;
70003d96:	e016      	b.n	70003dc6 <HAL_RCCEx_GetPeriphCLKFreq+0x85e>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70003d98:	4b65      	ldr	r3, [pc, #404]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003d9a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003d9c:	f003 0340 	and.w	r3, r3, #64	@ 0x40
70003da0:	2b00      	cmp	r3, #0
70003da2:	d013      	beq.n	70003dcc <HAL_RCCEx_GetPeriphCLKFreq+0x864>
            frequency = HAL_RCC_GetPLL1QFreq();
70003da4:	f7fe fa6c 	bl	70002280 <HAL_RCC_GetPLL1QFreq>
70003da8:	6178      	str	r0, [r7, #20]
          break;
70003daa:	e00f      	b.n	70003dcc <HAL_RCCEx_GetPeriphCLKFreq+0x864>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70003dac:	4b60      	ldr	r3, [pc, #384]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003dae:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003db0:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70003db4:	2b00      	cmp	r3, #0
70003db6:	d00c      	beq.n	70003dd2 <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
            frequency = HAL_RCC_GetPLL2PFreq();
70003db8:	f7fe fa78 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70003dbc:	6178      	str	r0, [r7, #20]
          break;
70003dbe:	e008      	b.n	70003dd2 <HAL_RCCEx_GetPeriphCLKFreq+0x86a>
          break;
70003dc0:	bf00      	nop
70003dc2:	f000 bf0c 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003dc6:	bf00      	nop
70003dc8:	f000 bf09 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003dcc:	bf00      	nop
70003dce:	f000 bf06 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003dd2:	bf00      	nop
      break;
70003dd4:	f000 bf03 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_I2C23_SOURCE();
70003dd8:	4b55      	ldr	r3, [pc, #340]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003dda:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70003ddc:	f403 7340 	and.w	r3, r3, #768	@ 0x300
70003de0:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003de2:	693b      	ldr	r3, [r7, #16]
70003de4:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70003de8:	d037      	beq.n	70003e5a <HAL_RCCEx_GetPeriphCLKFreq+0x8f2>
70003dea:	693b      	ldr	r3, [r7, #16]
70003dec:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70003df0:	d83c      	bhi.n	70003e6c <HAL_RCCEx_GetPeriphCLKFreq+0x904>
70003df2:	693b      	ldr	r3, [r7, #16]
70003df4:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70003df8:	d019      	beq.n	70003e2e <HAL_RCCEx_GetPeriphCLKFreq+0x8c6>
70003dfa:	693b      	ldr	r3, [r7, #16]
70003dfc:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70003e00:	d834      	bhi.n	70003e6c <HAL_RCCEx_GetPeriphCLKFreq+0x904>
70003e02:	693b      	ldr	r3, [r7, #16]
70003e04:	2b00      	cmp	r3, #0
70003e06:	d004      	beq.n	70003e12 <HAL_RCCEx_GetPeriphCLKFreq+0x8aa>
70003e08:	693b      	ldr	r3, [r7, #16]
70003e0a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
70003e0e:	d004      	beq.n	70003e1a <HAL_RCCEx_GetPeriphCLKFreq+0x8b2>
          break;
70003e10:	e02c      	b.n	70003e6c <HAL_RCCEx_GetPeriphCLKFreq+0x904>
          frequency = HAL_RCC_GetPCLK1Freq();
70003e12:	f7fe f9e1 	bl	700021d8 <HAL_RCC_GetPCLK1Freq>
70003e16:	6178      	str	r0, [r7, #20]
          break;
70003e18:	e032      	b.n	70003e80 <HAL_RCCEx_GetPeriphCLKFreq+0x918>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
70003e1a:	4b45      	ldr	r3, [pc, #276]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003e1c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003e1e:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
70003e22:	2b00      	cmp	r3, #0
70003e24:	d025      	beq.n	70003e72 <HAL_RCCEx_GetPeriphCLKFreq+0x90a>
            frequency = HAL_RCC_GetPLL3RFreq();
70003e26:	f7fe fadd 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
70003e2a:	6178      	str	r0, [r7, #20]
          break;
70003e2c:	e021      	b.n	70003e72 <HAL_RCCEx_GetPeriphCLKFreq+0x90a>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
70003e2e:	4b40      	ldr	r3, [pc, #256]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003e30:	681b      	ldr	r3, [r3, #0]
70003e32:	f003 0304 	and.w	r3, r3, #4
70003e36:	2b00      	cmp	r3, #0
70003e38:	d01e      	beq.n	70003e78 <HAL_RCCEx_GetPeriphCLKFreq+0x910>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70003e3a:	4b3d      	ldr	r3, [pc, #244]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003e3c:	681b      	ldr	r3, [r3, #0]
70003e3e:	f003 0320 	and.w	r3, r3, #32
70003e42:	2b00      	cmp	r3, #0
70003e44:	d018      	beq.n	70003e78 <HAL_RCCEx_GetPeriphCLKFreq+0x910>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70003e46:	4b3a      	ldr	r3, [pc, #232]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003e48:	681b      	ldr	r3, [r3, #0]
70003e4a:	08db      	lsrs	r3, r3, #3
70003e4c:	f003 0303 	and.w	r3, r3, #3
70003e50:	4a39      	ldr	r2, [pc, #228]	@ (70003f38 <HAL_RCCEx_GetPeriphCLKFreq+0x9d0>)
70003e52:	fa22 f303 	lsr.w	r3, r2, r3
70003e56:	617b      	str	r3, [r7, #20]
          break;
70003e58:	e00e      	b.n	70003e78 <HAL_RCCEx_GetPeriphCLKFreq+0x910>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70003e5a:	4b35      	ldr	r3, [pc, #212]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003e5c:	681b      	ldr	r3, [r3, #0]
70003e5e:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70003e62:	2b00      	cmp	r3, #0
70003e64:	d00b      	beq.n	70003e7e <HAL_RCCEx_GetPeriphCLKFreq+0x916>
            frequency = CSI_VALUE;
70003e66:	4b35      	ldr	r3, [pc, #212]	@ (70003f3c <HAL_RCCEx_GetPeriphCLKFreq+0x9d4>)
70003e68:	617b      	str	r3, [r7, #20]
          break;
70003e6a:	e008      	b.n	70003e7e <HAL_RCCEx_GetPeriphCLKFreq+0x916>
          break;
70003e6c:	bf00      	nop
70003e6e:	f000 beb6 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003e72:	bf00      	nop
70003e74:	f000 beb3 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003e78:	bf00      	nop
70003e7a:	f000 beb0 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003e7e:	bf00      	nop
      break;
70003e80:	f000 bead 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_I2C1_I3C1_SOURCE();
70003e84:	4b2a      	ldr	r3, [pc, #168]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003e86:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70003e88:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
70003e8c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003e8e:	693b      	ldr	r3, [r7, #16]
70003e90:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70003e94:	d037      	beq.n	70003f06 <HAL_RCCEx_GetPeriphCLKFreq+0x99e>
70003e96:	693b      	ldr	r3, [r7, #16]
70003e98:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70003e9c:	d83c      	bhi.n	70003f18 <HAL_RCCEx_GetPeriphCLKFreq+0x9b0>
70003e9e:	693b      	ldr	r3, [r7, #16]
70003ea0:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70003ea4:	d019      	beq.n	70003eda <HAL_RCCEx_GetPeriphCLKFreq+0x972>
70003ea6:	693b      	ldr	r3, [r7, #16]
70003ea8:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70003eac:	d834      	bhi.n	70003f18 <HAL_RCCEx_GetPeriphCLKFreq+0x9b0>
70003eae:	693b      	ldr	r3, [r7, #16]
70003eb0:	2b00      	cmp	r3, #0
70003eb2:	d004      	beq.n	70003ebe <HAL_RCCEx_GetPeriphCLKFreq+0x956>
70003eb4:	693b      	ldr	r3, [r7, #16]
70003eb6:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
70003eba:	d004      	beq.n	70003ec6 <HAL_RCCEx_GetPeriphCLKFreq+0x95e>
          break;
70003ebc:	e02c      	b.n	70003f18 <HAL_RCCEx_GetPeriphCLKFreq+0x9b0>
          frequency = HAL_RCC_GetPCLK1Freq();
70003ebe:	f7fe f98b 	bl	700021d8 <HAL_RCC_GetPCLK1Freq>
70003ec2:	6178      	str	r0, [r7, #20]
          break;
70003ec4:	e032      	b.n	70003f2c <HAL_RCCEx_GetPeriphCLKFreq+0x9c4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
70003ec6:	4b1a      	ldr	r3, [pc, #104]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003ec8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003eca:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
70003ece:	2b00      	cmp	r3, #0
70003ed0:	d025      	beq.n	70003f1e <HAL_RCCEx_GetPeriphCLKFreq+0x9b6>
            frequency = HAL_RCC_GetPLL3RFreq();
70003ed2:	f7fe fa87 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
70003ed6:	6178      	str	r0, [r7, #20]
          break;
70003ed8:	e021      	b.n	70003f1e <HAL_RCCEx_GetPeriphCLKFreq+0x9b6>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
70003eda:	4b15      	ldr	r3, [pc, #84]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003edc:	681b      	ldr	r3, [r3, #0]
70003ede:	f003 0304 	and.w	r3, r3, #4
70003ee2:	2b00      	cmp	r3, #0
70003ee4:	d01e      	beq.n	70003f24 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70003ee6:	4b12      	ldr	r3, [pc, #72]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003ee8:	681b      	ldr	r3, [r3, #0]
70003eea:	f003 0320 	and.w	r3, r3, #32
70003eee:	2b00      	cmp	r3, #0
70003ef0:	d018      	beq.n	70003f24 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70003ef2:	4b0f      	ldr	r3, [pc, #60]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003ef4:	681b      	ldr	r3, [r3, #0]
70003ef6:	08db      	lsrs	r3, r3, #3
70003ef8:	f003 0303 	and.w	r3, r3, #3
70003efc:	4a0e      	ldr	r2, [pc, #56]	@ (70003f38 <HAL_RCCEx_GetPeriphCLKFreq+0x9d0>)
70003efe:	fa22 f303 	lsr.w	r3, r2, r3
70003f02:	617b      	str	r3, [r7, #20]
          break;
70003f04:	e00e      	b.n	70003f24 <HAL_RCCEx_GetPeriphCLKFreq+0x9bc>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70003f06:	4b0a      	ldr	r3, [pc, #40]	@ (70003f30 <HAL_RCCEx_GetPeriphCLKFreq+0x9c8>)
70003f08:	681b      	ldr	r3, [r3, #0]
70003f0a:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70003f0e:	2b00      	cmp	r3, #0
70003f10:	d00b      	beq.n	70003f2a <HAL_RCCEx_GetPeriphCLKFreq+0x9c2>
            frequency = CSI_VALUE;
70003f12:	4b0a      	ldr	r3, [pc, #40]	@ (70003f3c <HAL_RCCEx_GetPeriphCLKFreq+0x9d4>)
70003f14:	617b      	str	r3, [r7, #20]
          break;
70003f16:	e008      	b.n	70003f2a <HAL_RCCEx_GetPeriphCLKFreq+0x9c2>
          break;
70003f18:	bf00      	nop
70003f1a:	f000 be60 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003f1e:	bf00      	nop
70003f20:	f000 be5d 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003f24:	bf00      	nop
70003f26:	f000 be5a 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70003f2a:	bf00      	nop
      break;
70003f2c:	f000 be57 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
70003f30:	58024400 	.word	0x58024400
70003f34:	016e3600 	.word	0x016e3600
70003f38:	03d09000 	.word	0x03d09000
70003f3c:	003d0900 	.word	0x003d0900
      clocksource = __HAL_RCC_GET_LPTIM1_SOURCE();
70003f40:	4ba0      	ldr	r3, [pc, #640]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70003f42:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70003f44:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
70003f48:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70003f4a:	693b      	ldr	r3, [r7, #16]
70003f4c:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
70003f50:	d04f      	beq.n	70003ff2 <HAL_RCCEx_GetPeriphCLKFreq+0xa8a>
70003f52:	693b      	ldr	r3, [r7, #16]
70003f54:	f5b3 2fa0 	cmp.w	r3, #327680	@ 0x50000
70003f58:	d84f      	bhi.n	70003ffa <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
70003f5a:	693b      	ldr	r3, [r7, #16]
70003f5c:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70003f60:	d03d      	beq.n	70003fde <HAL_RCCEx_GetPeriphCLKFreq+0xa76>
70003f62:	693b      	ldr	r3, [r7, #16]
70003f64:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
70003f68:	d847      	bhi.n	70003ffa <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
70003f6a:	693b      	ldr	r3, [r7, #16]
70003f6c:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
70003f70:	d02b      	beq.n	70003fca <HAL_RCCEx_GetPeriphCLKFreq+0xa62>
70003f72:	693b      	ldr	r3, [r7, #16]
70003f74:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
70003f78:	d83f      	bhi.n	70003ffa <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
70003f7a:	693b      	ldr	r3, [r7, #16]
70003f7c:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70003f80:	d019      	beq.n	70003fb6 <HAL_RCCEx_GetPeriphCLKFreq+0xa4e>
70003f82:	693b      	ldr	r3, [r7, #16]
70003f84:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
70003f88:	d837      	bhi.n	70003ffa <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
70003f8a:	693b      	ldr	r3, [r7, #16]
70003f8c:	2b00      	cmp	r3, #0
70003f8e:	d004      	beq.n	70003f9a <HAL_RCCEx_GetPeriphCLKFreq+0xa32>
70003f90:	693b      	ldr	r3, [r7, #16]
70003f92:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
70003f96:	d004      	beq.n	70003fa2 <HAL_RCCEx_GetPeriphCLKFreq+0xa3a>
          break;
70003f98:	e02f      	b.n	70003ffa <HAL_RCCEx_GetPeriphCLKFreq+0xa92>
          frequency = HAL_RCC_GetPCLK1Freq();
70003f9a:	f7fe f91d 	bl	700021d8 <HAL_RCC_GetPCLK1Freq>
70003f9e:	6178      	str	r0, [r7, #20]
          break;
70003fa0:	e038      	b.n	70004014 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70003fa2:	4b88      	ldr	r3, [pc, #544]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70003fa4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003fa6:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70003faa:	2b00      	cmp	r3, #0
70003fac:	d028      	beq.n	70004000 <HAL_RCCEx_GetPeriphCLKFreq+0xa98>
            frequency = HAL_RCC_GetPLL2PFreq();
70003fae:	f7fe f97d 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70003fb2:	6178      	str	r0, [r7, #20]
          break;
70003fb4:	e024      	b.n	70004000 <HAL_RCCEx_GetPeriphCLKFreq+0xa98>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
70003fb6:	4b83      	ldr	r3, [pc, #524]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70003fb8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70003fba:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
70003fbe:	2b00      	cmp	r3, #0
70003fc0:	d021      	beq.n	70004006 <HAL_RCCEx_GetPeriphCLKFreq+0xa9e>
            frequency = HAL_RCC_GetPLL3RFreq();
70003fc2:	f7fe fa0f 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
70003fc6:	6178      	str	r0, [r7, #20]
          break;
70003fc8:	e01d      	b.n	70004006 <HAL_RCCEx_GetPeriphCLKFreq+0xa9e>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
70003fca:	4b7e      	ldr	r3, [pc, #504]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70003fcc:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70003fce:	f003 0302 	and.w	r3, r3, #2
70003fd2:	2b00      	cmp	r3, #0
70003fd4:	d01a      	beq.n	7000400c <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>
            frequency = LSE_VALUE;
70003fd6:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
70003fda:	617b      	str	r3, [r7, #20]
          break;
70003fdc:	e016      	b.n	7000400c <HAL_RCCEx_GetPeriphCLKFreq+0xaa4>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
70003fde:	4b79      	ldr	r3, [pc, #484]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70003fe0:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
70003fe2:	f003 0302 	and.w	r3, r3, #2
70003fe6:	2b00      	cmp	r3, #0
70003fe8:	d013      	beq.n	70004012 <HAL_RCCEx_GetPeriphCLKFreq+0xaaa>
            frequency = LSI_VALUE;
70003fea:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
70003fee:	617b      	str	r3, [r7, #20]
          break;
70003ff0:	e00f      	b.n	70004012 <HAL_RCCEx_GetPeriphCLKFreq+0xaaa>
          frequency = RCC_GetCLKPFreq();
70003ff2:	f000 fe0d 	bl	70004c10 <RCC_GetCLKPFreq>
70003ff6:	6178      	str	r0, [r7, #20]
          break;
70003ff8:	e00c      	b.n	70004014 <HAL_RCCEx_GetPeriphCLKFreq+0xaac>
          break;
70003ffa:	bf00      	nop
70003ffc:	f000 bdef 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004000:	bf00      	nop
70004002:	f000 bdec 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004006:	bf00      	nop
70004008:	f000 bde9 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000400c:	bf00      	nop
7000400e:	f000 bde6 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004012:	bf00      	nop
      break;
70004014:	f000 bde3 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_LPTIM23_SOURCE();
70004018:	4b6a      	ldr	r3, [pc, #424]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
7000401a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
7000401c:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
70004020:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70004022:	693b      	ldr	r3, [r7, #16]
70004024:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
70004028:	d04f      	beq.n	700040ca <HAL_RCCEx_GetPeriphCLKFreq+0xb62>
7000402a:	693b      	ldr	r3, [r7, #16]
7000402c:	f5b3 6fa0 	cmp.w	r3, #1280	@ 0x500
70004030:	d84f      	bhi.n	700040d2 <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
70004032:	693b      	ldr	r3, [r7, #16]
70004034:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70004038:	d03d      	beq.n	700040b6 <HAL_RCCEx_GetPeriphCLKFreq+0xb4e>
7000403a:	693b      	ldr	r3, [r7, #16]
7000403c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70004040:	d847      	bhi.n	700040d2 <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
70004042:	693b      	ldr	r3, [r7, #16]
70004044:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70004048:	d02b      	beq.n	700040a2 <HAL_RCCEx_GetPeriphCLKFreq+0xb3a>
7000404a:	693b      	ldr	r3, [r7, #16]
7000404c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70004050:	d83f      	bhi.n	700040d2 <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
70004052:	693b      	ldr	r3, [r7, #16]
70004054:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70004058:	d019      	beq.n	7000408e <HAL_RCCEx_GetPeriphCLKFreq+0xb26>
7000405a:	693b      	ldr	r3, [r7, #16]
7000405c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70004060:	d837      	bhi.n	700040d2 <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
70004062:	693b      	ldr	r3, [r7, #16]
70004064:	2b00      	cmp	r3, #0
70004066:	d004      	beq.n	70004072 <HAL_RCCEx_GetPeriphCLKFreq+0xb0a>
70004068:	693b      	ldr	r3, [r7, #16]
7000406a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
7000406e:	d004      	beq.n	7000407a <HAL_RCCEx_GetPeriphCLKFreq+0xb12>
          break;
70004070:	e02f      	b.n	700040d2 <HAL_RCCEx_GetPeriphCLKFreq+0xb6a>
          frequency = HAL_RCC_GetPCLK4Freq();
70004072:	f7fe f8e9 	bl	70002248 <HAL_RCC_GetPCLK4Freq>
70004076:	6178      	str	r0, [r7, #20]
          break;
70004078:	e038      	b.n	700040ec <HAL_RCCEx_GetPeriphCLKFreq+0xb84>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
7000407a:	4b52      	ldr	r3, [pc, #328]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
7000407c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000407e:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70004082:	2b00      	cmp	r3, #0
70004084:	d028      	beq.n	700040d8 <HAL_RCCEx_GetPeriphCLKFreq+0xb70>
            frequency = HAL_RCC_GetPLL2PFreq();
70004086:	f7fe f911 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
7000408a:	6178      	str	r0, [r7, #20]
          break;
7000408c:	e024      	b.n	700040d8 <HAL_RCCEx_GetPeriphCLKFreq+0xb70>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
7000408e:	4b4d      	ldr	r3, [pc, #308]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70004090:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004092:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
70004096:	2b00      	cmp	r3, #0
70004098:	d021      	beq.n	700040de <HAL_RCCEx_GetPeriphCLKFreq+0xb76>
            frequency = HAL_RCC_GetPLL3RFreq();
7000409a:	f7fe f9a3 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
7000409e:	6178      	str	r0, [r7, #20]
          break;
700040a0:	e01d      	b.n	700040de <HAL_RCCEx_GetPeriphCLKFreq+0xb76>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
700040a2:	4b48      	ldr	r3, [pc, #288]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
700040a4:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
700040a6:	f003 0302 	and.w	r3, r3, #2
700040aa:	2b00      	cmp	r3, #0
700040ac:	d01a      	beq.n	700040e4 <HAL_RCCEx_GetPeriphCLKFreq+0xb7c>
            frequency = LSE_VALUE;
700040ae:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
700040b2:	617b      	str	r3, [r7, #20]
          break;
700040b4:	e016      	b.n	700040e4 <HAL_RCCEx_GetPeriphCLKFreq+0xb7c>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
700040b6:	4b43      	ldr	r3, [pc, #268]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
700040b8:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
700040ba:	f003 0302 	and.w	r3, r3, #2
700040be:	2b00      	cmp	r3, #0
700040c0:	d013      	beq.n	700040ea <HAL_RCCEx_GetPeriphCLKFreq+0xb82>
            frequency = LSI_VALUE;
700040c2:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
700040c6:	617b      	str	r3, [r7, #20]
          break;
700040c8:	e00f      	b.n	700040ea <HAL_RCCEx_GetPeriphCLKFreq+0xb82>
          frequency = RCC_GetCLKPFreq();
700040ca:	f000 fda1 	bl	70004c10 <RCC_GetCLKPFreq>
700040ce:	6178      	str	r0, [r7, #20]
          break;
700040d0:	e00c      	b.n	700040ec <HAL_RCCEx_GetPeriphCLKFreq+0xb84>
          break;
700040d2:	bf00      	nop
700040d4:	f000 bd83 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700040d8:	bf00      	nop
700040da:	f000 bd80 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700040de:	bf00      	nop
700040e0:	f000 bd7d 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700040e4:	bf00      	nop
700040e6:	f000 bd7a 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700040ea:	bf00      	nop
      break;
700040ec:	f000 bd77 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_LPTIM45_SOURCE();
700040f0:	4b34      	ldr	r3, [pc, #208]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
700040f2:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
700040f4:	f403 43e0 	and.w	r3, r3, #28672	@ 0x7000
700040f8:	613b      	str	r3, [r7, #16]
      switch (clocksource)
700040fa:	693b      	ldr	r3, [r7, #16]
700040fc:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
70004100:	d04f      	beq.n	700041a2 <HAL_RCCEx_GetPeriphCLKFreq+0xc3a>
70004102:	693b      	ldr	r3, [r7, #16]
70004104:	f5b3 4fa0 	cmp.w	r3, #20480	@ 0x5000
70004108:	d84f      	bhi.n	700041aa <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
7000410a:	693b      	ldr	r3, [r7, #16]
7000410c:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
70004110:	d03d      	beq.n	7000418e <HAL_RCCEx_GetPeriphCLKFreq+0xc26>
70004112:	693b      	ldr	r3, [r7, #16]
70004114:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
70004118:	d847      	bhi.n	700041aa <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
7000411a:	693b      	ldr	r3, [r7, #16]
7000411c:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70004120:	d02b      	beq.n	7000417a <HAL_RCCEx_GetPeriphCLKFreq+0xc12>
70004122:	693b      	ldr	r3, [r7, #16]
70004124:	f5b3 5f40 	cmp.w	r3, #12288	@ 0x3000
70004128:	d83f      	bhi.n	700041aa <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
7000412a:	693b      	ldr	r3, [r7, #16]
7000412c:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70004130:	d019      	beq.n	70004166 <HAL_RCCEx_GetPeriphCLKFreq+0xbfe>
70004132:	693b      	ldr	r3, [r7, #16]
70004134:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70004138:	d837      	bhi.n	700041aa <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
7000413a:	693b      	ldr	r3, [r7, #16]
7000413c:	2b00      	cmp	r3, #0
7000413e:	d004      	beq.n	7000414a <HAL_RCCEx_GetPeriphCLKFreq+0xbe2>
70004140:	693b      	ldr	r3, [r7, #16]
70004142:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
70004146:	d004      	beq.n	70004152 <HAL_RCCEx_GetPeriphCLKFreq+0xbea>
          break;
70004148:	e02f      	b.n	700041aa <HAL_RCCEx_GetPeriphCLKFreq+0xc42>
          frequency = HAL_RCC_GetPCLK4Freq();
7000414a:	f7fe f87d 	bl	70002248 <HAL_RCC_GetPCLK4Freq>
7000414e:	6178      	str	r0, [r7, #20]
          break;
70004150:	e03b      	b.n	700041ca <HAL_RCCEx_GetPeriphCLKFreq+0xc62>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70004152:	4b1c      	ldr	r3, [pc, #112]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70004154:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004156:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
7000415a:	2b00      	cmp	r3, #0
7000415c:	d028      	beq.n	700041b0 <HAL_RCCEx_GetPeriphCLKFreq+0xc48>
            frequency = HAL_RCC_GetPLL2PFreq();
7000415e:	f7fe f8a5 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70004162:	6178      	str	r0, [r7, #20]
          break;
70004164:	e024      	b.n	700041b0 <HAL_RCCEx_GetPeriphCLKFreq+0xc48>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
70004166:	4b17      	ldr	r3, [pc, #92]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70004168:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000416a:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
7000416e:	2b00      	cmp	r3, #0
70004170:	d021      	beq.n	700041b6 <HAL_RCCEx_GetPeriphCLKFreq+0xc4e>
            frequency = HAL_RCC_GetPLL3RFreq();
70004172:	f7fe f937 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
70004176:	6178      	str	r0, [r7, #20]
          break;
70004178:	e01d      	b.n	700041b6 <HAL_RCCEx_GetPeriphCLKFreq+0xc4e>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
7000417a:	4b12      	ldr	r3, [pc, #72]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
7000417c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
7000417e:	f003 0302 	and.w	r3, r3, #2
70004182:	2b00      	cmp	r3, #0
70004184:	d01a      	beq.n	700041bc <HAL_RCCEx_GetPeriphCLKFreq+0xc54>
            frequency = LSE_VALUE;
70004186:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
7000418a:	617b      	str	r3, [r7, #20]
          break;
7000418c:	e016      	b.n	700041bc <HAL_RCCEx_GetPeriphCLKFreq+0xc54>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
7000418e:	4b0d      	ldr	r3, [pc, #52]	@ (700041c4 <HAL_RCCEx_GetPeriphCLKFreq+0xc5c>)
70004190:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
70004192:	f003 0302 	and.w	r3, r3, #2
70004196:	2b00      	cmp	r3, #0
70004198:	d016      	beq.n	700041c8 <HAL_RCCEx_GetPeriphCLKFreq+0xc60>
            frequency = LSI_VALUE;
7000419a:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
7000419e:	617b      	str	r3, [r7, #20]
          break;
700041a0:	e012      	b.n	700041c8 <HAL_RCCEx_GetPeriphCLKFreq+0xc60>
          frequency = RCC_GetCLKPFreq();
700041a2:	f000 fd35 	bl	70004c10 <RCC_GetCLKPFreq>
700041a6:	6178      	str	r0, [r7, #20]
          break;
700041a8:	e00f      	b.n	700041ca <HAL_RCCEx_GetPeriphCLKFreq+0xc62>
          break;
700041aa:	bf00      	nop
700041ac:	f000 bd17 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700041b0:	bf00      	nop
700041b2:	f000 bd14 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700041b6:	bf00      	nop
700041b8:	f000 bd11 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700041bc:	bf00      	nop
700041be:	f000 bd0e 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
700041c2:	bf00      	nop
700041c4:	58024400 	.word	0x58024400
          break;
700041c8:	bf00      	nop
      break;
700041ca:	f000 bd08 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_LPUART1_SOURCE();
700041ce:	4ba3      	ldr	r3, [pc, #652]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
700041d0:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
700041d2:	f003 0307 	and.w	r3, r3, #7
700041d6:	613b      	str	r3, [r7, #16]
      switch (clocksource)
700041d8:	693b      	ldr	r3, [r7, #16]
700041da:	2b05      	cmp	r3, #5
700041dc:	d84f      	bhi.n	7000427e <HAL_RCCEx_GetPeriphCLKFreq+0xd16>
700041de:	a201      	add	r2, pc, #4	@ (adr r2, 700041e4 <HAL_RCCEx_GetPeriphCLKFreq+0xc7c>)
700041e0:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
700041e4:	700041fd 	.word	0x700041fd
700041e8:	70004205 	.word	0x70004205
700041ec:	70004219 	.word	0x70004219
700041f0:	7000422d 	.word	0x7000422d
700041f4:	70004259 	.word	0x70004259
700041f8:	7000426b 	.word	0x7000426b
          frequency = HAL_RCC_GetPCLK4Freq();
700041fc:	f7fe f824 	bl	70002248 <HAL_RCC_GetPCLK4Freq>
70004200:	6178      	str	r0, [r7, #20]
          break;
70004202:	e04c      	b.n	7000429e <HAL_RCCEx_GetPeriphCLKFreq+0xd36>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004204:	4b95      	ldr	r3, [pc, #596]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004206:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004208:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
7000420c:	2b00      	cmp	r3, #0
7000420e:	d039      	beq.n	70004284 <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
            frequency = HAL_RCC_GetPLL2QFreq();
70004210:	f7fe f862 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
70004214:	6178      	str	r0, [r7, #20]
          break;
70004216:	e035      	b.n	70004284 <HAL_RCCEx_GetPeriphCLKFreq+0xd1c>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004218:	4b90      	ldr	r3, [pc, #576]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
7000421a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000421c:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
70004220:	2b00      	cmp	r3, #0
70004222:	d032      	beq.n	7000428a <HAL_RCCEx_GetPeriphCLKFreq+0xd22>
            frequency = HAL_RCC_GetPLL3QFreq();
70004224:	f7fe f8c8 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
70004228:	6178      	str	r0, [r7, #20]
          break;
7000422a:	e02e      	b.n	7000428a <HAL_RCCEx_GetPeriphCLKFreq+0xd22>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
7000422c:	4b8b      	ldr	r3, [pc, #556]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
7000422e:	681b      	ldr	r3, [r3, #0]
70004230:	f003 0304 	and.w	r3, r3, #4
70004234:	2b00      	cmp	r3, #0
70004236:	d02b      	beq.n	70004290 <HAL_RCCEx_GetPeriphCLKFreq+0xd28>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70004238:	4b88      	ldr	r3, [pc, #544]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
7000423a:	681b      	ldr	r3, [r3, #0]
7000423c:	f003 0320 	and.w	r3, r3, #32
70004240:	2b00      	cmp	r3, #0
70004242:	d025      	beq.n	70004290 <HAL_RCCEx_GetPeriphCLKFreq+0xd28>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70004244:	4b85      	ldr	r3, [pc, #532]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004246:	681b      	ldr	r3, [r3, #0]
70004248:	08db      	lsrs	r3, r3, #3
7000424a:	f003 0303 	and.w	r3, r3, #3
7000424e:	4a84      	ldr	r2, [pc, #528]	@ (70004460 <HAL_RCCEx_GetPeriphCLKFreq+0xef8>)
70004250:	fa22 f303 	lsr.w	r3, r2, r3
70004254:	617b      	str	r3, [r7, #20]
          break;
70004256:	e01b      	b.n	70004290 <HAL_RCCEx_GetPeriphCLKFreq+0xd28>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70004258:	4b80      	ldr	r3, [pc, #512]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
7000425a:	681b      	ldr	r3, [r3, #0]
7000425c:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70004260:	2b00      	cmp	r3, #0
70004262:	d018      	beq.n	70004296 <HAL_RCCEx_GetPeriphCLKFreq+0xd2e>
            frequency = CSI_VALUE;
70004264:	4b7f      	ldr	r3, [pc, #508]	@ (70004464 <HAL_RCCEx_GetPeriphCLKFreq+0xefc>)
70004266:	617b      	str	r3, [r7, #20]
          break;
70004268:	e015      	b.n	70004296 <HAL_RCCEx_GetPeriphCLKFreq+0xd2e>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
7000426a:	4b7c      	ldr	r3, [pc, #496]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
7000426c:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
7000426e:	f003 0302 	and.w	r3, r3, #2
70004272:	2b00      	cmp	r3, #0
70004274:	d012      	beq.n	7000429c <HAL_RCCEx_GetPeriphCLKFreq+0xd34>
            frequency = LSE_VALUE;
70004276:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
7000427a:	617b      	str	r3, [r7, #20]
          break;
7000427c:	e00e      	b.n	7000429c <HAL_RCCEx_GetPeriphCLKFreq+0xd34>
          break;
7000427e:	bf00      	nop
70004280:	f000 bcad 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004284:	bf00      	nop
70004286:	f000 bcaa 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000428a:	bf00      	nop
7000428c:	f000 bca7 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004290:	bf00      	nop
70004292:	f000 bca4 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004296:	bf00      	nop
70004298:	f000 bca1 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000429c:	bf00      	nop
      break;
7000429e:	f000 bc9e 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
700042a2:	4b6e      	ldr	r3, [pc, #440]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
700042a4:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700042a6:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
700042aa:	2b00      	cmp	r3, #0
700042ac:	f000 8494 	beq.w	70004bd8 <HAL_RCCEx_GetPeriphCLKFreq+0x1670>
        frequency = HAL_RCC_GetPLL3RFreq();
700042b0:	f7fe f898 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
700042b4:	6178      	str	r0, [r7, #20]
      break;
700042b6:	f000 bc8f 	b.w	70004bd8 <HAL_RCCEx_GetPeriphCLKFreq+0x1670>
      clocksource = __HAL_RCC_GET_PSSI_SOURCE();
700042ba:	4b68      	ldr	r3, [pc, #416]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
700042bc:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
700042be:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
700042c2:	613b      	str	r3, [r7, #16]
      switch (clocksource)
700042c4:	693b      	ldr	r3, [r7, #16]
700042c6:	2b00      	cmp	r3, #0
700042c8:	d004      	beq.n	700042d4 <HAL_RCCEx_GetPeriphCLKFreq+0xd6c>
700042ca:	693b      	ldr	r3, [r7, #16]
700042cc:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
700042d0:	d00a      	beq.n	700042e8 <HAL_RCCEx_GetPeriphCLKFreq+0xd80>
          break;
700042d2:	e00e      	b.n	700042f2 <HAL_RCCEx_GetPeriphCLKFreq+0xd8a>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
700042d4:	4b61      	ldr	r3, [pc, #388]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
700042d6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700042d8:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
700042dc:	2b00      	cmp	r3, #0
700042de:	d007      	beq.n	700042f0 <HAL_RCCEx_GetPeriphCLKFreq+0xd88>
            frequency = HAL_RCC_GetPLL3RFreq();
700042e0:	f7fe f880 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
700042e4:	6178      	str	r0, [r7, #20]
          break;
700042e6:	e003      	b.n	700042f0 <HAL_RCCEx_GetPeriphCLKFreq+0xd88>
          frequency = RCC_GetCLKPFreq();
700042e8:	f000 fc92 	bl	70004c10 <RCC_GetCLKPFreq>
700042ec:	6178      	str	r0, [r7, #20]
          break;
700042ee:	e000      	b.n	700042f2 <HAL_RCCEx_GetPeriphCLKFreq+0xd8a>
          break;
700042f0:	bf00      	nop
      break;
700042f2:	f000 bc74 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_RTC_SOURCE();
700042f6:	4b59      	ldr	r3, [pc, #356]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
700042f8:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
700042fa:	f403 7340 	and.w	r3, r3, #768	@ 0x300
700042fe:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70004302:	d107      	bne.n	70004314 <HAL_RCCEx_GetPeriphCLKFreq+0xdac>
70004304:	4b55      	ldr	r3, [pc, #340]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004306:	691b      	ldr	r3, [r3, #16]
70004308:	011b      	lsls	r3, r3, #4
7000430a:	f403 337c 	and.w	r3, r3, #258048	@ 0x3f000
7000430e:	f443 7340 	orr.w	r3, r3, #768	@ 0x300
70004312:	e003      	b.n	7000431c <HAL_RCCEx_GetPeriphCLKFreq+0xdb4>
70004314:	4b51      	ldr	r3, [pc, #324]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004316:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70004318:	f403 7340 	and.w	r3, r3, #768	@ 0x300
7000431c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
7000431e:	693b      	ldr	r3, [r7, #16]
70004320:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70004324:	d014      	beq.n	70004350 <HAL_RCCEx_GetPeriphCLKFreq+0xde8>
70004326:	693b      	ldr	r3, [r7, #16]
70004328:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
7000432c:	d81a      	bhi.n	70004364 <HAL_RCCEx_GetPeriphCLKFreq+0xdfc>
7000432e:	693b      	ldr	r3, [r7, #16]
70004330:	2b00      	cmp	r3, #0
70004332:	d033      	beq.n	7000439c <HAL_RCCEx_GetPeriphCLKFreq+0xe34>
70004334:	693b      	ldr	r3, [r7, #16]
70004336:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
7000433a:	d113      	bne.n	70004364 <HAL_RCCEx_GetPeriphCLKFreq+0xdfc>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
7000433c:	4b47      	ldr	r3, [pc, #284]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
7000433e:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70004340:	f003 0302 	and.w	r3, r3, #2
70004344:	2b00      	cmp	r3, #0
70004346:	d02c      	beq.n	700043a2 <HAL_RCCEx_GetPeriphCLKFreq+0xe3a>
            frequency = LSE_VALUE;
70004348:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
7000434c:	617b      	str	r3, [r7, #20]
          break;
7000434e:	e028      	b.n	700043a2 <HAL_RCCEx_GetPeriphCLKFreq+0xe3a>
          if (READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
70004350:	4b42      	ldr	r3, [pc, #264]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004352:	6f5b      	ldr	r3, [r3, #116]	@ 0x74
70004354:	f003 0302 	and.w	r3, r3, #2
70004358:	2b00      	cmp	r3, #0
7000435a:	d025      	beq.n	700043a8 <HAL_RCCEx_GetPeriphCLKFreq+0xe40>
            frequency = LSI_VALUE;
7000435c:	f44f 43fa 	mov.w	r3, #32000	@ 0x7d00
70004360:	617b      	str	r3, [r7, #20]
          break;
70004362:	e021      	b.n	700043a8 <HAL_RCCEx_GetPeriphCLKFreq+0xe40>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL) == RCC_BDCR_RTCSEL) /*!< HSE is the clock source for RTC */
70004364:	4b3d      	ldr	r3, [pc, #244]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004366:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70004368:	f403 7340 	and.w	r3, r3, #768	@ 0x300
7000436c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70004370:	d11d      	bne.n	700043ae <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
            if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70004372:	4b3a      	ldr	r3, [pc, #232]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004374:	681b      	ldr	r3, [r3, #0]
70004376:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
7000437a:	2b00      	cmp	r3, #0
7000437c:	d017      	beq.n	700043ae <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
              prescaler = READ_BIT(RCC->CFGR, RCC_CFGR_RTCPRE) >> RCC_CFGR_RTCPRE_Pos;
7000437e:	4b37      	ldr	r3, [pc, #220]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004380:	691b      	ldr	r3, [r3, #16]
70004382:	0a1b      	lsrs	r3, r3, #8
70004384:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70004388:	60fb      	str	r3, [r7, #12]
              if (prescaler > 1U)
7000438a:	68fb      	ldr	r3, [r7, #12]
7000438c:	2b01      	cmp	r3, #1
7000438e:	d90e      	bls.n	700043ae <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
                frequency = HSE_VALUE / prescaler;
70004390:	4a35      	ldr	r2, [pc, #212]	@ (70004468 <HAL_RCCEx_GetPeriphCLKFreq+0xf00>)
70004392:	68fb      	ldr	r3, [r7, #12]
70004394:	fbb2 f3f3 	udiv	r3, r2, r3
70004398:	617b      	str	r3, [r7, #20]
          break;
7000439a:	e008      	b.n	700043ae <HAL_RCCEx_GetPeriphCLKFreq+0xe46>
          break;
7000439c:	bf00      	nop
7000439e:	f000 bc1e 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700043a2:	bf00      	nop
700043a4:	f000 bc1b 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700043a8:	bf00      	nop
700043aa:	f000 bc18 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700043ae:	bf00      	nop
      break;
700043b0:	f000 bc15 	b.w	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SAI1_SOURCE();
700043b4:	4b29      	ldr	r3, [pc, #164]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
700043b6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
700043b8:	f403 23e0 	and.w	r3, r3, #458752	@ 0x70000
700043bc:	613b      	str	r3, [r7, #16]
      switch (clocksource)
700043be:	693b      	ldr	r3, [r7, #16]
700043c0:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
700043c4:	d039      	beq.n	7000443a <HAL_RCCEx_GetPeriphCLKFreq+0xed2>
700043c6:	693b      	ldr	r3, [r7, #16]
700043c8:	f5b3 2f80 	cmp.w	r3, #262144	@ 0x40000
700043cc:	d83d      	bhi.n	7000444a <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
700043ce:	693b      	ldr	r3, [r7, #16]
700043d0:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
700043d4:	d035      	beq.n	70004442 <HAL_RCCEx_GetPeriphCLKFreq+0xeda>
700043d6:	693b      	ldr	r3, [r7, #16]
700043d8:	f5b3 3f40 	cmp.w	r3, #196608	@ 0x30000
700043dc:	d835      	bhi.n	7000444a <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
700043de:	693b      	ldr	r3, [r7, #16]
700043e0:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
700043e4:	d01f      	beq.n	70004426 <HAL_RCCEx_GetPeriphCLKFreq+0xebe>
700043e6:	693b      	ldr	r3, [r7, #16]
700043e8:	f5b3 3f00 	cmp.w	r3, #131072	@ 0x20000
700043ec:	d82d      	bhi.n	7000444a <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
700043ee:	693b      	ldr	r3, [r7, #16]
700043f0:	2b00      	cmp	r3, #0
700043f2:	d004      	beq.n	700043fe <HAL_RCCEx_GetPeriphCLKFreq+0xe96>
700043f4:	693b      	ldr	r3, [r7, #16]
700043f6:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
700043fa:	d00a      	beq.n	70004412 <HAL_RCCEx_GetPeriphCLKFreq+0xeaa>
          break;
700043fc:	e025      	b.n	7000444a <HAL_RCCEx_GetPeriphCLKFreq+0xee2>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
700043fe:	4b17      	ldr	r3, [pc, #92]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004400:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004402:	f003 0340 	and.w	r3, r3, #64	@ 0x40
70004406:	2b00      	cmp	r3, #0
70004408:	d021      	beq.n	7000444e <HAL_RCCEx_GetPeriphCLKFreq+0xee6>
            frequency = HAL_RCC_GetPLL1QFreq();
7000440a:	f7fd ff39 	bl	70002280 <HAL_RCC_GetPLL1QFreq>
7000440e:	6178      	str	r0, [r7, #20]
          break;
70004410:	e01d      	b.n	7000444e <HAL_RCCEx_GetPeriphCLKFreq+0xee6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70004412:	4b12      	ldr	r3, [pc, #72]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004414:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004416:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
7000441a:	2b00      	cmp	r3, #0
7000441c:	d019      	beq.n	70004452 <HAL_RCCEx_GetPeriphCLKFreq+0xeea>
            frequency = HAL_RCC_GetPLL2PFreq();
7000441e:	f7fd ff45 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70004422:	6178      	str	r0, [r7, #20]
          break;
70004424:	e015      	b.n	70004452 <HAL_RCCEx_GetPeriphCLKFreq+0xeea>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70004426:	4b0d      	ldr	r3, [pc, #52]	@ (7000445c <HAL_RCCEx_GetPeriphCLKFreq+0xef4>)
70004428:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000442a:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
7000442e:	2b00      	cmp	r3, #0
70004430:	d011      	beq.n	70004456 <HAL_RCCEx_GetPeriphCLKFreq+0xeee>
            frequency = HAL_RCC_GetPLL3PFreq();
70004432:	f7fd ffab 	bl	7000238c <HAL_RCC_GetPLL3PFreq>
70004436:	6178      	str	r0, [r7, #20]
          break;
70004438:	e00d      	b.n	70004456 <HAL_RCCEx_GetPeriphCLKFreq+0xeee>
          frequency = RCC_GetCLKPFreq();
7000443a:	f000 fbe9 	bl	70004c10 <RCC_GetCLKPFreq>
7000443e:	6178      	str	r0, [r7, #20]
          break;
70004440:	e00a      	b.n	70004458 <HAL_RCCEx_GetPeriphCLKFreq+0xef0>
          frequency = EXTERNAL_CLOCK_VALUE;
70004442:	f64b 3380 	movw	r3, #48000	@ 0xbb80
70004446:	617b      	str	r3, [r7, #20]
          break;
70004448:	e006      	b.n	70004458 <HAL_RCCEx_GetPeriphCLKFreq+0xef0>
          break;
7000444a:	bf00      	nop
7000444c:	e3c7      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000444e:	bf00      	nop
70004450:	e3c5      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004452:	bf00      	nop
70004454:	e3c3      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004456:	bf00      	nop
      break;
70004458:	e3c1      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
7000445a:	bf00      	nop
7000445c:	58024400 	.word	0x58024400
70004460:	03d09000 	.word	0x03d09000
70004464:	003d0900 	.word	0x003d0900
70004468:	016e3600 	.word	0x016e3600
      clocksource = __HAL_RCC_GET_SAI2_SOURCE();
7000446c:	4b94      	ldr	r3, [pc, #592]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
7000446e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70004470:	f403 03e0 	and.w	r3, r3, #7340032	@ 0x700000
70004474:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70004476:	693b      	ldr	r3, [r7, #16]
70004478:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
7000447c:	d049      	beq.n	70004512 <HAL_RCCEx_GetPeriphCLKFreq+0xfaa>
7000447e:	693b      	ldr	r3, [r7, #16]
70004480:	f5b3 0fa0 	cmp.w	r3, #5242880	@ 0x500000
70004484:	d847      	bhi.n	70004516 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
70004486:	693b      	ldr	r3, [r7, #16]
70004488:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
7000448c:	d039      	beq.n	70004502 <HAL_RCCEx_GetPeriphCLKFreq+0xf9a>
7000448e:	693b      	ldr	r3, [r7, #16]
70004490:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
70004494:	d83f      	bhi.n	70004516 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
70004496:	693b      	ldr	r3, [r7, #16]
70004498:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
7000449c:	d035      	beq.n	7000450a <HAL_RCCEx_GetPeriphCLKFreq+0xfa2>
7000449e:	693b      	ldr	r3, [r7, #16]
700044a0:	f5b3 1f40 	cmp.w	r3, #3145728	@ 0x300000
700044a4:	d837      	bhi.n	70004516 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
700044a6:	693b      	ldr	r3, [r7, #16]
700044a8:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
700044ac:	d01f      	beq.n	700044ee <HAL_RCCEx_GetPeriphCLKFreq+0xf86>
700044ae:	693b      	ldr	r3, [r7, #16]
700044b0:	f5b3 1f00 	cmp.w	r3, #2097152	@ 0x200000
700044b4:	d82f      	bhi.n	70004516 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
700044b6:	693b      	ldr	r3, [r7, #16]
700044b8:	2b00      	cmp	r3, #0
700044ba:	d004      	beq.n	700044c6 <HAL_RCCEx_GetPeriphCLKFreq+0xf5e>
700044bc:	693b      	ldr	r3, [r7, #16]
700044be:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
700044c2:	d00a      	beq.n	700044da <HAL_RCCEx_GetPeriphCLKFreq+0xf72>
          break;
700044c4:	e027      	b.n	70004516 <HAL_RCCEx_GetPeriphCLKFreq+0xfae>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
700044c6:	4b7e      	ldr	r3, [pc, #504]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700044c8:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700044ca:	f003 0340 	and.w	r3, r3, #64	@ 0x40
700044ce:	2b00      	cmp	r3, #0
700044d0:	d023      	beq.n	7000451a <HAL_RCCEx_GetPeriphCLKFreq+0xfb2>
            frequency = HAL_RCC_GetPLL1QFreq();
700044d2:	f7fd fed5 	bl	70002280 <HAL_RCC_GetPLL1QFreq>
700044d6:	6178      	str	r0, [r7, #20]
          break;
700044d8:	e01f      	b.n	7000451a <HAL_RCCEx_GetPeriphCLKFreq+0xfb2>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
700044da:	4b79      	ldr	r3, [pc, #484]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700044dc:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700044de:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
700044e2:	2b00      	cmp	r3, #0
700044e4:	d01b      	beq.n	7000451e <HAL_RCCEx_GetPeriphCLKFreq+0xfb6>
            frequency = HAL_RCC_GetPLL2PFreq();
700044e6:	f7fd fee1 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
700044ea:	6178      	str	r0, [r7, #20]
          break;
700044ec:	e017      	b.n	7000451e <HAL_RCCEx_GetPeriphCLKFreq+0xfb6>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
700044ee:	4b74      	ldr	r3, [pc, #464]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700044f0:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700044f2:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
700044f6:	2b00      	cmp	r3, #0
700044f8:	d013      	beq.n	70004522 <HAL_RCCEx_GetPeriphCLKFreq+0xfba>
            frequency = HAL_RCC_GetPLL3PFreq();
700044fa:	f7fd ff47 	bl	7000238c <HAL_RCC_GetPLL3PFreq>
700044fe:	6178      	str	r0, [r7, #20]
          break;
70004500:	e00f      	b.n	70004522 <HAL_RCCEx_GetPeriphCLKFreq+0xfba>
          frequency = RCC_GetCLKPFreq();
70004502:	f000 fb85 	bl	70004c10 <RCC_GetCLKPFreq>
70004506:	6178      	str	r0, [r7, #20]
          break;
70004508:	e00c      	b.n	70004524 <HAL_RCCEx_GetPeriphCLKFreq+0xfbc>
          frequency = EXTERNAL_CLOCK_VALUE;
7000450a:	f64b 3380 	movw	r3, #48000	@ 0xbb80
7000450e:	617b      	str	r3, [r7, #20]
          break;
70004510:	e008      	b.n	70004524 <HAL_RCCEx_GetPeriphCLKFreq+0xfbc>
          break;
70004512:	bf00      	nop
70004514:	e363      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004516:	bf00      	nop
70004518:	e361      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000451a:	bf00      	nop
7000451c:	e35f      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000451e:	bf00      	nop
70004520:	e35d      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004522:	bf00      	nop
      break;
70004524:	e35b      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SDMMC12_SOURCE();
70004526:	4b66      	ldr	r3, [pc, #408]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
70004528:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
7000452a:	f003 0304 	and.w	r3, r3, #4
7000452e:	613b      	str	r3, [r7, #16]
      if (clocksource ==
70004530:	693b      	ldr	r3, [r7, #16]
70004532:	2b00      	cmp	r3, #0
70004534:	d10a      	bne.n	7000454c <HAL_RCCEx_GetPeriphCLKFreq+0xfe4>
        if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_SCLK) != 0U)
70004536:	4b62      	ldr	r3, [pc, #392]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
70004538:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000453a:	f403 2300 	and.w	r3, r3, #524288	@ 0x80000
7000453e:	2b00      	cmp	r3, #0
70004540:	f000 834c 	beq.w	70004bdc <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
          frequency = HAL_RCC_GetPLL2SFreq();
70004544:	f7fd fef4 	bl	70002330 <HAL_RCC_GetPLL2SFreq>
70004548:	6178      	str	r0, [r7, #20]
      break;
7000454a:	e347      	b.n	70004bdc <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
        if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_TCLK) != 0U)
7000454c:	4b5c      	ldr	r3, [pc, #368]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
7000454e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004550:	f403 1380 	and.w	r3, r3, #1048576	@ 0x100000
70004554:	2b00      	cmp	r3, #0
70004556:	f000 8341 	beq.w	70004bdc <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
          frequency = HAL_RCC_GetPLL2TFreq();
7000455a:	f7fd feff 	bl	7000235c <HAL_RCC_GetPLL2TFreq>
7000455e:	6178      	str	r0, [r7, #20]
      break;
70004560:	e33c      	b.n	70004bdc <HAL_RCCEx_GetPeriphCLKFreq+0x1674>
      clocksource = __HAL_RCC_GET_SPDIFRX_SOURCE();
70004562:	4b57      	ldr	r3, [pc, #348]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
70004564:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70004566:	f003 7340 	and.w	r3, r3, #50331648	@ 0x3000000
7000456a:	613b      	str	r3, [r7, #16]
      switch (clocksource)
7000456c:	693b      	ldr	r3, [r7, #16]
7000456e:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
70004572:	d031      	beq.n	700045d8 <HAL_RCCEx_GetPeriphCLKFreq+0x1070>
70004574:	693b      	ldr	r3, [r7, #16]
70004576:	f1b3 7f40 	cmp.w	r3, #50331648	@ 0x3000000
7000457a:	d843      	bhi.n	70004604 <HAL_RCCEx_GetPeriphCLKFreq+0x109c>
7000457c:	693b      	ldr	r3, [r7, #16]
7000457e:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
70004582:	d01f      	beq.n	700045c4 <HAL_RCCEx_GetPeriphCLKFreq+0x105c>
70004584:	693b      	ldr	r3, [r7, #16]
70004586:	f1b3 7f00 	cmp.w	r3, #33554432	@ 0x2000000
7000458a:	d83b      	bhi.n	70004604 <HAL_RCCEx_GetPeriphCLKFreq+0x109c>
7000458c:	693b      	ldr	r3, [r7, #16]
7000458e:	2b00      	cmp	r3, #0
70004590:	d004      	beq.n	7000459c <HAL_RCCEx_GetPeriphCLKFreq+0x1034>
70004592:	693b      	ldr	r3, [r7, #16]
70004594:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
70004598:	d00a      	beq.n	700045b0 <HAL_RCCEx_GetPeriphCLKFreq+0x1048>
          break;
7000459a:	e033      	b.n	70004604 <HAL_RCCEx_GetPeriphCLKFreq+0x109c>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
7000459c:	4b48      	ldr	r3, [pc, #288]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
7000459e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700045a0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
700045a4:	2b00      	cmp	r3, #0
700045a6:	d02f      	beq.n	70004608 <HAL_RCCEx_GetPeriphCLKFreq+0x10a0>
            frequency = HAL_RCC_GetPLL1QFreq();
700045a8:	f7fd fe6a 	bl	70002280 <HAL_RCC_GetPLL1QFreq>
700045ac:	6178      	str	r0, [r7, #20]
          break;
700045ae:	e02b      	b.n	70004608 <HAL_RCCEx_GetPeriphCLKFreq+0x10a0>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
700045b0:	4b43      	ldr	r3, [pc, #268]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700045b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700045b4:	f403 2380 	and.w	r3, r3, #262144	@ 0x40000
700045b8:	2b00      	cmp	r3, #0
700045ba:	d027      	beq.n	7000460c <HAL_RCCEx_GetPeriphCLKFreq+0x10a4>
            frequency = HAL_RCC_GetPLL2RFreq();
700045bc:	f7fd fea2 	bl	70002304 <HAL_RCC_GetPLL2RFreq>
700045c0:	6178      	str	r0, [r7, #20]
          break;
700045c2:	e023      	b.n	7000460c <HAL_RCCEx_GetPeriphCLKFreq+0x10a4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_RCLK) != 0U)
700045c4:	4b3e      	ldr	r3, [pc, #248]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700045c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700045c8:	f003 5300 	and.w	r3, r3, #536870912	@ 0x20000000
700045cc:	2b00      	cmp	r3, #0
700045ce:	d01f      	beq.n	70004610 <HAL_RCCEx_GetPeriphCLKFreq+0x10a8>
            frequency = HAL_RCC_GetPLL3RFreq();
700045d0:	f7fd ff08 	bl	700023e4 <HAL_RCC_GetPLL3RFreq>
700045d4:	6178      	str	r0, [r7, #20]
          break;
700045d6:	e01b      	b.n	70004610 <HAL_RCCEx_GetPeriphCLKFreq+0x10a8>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
700045d8:	4b39      	ldr	r3, [pc, #228]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700045da:	681b      	ldr	r3, [r3, #0]
700045dc:	f003 0304 	and.w	r3, r3, #4
700045e0:	2b00      	cmp	r3, #0
700045e2:	d017      	beq.n	70004614 <HAL_RCCEx_GetPeriphCLKFreq+0x10ac>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
700045e4:	4b36      	ldr	r3, [pc, #216]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700045e6:	681b      	ldr	r3, [r3, #0]
700045e8:	f003 0320 	and.w	r3, r3, #32
700045ec:	2b00      	cmp	r3, #0
700045ee:	d011      	beq.n	70004614 <HAL_RCCEx_GetPeriphCLKFreq+0x10ac>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
700045f0:	4b33      	ldr	r3, [pc, #204]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
700045f2:	681b      	ldr	r3, [r3, #0]
700045f4:	08db      	lsrs	r3, r3, #3
700045f6:	f003 0303 	and.w	r3, r3, #3
700045fa:	4a32      	ldr	r2, [pc, #200]	@ (700046c4 <HAL_RCCEx_GetPeriphCLKFreq+0x115c>)
700045fc:	fa22 f303 	lsr.w	r3, r2, r3
70004600:	617b      	str	r3, [r7, #20]
          break;
70004602:	e007      	b.n	70004614 <HAL_RCCEx_GetPeriphCLKFreq+0x10ac>
          break;
70004604:	bf00      	nop
70004606:	e2ea      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004608:	bf00      	nop
7000460a:	e2e8      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000460c:	bf00      	nop
7000460e:	e2e6      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004610:	bf00      	nop
70004612:	e2e4      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004614:	bf00      	nop
      break;
70004616:	e2e2      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SPI1_SOURCE();
70004618:	4b29      	ldr	r3, [pc, #164]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
7000461a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
7000461c:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
70004620:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70004622:	693b      	ldr	r3, [r7, #16]
70004624:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70004628:	d039      	beq.n	7000469e <HAL_RCCEx_GetPeriphCLKFreq+0x1136>
7000462a:	693b      	ldr	r3, [r7, #16]
7000462c:	f5b3 6f80 	cmp.w	r3, #1024	@ 0x400
70004630:	d83d      	bhi.n	700046ae <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
70004632:	693b      	ldr	r3, [r7, #16]
70004634:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70004638:	d035      	beq.n	700046a6 <HAL_RCCEx_GetPeriphCLKFreq+0x113e>
7000463a:	693b      	ldr	r3, [r7, #16]
7000463c:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70004640:	d835      	bhi.n	700046ae <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
70004642:	693b      	ldr	r3, [r7, #16]
70004644:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70004648:	d01f      	beq.n	7000468a <HAL_RCCEx_GetPeriphCLKFreq+0x1122>
7000464a:	693b      	ldr	r3, [r7, #16]
7000464c:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70004650:	d82d      	bhi.n	700046ae <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
70004652:	693b      	ldr	r3, [r7, #16]
70004654:	2b00      	cmp	r3, #0
70004656:	d004      	beq.n	70004662 <HAL_RCCEx_GetPeriphCLKFreq+0x10fa>
70004658:	693b      	ldr	r3, [r7, #16]
7000465a:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
7000465e:	d00a      	beq.n	70004676 <HAL_RCCEx_GetPeriphCLKFreq+0x110e>
          break;
70004660:	e025      	b.n	700046ae <HAL_RCCEx_GetPeriphCLKFreq+0x1146>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004662:	4b17      	ldr	r3, [pc, #92]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
70004664:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004666:	f003 0340 	and.w	r3, r3, #64	@ 0x40
7000466a:	2b00      	cmp	r3, #0
7000466c:	d021      	beq.n	700046b2 <HAL_RCCEx_GetPeriphCLKFreq+0x114a>
            frequency = HAL_RCC_GetPLL1QFreq();
7000466e:	f7fd fe07 	bl	70002280 <HAL_RCC_GetPLL1QFreq>
70004672:	6178      	str	r0, [r7, #20]
          break;
70004674:	e01d      	b.n	700046b2 <HAL_RCCEx_GetPeriphCLKFreq+0x114a>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70004676:	4b12      	ldr	r3, [pc, #72]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
70004678:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000467a:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
7000467e:	2b00      	cmp	r3, #0
70004680:	d019      	beq.n	700046b6 <HAL_RCCEx_GetPeriphCLKFreq+0x114e>
            frequency = HAL_RCC_GetPLL2PFreq();
70004682:	f7fd fe13 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70004686:	6178      	str	r0, [r7, #20]
          break;
70004688:	e015      	b.n	700046b6 <HAL_RCCEx_GetPeriphCLKFreq+0x114e>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
7000468a:	4b0d      	ldr	r3, [pc, #52]	@ (700046c0 <HAL_RCCEx_GetPeriphCLKFreq+0x1158>)
7000468c:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000468e:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
70004692:	2b00      	cmp	r3, #0
70004694:	d011      	beq.n	700046ba <HAL_RCCEx_GetPeriphCLKFreq+0x1152>
            frequency = HAL_RCC_GetPLL3PFreq();
70004696:	f7fd fe79 	bl	7000238c <HAL_RCC_GetPLL3PFreq>
7000469a:	6178      	str	r0, [r7, #20]
          break;
7000469c:	e00d      	b.n	700046ba <HAL_RCCEx_GetPeriphCLKFreq+0x1152>
          frequency = RCC_GetCLKPFreq();
7000469e:	f000 fab7 	bl	70004c10 <RCC_GetCLKPFreq>
700046a2:	6178      	str	r0, [r7, #20]
          break;
700046a4:	e00a      	b.n	700046bc <HAL_RCCEx_GetPeriphCLKFreq+0x1154>
          frequency = EXTERNAL_CLOCK_VALUE;
700046a6:	f64b 3380 	movw	r3, #48000	@ 0xbb80
700046aa:	617b      	str	r3, [r7, #20]
          break;
700046ac:	e006      	b.n	700046bc <HAL_RCCEx_GetPeriphCLKFreq+0x1154>
          break;
700046ae:	bf00      	nop
700046b0:	e295      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700046b2:	bf00      	nop
700046b4:	e293      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700046b6:	bf00      	nop
700046b8:	e291      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700046ba:	bf00      	nop
      break;
700046bc:	e28f      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
700046be:	bf00      	nop
700046c0:	58024400 	.word	0x58024400
700046c4:	03d09000 	.word	0x03d09000
      clocksource = __HAL_RCC_GET_SPI23_SOURCE();
700046c8:	4b92      	ldr	r3, [pc, #584]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700046ca:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
700046cc:	f003 0370 	and.w	r3, r3, #112	@ 0x70
700046d0:	613b      	str	r3, [r7, #16]
      switch (clocksource)
700046d2:	693b      	ldr	r3, [r7, #16]
700046d4:	2b40      	cmp	r3, #64	@ 0x40
700046d6:	d033      	beq.n	70004740 <HAL_RCCEx_GetPeriphCLKFreq+0x11d8>
700046d8:	693b      	ldr	r3, [r7, #16]
700046da:	2b40      	cmp	r3, #64	@ 0x40
700046dc:	d838      	bhi.n	70004750 <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
700046de:	693b      	ldr	r3, [r7, #16]
700046e0:	2b30      	cmp	r3, #48	@ 0x30
700046e2:	d031      	beq.n	70004748 <HAL_RCCEx_GetPeriphCLKFreq+0x11e0>
700046e4:	693b      	ldr	r3, [r7, #16]
700046e6:	2b30      	cmp	r3, #48	@ 0x30
700046e8:	d832      	bhi.n	70004750 <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
700046ea:	693b      	ldr	r3, [r7, #16]
700046ec:	2b20      	cmp	r3, #32
700046ee:	d01d      	beq.n	7000472c <HAL_RCCEx_GetPeriphCLKFreq+0x11c4>
700046f0:	693b      	ldr	r3, [r7, #16]
700046f2:	2b20      	cmp	r3, #32
700046f4:	d82c      	bhi.n	70004750 <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
700046f6:	693b      	ldr	r3, [r7, #16]
700046f8:	2b00      	cmp	r3, #0
700046fa:	d003      	beq.n	70004704 <HAL_RCCEx_GetPeriphCLKFreq+0x119c>
700046fc:	693b      	ldr	r3, [r7, #16]
700046fe:	2b10      	cmp	r3, #16
70004700:	d00a      	beq.n	70004718 <HAL_RCCEx_GetPeriphCLKFreq+0x11b0>
          break;
70004702:	e025      	b.n	70004750 <HAL_RCCEx_GetPeriphCLKFreq+0x11e8>
          if (__HAL_RCC_GET_PLL1CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004704:	4b83      	ldr	r3, [pc, #524]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
70004706:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004708:	f003 0340 	and.w	r3, r3, #64	@ 0x40
7000470c:	2b00      	cmp	r3, #0
7000470e:	d021      	beq.n	70004754 <HAL_RCCEx_GetPeriphCLKFreq+0x11ec>
            frequency = HAL_RCC_GetPLL1QFreq();
70004710:	f7fd fdb6 	bl	70002280 <HAL_RCC_GetPLL1QFreq>
70004714:	6178      	str	r0, [r7, #20]
          break;
70004716:	e01d      	b.n	70004754 <HAL_RCCEx_GetPeriphCLKFreq+0x11ec>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
70004718:	4b7e      	ldr	r3, [pc, #504]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
7000471a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000471c:	f403 3380 	and.w	r3, r3, #65536	@ 0x10000
70004720:	2b00      	cmp	r3, #0
70004722:	d019      	beq.n	70004758 <HAL_RCCEx_GetPeriphCLKFreq+0x11f0>
            frequency = HAL_RCC_GetPLL2PFreq();
70004724:	f7fd fdc2 	bl	700022ac <HAL_RCC_GetPLL2PFreq>
70004728:	6178      	str	r0, [r7, #20]
          break;
7000472a:	e015      	b.n	70004758 <HAL_RCCEx_GetPeriphCLKFreq+0x11f0>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_PCLK) != 0U)
7000472c:	4b79      	ldr	r3, [pc, #484]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
7000472e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004730:	f003 6300 	and.w	r3, r3, #134217728	@ 0x8000000
70004734:	2b00      	cmp	r3, #0
70004736:	d011      	beq.n	7000475c <HAL_RCCEx_GetPeriphCLKFreq+0x11f4>
            frequency = HAL_RCC_GetPLL3PFreq();
70004738:	f7fd fe28 	bl	7000238c <HAL_RCC_GetPLL3PFreq>
7000473c:	6178      	str	r0, [r7, #20]
          break;
7000473e:	e00d      	b.n	7000475c <HAL_RCCEx_GetPeriphCLKFreq+0x11f4>
          frequency = RCC_GetCLKPFreq();
70004740:	f000 fa66 	bl	70004c10 <RCC_GetCLKPFreq>
70004744:	6178      	str	r0, [r7, #20]
          break;
70004746:	e00a      	b.n	7000475e <HAL_RCCEx_GetPeriphCLKFreq+0x11f6>
          frequency = EXTERNAL_CLOCK_VALUE;
70004748:	f64b 3380 	movw	r3, #48000	@ 0xbb80
7000474c:	617b      	str	r3, [r7, #20]
          break;
7000474e:	e006      	b.n	7000475e <HAL_RCCEx_GetPeriphCLKFreq+0x11f6>
          break;
70004750:	bf00      	nop
70004752:	e244      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004754:	bf00      	nop
70004756:	e242      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004758:	bf00      	nop
7000475a:	e240      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000475c:	bf00      	nop
      break;
7000475e:	e23e      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SPI45_SOURCE();
70004760:	4b6c      	ldr	r3, [pc, #432]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
70004762:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70004764:	f003 0370 	and.w	r3, r3, #112	@ 0x70
70004768:	613b      	str	r3, [r7, #16]
      switch (clocksource)
7000476a:	693b      	ldr	r3, [r7, #16]
7000476c:	2b50      	cmp	r3, #80	@ 0x50
7000476e:	d052      	beq.n	70004816 <HAL_RCCEx_GetPeriphCLKFreq+0x12ae>
70004770:	693b      	ldr	r3, [r7, #16]
70004772:	2b50      	cmp	r3, #80	@ 0x50
70004774:	d858      	bhi.n	70004828 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
70004776:	693b      	ldr	r3, [r7, #16]
70004778:	2b40      	cmp	r3, #64	@ 0x40
7000477a:	d043      	beq.n	70004804 <HAL_RCCEx_GetPeriphCLKFreq+0x129c>
7000477c:	693b      	ldr	r3, [r7, #16]
7000477e:	2b40      	cmp	r3, #64	@ 0x40
70004780:	d852      	bhi.n	70004828 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
70004782:	693b      	ldr	r3, [r7, #16]
70004784:	2b30      	cmp	r3, #48	@ 0x30
70004786:	d027      	beq.n	700047d8 <HAL_RCCEx_GetPeriphCLKFreq+0x1270>
70004788:	693b      	ldr	r3, [r7, #16]
7000478a:	2b30      	cmp	r3, #48	@ 0x30
7000478c:	d84c      	bhi.n	70004828 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
7000478e:	693b      	ldr	r3, [r7, #16]
70004790:	2b20      	cmp	r3, #32
70004792:	d017      	beq.n	700047c4 <HAL_RCCEx_GetPeriphCLKFreq+0x125c>
70004794:	693b      	ldr	r3, [r7, #16]
70004796:	2b20      	cmp	r3, #32
70004798:	d846      	bhi.n	70004828 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
7000479a:	693b      	ldr	r3, [r7, #16]
7000479c:	2b00      	cmp	r3, #0
7000479e:	d003      	beq.n	700047a8 <HAL_RCCEx_GetPeriphCLKFreq+0x1240>
700047a0:	693b      	ldr	r3, [r7, #16]
700047a2:	2b10      	cmp	r3, #16
700047a4:	d004      	beq.n	700047b0 <HAL_RCCEx_GetPeriphCLKFreq+0x1248>
          break;
700047a6:	e03f      	b.n	70004828 <HAL_RCCEx_GetPeriphCLKFreq+0x12c0>
          frequency = HAL_RCC_GetPCLK2Freq();
700047a8:	f7fd fd32 	bl	70002210 <HAL_RCC_GetPCLK2Freq>
700047ac:	6178      	str	r0, [r7, #20]
          break;
700047ae:	e046      	b.n	7000483e <HAL_RCCEx_GetPeriphCLKFreq+0x12d6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
700047b0:	4b58      	ldr	r3, [pc, #352]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700047b2:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700047b4:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
700047b8:	2b00      	cmp	r3, #0
700047ba:	d037      	beq.n	7000482c <HAL_RCCEx_GetPeriphCLKFreq+0x12c4>
            frequency = HAL_RCC_GetPLL2QFreq();
700047bc:	f7fd fd8c 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
700047c0:	6178      	str	r0, [r7, #20]
          break;
700047c2:	e033      	b.n	7000482c <HAL_RCCEx_GetPeriphCLKFreq+0x12c4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
700047c4:	4b53      	ldr	r3, [pc, #332]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700047c6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700047c8:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
700047cc:	2b00      	cmp	r3, #0
700047ce:	d02f      	beq.n	70004830 <HAL_RCCEx_GetPeriphCLKFreq+0x12c8>
            frequency = HAL_RCC_GetPLL3QFreq();
700047d0:	f7fd fdf2 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
700047d4:	6178      	str	r0, [r7, #20]
          break;
700047d6:	e02b      	b.n	70004830 <HAL_RCCEx_GetPeriphCLKFreq+0x12c8>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
700047d8:	4b4e      	ldr	r3, [pc, #312]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700047da:	681b      	ldr	r3, [r3, #0]
700047dc:	f003 0304 	and.w	r3, r3, #4
700047e0:	2b00      	cmp	r3, #0
700047e2:	d027      	beq.n	70004834 <HAL_RCCEx_GetPeriphCLKFreq+0x12cc>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
700047e4:	4b4b      	ldr	r3, [pc, #300]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700047e6:	681b      	ldr	r3, [r3, #0]
700047e8:	f003 0320 	and.w	r3, r3, #32
700047ec:	2b00      	cmp	r3, #0
700047ee:	d021      	beq.n	70004834 <HAL_RCCEx_GetPeriphCLKFreq+0x12cc>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
700047f0:	4b48      	ldr	r3, [pc, #288]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700047f2:	681b      	ldr	r3, [r3, #0]
700047f4:	08db      	lsrs	r3, r3, #3
700047f6:	f003 0303 	and.w	r3, r3, #3
700047fa:	4a47      	ldr	r2, [pc, #284]	@ (70004918 <HAL_RCCEx_GetPeriphCLKFreq+0x13b0>)
700047fc:	fa22 f303 	lsr.w	r3, r2, r3
70004800:	617b      	str	r3, [r7, #20]
          break;
70004802:	e017      	b.n	70004834 <HAL_RCCEx_GetPeriphCLKFreq+0x12cc>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70004804:	4b43      	ldr	r3, [pc, #268]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
70004806:	681b      	ldr	r3, [r3, #0]
70004808:	f403 7380 	and.w	r3, r3, #256	@ 0x100
7000480c:	2b00      	cmp	r3, #0
7000480e:	d013      	beq.n	70004838 <HAL_RCCEx_GetPeriphCLKFreq+0x12d0>
            frequency = CSI_VALUE;
70004810:	4b42      	ldr	r3, [pc, #264]	@ (7000491c <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
70004812:	617b      	str	r3, [r7, #20]
          break;
70004814:	e010      	b.n	70004838 <HAL_RCCEx_GetPeriphCLKFreq+0x12d0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70004816:	4b3f      	ldr	r3, [pc, #252]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
70004818:	681b      	ldr	r3, [r3, #0]
7000481a:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
7000481e:	2b00      	cmp	r3, #0
70004820:	d00c      	beq.n	7000483c <HAL_RCCEx_GetPeriphCLKFreq+0x12d4>
            frequency = HSE_VALUE;
70004822:	4b3f      	ldr	r3, [pc, #252]	@ (70004920 <HAL_RCCEx_GetPeriphCLKFreq+0x13b8>)
70004824:	617b      	str	r3, [r7, #20]
          break;
70004826:	e009      	b.n	7000483c <HAL_RCCEx_GetPeriphCLKFreq+0x12d4>
          break;
70004828:	bf00      	nop
7000482a:	e1d8      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000482c:	bf00      	nop
7000482e:	e1d6      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004830:	bf00      	nop
70004832:	e1d4      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004834:	bf00      	nop
70004836:	e1d2      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004838:	bf00      	nop
7000483a:	e1d0      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000483c:	bf00      	nop
      break;
7000483e:	e1ce      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_SPI6_SOURCE();
70004840:	4b34      	ldr	r3, [pc, #208]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
70004842:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
70004844:	f003 0370 	and.w	r3, r3, #112	@ 0x70
70004848:	613b      	str	r3, [r7, #16]
      switch (clocksource)
7000484a:	693b      	ldr	r3, [r7, #16]
7000484c:	2b50      	cmp	r3, #80	@ 0x50
7000484e:	d052      	beq.n	700048f6 <HAL_RCCEx_GetPeriphCLKFreq+0x138e>
70004850:	693b      	ldr	r3, [r7, #16]
70004852:	2b50      	cmp	r3, #80	@ 0x50
70004854:	d858      	bhi.n	70004908 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
70004856:	693b      	ldr	r3, [r7, #16]
70004858:	2b40      	cmp	r3, #64	@ 0x40
7000485a:	d043      	beq.n	700048e4 <HAL_RCCEx_GetPeriphCLKFreq+0x137c>
7000485c:	693b      	ldr	r3, [r7, #16]
7000485e:	2b40      	cmp	r3, #64	@ 0x40
70004860:	d852      	bhi.n	70004908 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
70004862:	693b      	ldr	r3, [r7, #16]
70004864:	2b30      	cmp	r3, #48	@ 0x30
70004866:	d027      	beq.n	700048b8 <HAL_RCCEx_GetPeriphCLKFreq+0x1350>
70004868:	693b      	ldr	r3, [r7, #16]
7000486a:	2b30      	cmp	r3, #48	@ 0x30
7000486c:	d84c      	bhi.n	70004908 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
7000486e:	693b      	ldr	r3, [r7, #16]
70004870:	2b20      	cmp	r3, #32
70004872:	d017      	beq.n	700048a4 <HAL_RCCEx_GetPeriphCLKFreq+0x133c>
70004874:	693b      	ldr	r3, [r7, #16]
70004876:	2b20      	cmp	r3, #32
70004878:	d846      	bhi.n	70004908 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
7000487a:	693b      	ldr	r3, [r7, #16]
7000487c:	2b00      	cmp	r3, #0
7000487e:	d003      	beq.n	70004888 <HAL_RCCEx_GetPeriphCLKFreq+0x1320>
70004880:	693b      	ldr	r3, [r7, #16]
70004882:	2b10      	cmp	r3, #16
70004884:	d004      	beq.n	70004890 <HAL_RCCEx_GetPeriphCLKFreq+0x1328>
          break;
70004886:	e03f      	b.n	70004908 <HAL_RCCEx_GetPeriphCLKFreq+0x13a0>
          frequency = HAL_RCC_GetPCLK4Freq();
70004888:	f7fd fcde 	bl	70002248 <HAL_RCC_GetPCLK4Freq>
7000488c:	6178      	str	r0, [r7, #20]
          break;
7000488e:	e04e      	b.n	7000492e <HAL_RCCEx_GetPeriphCLKFreq+0x13c6>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004890:	4b20      	ldr	r3, [pc, #128]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
70004892:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004894:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70004898:	2b00      	cmp	r3, #0
7000489a:	d037      	beq.n	7000490c <HAL_RCCEx_GetPeriphCLKFreq+0x13a4>
            frequency = HAL_RCC_GetPLL2QFreq();
7000489c:	f7fd fd1c 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
700048a0:	6178      	str	r0, [r7, #20]
          break;
700048a2:	e033      	b.n	7000490c <HAL_RCCEx_GetPeriphCLKFreq+0x13a4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
700048a4:	4b1b      	ldr	r3, [pc, #108]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700048a6:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
700048a8:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
700048ac:	2b00      	cmp	r3, #0
700048ae:	d02f      	beq.n	70004910 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
            frequency = HAL_RCC_GetPLL3QFreq();
700048b0:	f7fd fd82 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
700048b4:	6178      	str	r0, [r7, #20]
          break;
700048b6:	e02b      	b.n	70004910 <HAL_RCCEx_GetPeriphCLKFreq+0x13a8>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
700048b8:	4b16      	ldr	r3, [pc, #88]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700048ba:	681b      	ldr	r3, [r3, #0]
700048bc:	f003 0304 	and.w	r3, r3, #4
700048c0:	2b00      	cmp	r3, #0
700048c2:	d02f      	beq.n	70004924 <HAL_RCCEx_GetPeriphCLKFreq+0x13bc>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
700048c4:	4b13      	ldr	r3, [pc, #76]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700048c6:	681b      	ldr	r3, [r3, #0]
700048c8:	f003 0320 	and.w	r3, r3, #32
700048cc:	2b00      	cmp	r3, #0
700048ce:	d029      	beq.n	70004924 <HAL_RCCEx_GetPeriphCLKFreq+0x13bc>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
700048d0:	4b10      	ldr	r3, [pc, #64]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700048d2:	681b      	ldr	r3, [r3, #0]
700048d4:	08db      	lsrs	r3, r3, #3
700048d6:	f003 0303 	and.w	r3, r3, #3
700048da:	4a0f      	ldr	r2, [pc, #60]	@ (70004918 <HAL_RCCEx_GetPeriphCLKFreq+0x13b0>)
700048dc:	fa22 f303 	lsr.w	r3, r2, r3
700048e0:	617b      	str	r3, [r7, #20]
          break;
700048e2:	e01f      	b.n	70004924 <HAL_RCCEx_GetPeriphCLKFreq+0x13bc>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
700048e4:	4b0b      	ldr	r3, [pc, #44]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700048e6:	681b      	ldr	r3, [r3, #0]
700048e8:	f403 7380 	and.w	r3, r3, #256	@ 0x100
700048ec:	2b00      	cmp	r3, #0
700048ee:	d01b      	beq.n	70004928 <HAL_RCCEx_GetPeriphCLKFreq+0x13c0>
            frequency = CSI_VALUE;
700048f0:	4b0a      	ldr	r3, [pc, #40]	@ (7000491c <HAL_RCCEx_GetPeriphCLKFreq+0x13b4>)
700048f2:	617b      	str	r3, [r7, #20]
          break;
700048f4:	e018      	b.n	70004928 <HAL_RCCEx_GetPeriphCLKFreq+0x13c0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
700048f6:	4b07      	ldr	r3, [pc, #28]	@ (70004914 <HAL_RCCEx_GetPeriphCLKFreq+0x13ac>)
700048f8:	681b      	ldr	r3, [r3, #0]
700048fa:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
700048fe:	2b00      	cmp	r3, #0
70004900:	d014      	beq.n	7000492c <HAL_RCCEx_GetPeriphCLKFreq+0x13c4>
            frequency = HSE_VALUE;
70004902:	4b07      	ldr	r3, [pc, #28]	@ (70004920 <HAL_RCCEx_GetPeriphCLKFreq+0x13b8>)
70004904:	617b      	str	r3, [r7, #20]
          break;
70004906:	e011      	b.n	7000492c <HAL_RCCEx_GetPeriphCLKFreq+0x13c4>
          break;
70004908:	bf00      	nop
7000490a:	e168      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000490c:	bf00      	nop
7000490e:	e166      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004910:	bf00      	nop
70004912:	e164      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
70004914:	58024400 	.word	0x58024400
70004918:	03d09000 	.word	0x03d09000
7000491c:	003d0900 	.word	0x003d0900
70004920:	016e3600 	.word	0x016e3600
          break;
70004924:	bf00      	nop
70004926:	e15a      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004928:	bf00      	nop
7000492a:	e158      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
7000492c:	bf00      	nop
      break;
7000492e:	e156      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USART1_SOURCE();
70004930:	4b9e      	ldr	r3, [pc, #632]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004932:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70004934:	f003 0307 	and.w	r3, r3, #7
70004938:	613b      	str	r3, [r7, #16]
      switch (clocksource)
7000493a:	693b      	ldr	r3, [r7, #16]
7000493c:	2b05      	cmp	r3, #5
7000493e:	d850      	bhi.n	700049e2 <HAL_RCCEx_GetPeriphCLKFreq+0x147a>
70004940:	a201      	add	r2, pc, #4	@ (adr r2, 70004948 <HAL_RCCEx_GetPeriphCLKFreq+0x13e0>)
70004942:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70004946:	bf00      	nop
70004948:	70004961 	.word	0x70004961
7000494c:	70004969 	.word	0x70004969
70004950:	7000497d 	.word	0x7000497d
70004954:	70004991 	.word	0x70004991
70004958:	700049bd 	.word	0x700049bd
7000495c:	700049cf 	.word	0x700049cf
          frequency = HAL_RCC_GetPCLK2Freq();
70004960:	f7fd fc56 	bl	70002210 <HAL_RCC_GetPCLK2Freq>
70004964:	6178      	str	r0, [r7, #20]
          break;
70004966:	e047      	b.n	700049f8 <HAL_RCCEx_GetPeriphCLKFreq+0x1490>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004968:	4b90      	ldr	r3, [pc, #576]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
7000496a:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
7000496c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70004970:	2b00      	cmp	r3, #0
70004972:	d038      	beq.n	700049e6 <HAL_RCCEx_GetPeriphCLKFreq+0x147e>
            frequency = HAL_RCC_GetPLL2QFreq();
70004974:	f7fd fcb0 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
70004978:	6178      	str	r0, [r7, #20]
          break;
7000497a:	e034      	b.n	700049e6 <HAL_RCCEx_GetPeriphCLKFreq+0x147e>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
7000497c:	4b8b      	ldr	r3, [pc, #556]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
7000497e:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004980:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
70004984:	2b00      	cmp	r3, #0
70004986:	d030      	beq.n	700049ea <HAL_RCCEx_GetPeriphCLKFreq+0x1482>
            frequency = HAL_RCC_GetPLL3QFreq();
70004988:	f7fd fd16 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
7000498c:	6178      	str	r0, [r7, #20]
          break;
7000498e:	e02c      	b.n	700049ea <HAL_RCCEx_GetPeriphCLKFreq+0x1482>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
70004990:	4b86      	ldr	r3, [pc, #536]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004992:	681b      	ldr	r3, [r3, #0]
70004994:	f003 0304 	and.w	r3, r3, #4
70004998:	2b00      	cmp	r3, #0
7000499a:	d028      	beq.n	700049ee <HAL_RCCEx_GetPeriphCLKFreq+0x1486>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
7000499c:	4b83      	ldr	r3, [pc, #524]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
7000499e:	681b      	ldr	r3, [r3, #0]
700049a0:	f003 0320 	and.w	r3, r3, #32
700049a4:	2b00      	cmp	r3, #0
700049a6:	d022      	beq.n	700049ee <HAL_RCCEx_GetPeriphCLKFreq+0x1486>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
700049a8:	4b80      	ldr	r3, [pc, #512]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
700049aa:	681b      	ldr	r3, [r3, #0]
700049ac:	08db      	lsrs	r3, r3, #3
700049ae:	f003 0303 	and.w	r3, r3, #3
700049b2:	4a7f      	ldr	r2, [pc, #508]	@ (70004bb0 <HAL_RCCEx_GetPeriphCLKFreq+0x1648>)
700049b4:	fa22 f303 	lsr.w	r3, r2, r3
700049b8:	617b      	str	r3, [r7, #20]
          break;
700049ba:	e018      	b.n	700049ee <HAL_RCCEx_GetPeriphCLKFreq+0x1486>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
700049bc:	4b7b      	ldr	r3, [pc, #492]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
700049be:	681b      	ldr	r3, [r3, #0]
700049c0:	f403 7380 	and.w	r3, r3, #256	@ 0x100
700049c4:	2b00      	cmp	r3, #0
700049c6:	d014      	beq.n	700049f2 <HAL_RCCEx_GetPeriphCLKFreq+0x148a>
            frequency = CSI_VALUE;
700049c8:	4b7a      	ldr	r3, [pc, #488]	@ (70004bb4 <HAL_RCCEx_GetPeriphCLKFreq+0x164c>)
700049ca:	617b      	str	r3, [r7, #20]
          break;
700049cc:	e011      	b.n	700049f2 <HAL_RCCEx_GetPeriphCLKFreq+0x148a>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
700049ce:	4b77      	ldr	r3, [pc, #476]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
700049d0:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
700049d2:	f003 0302 	and.w	r3, r3, #2
700049d6:	2b00      	cmp	r3, #0
700049d8:	d00d      	beq.n	700049f6 <HAL_RCCEx_GetPeriphCLKFreq+0x148e>
            frequency = LSE_VALUE;
700049da:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
700049de:	617b      	str	r3, [r7, #20]
          break;
700049e0:	e009      	b.n	700049f6 <HAL_RCCEx_GetPeriphCLKFreq+0x148e>
          break;
700049e2:	bf00      	nop
700049e4:	e0fb      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700049e6:	bf00      	nop
700049e8:	e0f9      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700049ea:	bf00      	nop
700049ec:	e0f7      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700049ee:	bf00      	nop
700049f0:	e0f5      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700049f2:	bf00      	nop
700049f4:	e0f3      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
700049f6:	bf00      	nop
      break;
700049f8:	e0f1      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USART234578_SOURCE();
700049fa:	4b6c      	ldr	r3, [pc, #432]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
700049fc:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
700049fe:	f003 0307 	and.w	r3, r3, #7
70004a02:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70004a04:	693b      	ldr	r3, [r7, #16]
70004a06:	2b05      	cmp	r3, #5
70004a08:	d84f      	bhi.n	70004aaa <HAL_RCCEx_GetPeriphCLKFreq+0x1542>
70004a0a:	a201      	add	r2, pc, #4	@ (adr r2, 70004a10 <HAL_RCCEx_GetPeriphCLKFreq+0x14a8>)
70004a0c:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70004a10:	70004a29 	.word	0x70004a29
70004a14:	70004a31 	.word	0x70004a31
70004a18:	70004a45 	.word	0x70004a45
70004a1c:	70004a59 	.word	0x70004a59
70004a20:	70004a85 	.word	0x70004a85
70004a24:	70004a97 	.word	0x70004a97
          frequency = HAL_RCC_GetPCLK1Freq();
70004a28:	f7fd fbd6 	bl	700021d8 <HAL_RCC_GetPCLK1Freq>
70004a2c:	6178      	str	r0, [r7, #20]
          break;
70004a2e:	e047      	b.n	70004ac0 <HAL_RCCEx_GetPeriphCLKFreq+0x1558>
          if (__HAL_RCC_GET_PLL2CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004a30:	4b5e      	ldr	r3, [pc, #376]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004a32:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004a34:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70004a38:	2b00      	cmp	r3, #0
70004a3a:	d038      	beq.n	70004aae <HAL_RCCEx_GetPeriphCLKFreq+0x1546>
            frequency = HAL_RCC_GetPLL2QFreq();
70004a3c:	f7fd fc4c 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
70004a40:	6178      	str	r0, [r7, #20]
          break;
70004a42:	e034      	b.n	70004aae <HAL_RCCEx_GetPeriphCLKFreq+0x1546>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004a44:	4b59      	ldr	r3, [pc, #356]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004a46:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004a48:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
70004a4c:	2b00      	cmp	r3, #0
70004a4e:	d030      	beq.n	70004ab2 <HAL_RCCEx_GetPeriphCLKFreq+0x154a>
            frequency = HAL_RCC_GetPLL3QFreq();
70004a50:	f7fd fcb2 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
70004a54:	6178      	str	r0, [r7, #20]
          break;
70004a56:	e02c      	b.n	70004ab2 <HAL_RCCEx_GetPeriphCLKFreq+0x154a>
          if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
70004a58:	4b54      	ldr	r3, [pc, #336]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004a5a:	681b      	ldr	r3, [r3, #0]
70004a5c:	f003 0304 	and.w	r3, r3, #4
70004a60:	2b00      	cmp	r3, #0
70004a62:	d028      	beq.n	70004ab6 <HAL_RCCEx_GetPeriphCLKFreq+0x154e>
            if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70004a64:	4b51      	ldr	r3, [pc, #324]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004a66:	681b      	ldr	r3, [r3, #0]
70004a68:	f003 0320 	and.w	r3, r3, #32
70004a6c:	2b00      	cmp	r3, #0
70004a6e:	d022      	beq.n	70004ab6 <HAL_RCCEx_GetPeriphCLKFreq+0x154e>
              frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70004a70:	4b4e      	ldr	r3, [pc, #312]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004a72:	681b      	ldr	r3, [r3, #0]
70004a74:	08db      	lsrs	r3, r3, #3
70004a76:	f003 0303 	and.w	r3, r3, #3
70004a7a:	4a4d      	ldr	r2, [pc, #308]	@ (70004bb0 <HAL_RCCEx_GetPeriphCLKFreq+0x1648>)
70004a7c:	fa22 f303 	lsr.w	r3, r2, r3
70004a80:	617b      	str	r3, [r7, #20]
          break;
70004a82:	e018      	b.n	70004ab6 <HAL_RCCEx_GetPeriphCLKFreq+0x154e>
          if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70004a84:	4b49      	ldr	r3, [pc, #292]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004a86:	681b      	ldr	r3, [r3, #0]
70004a88:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70004a8c:	2b00      	cmp	r3, #0
70004a8e:	d014      	beq.n	70004aba <HAL_RCCEx_GetPeriphCLKFreq+0x1552>
            frequency = CSI_VALUE;
70004a90:	4b48      	ldr	r3, [pc, #288]	@ (70004bb4 <HAL_RCCEx_GetPeriphCLKFreq+0x164c>)
70004a92:	617b      	str	r3, [r7, #20]
          break;
70004a94:	e011      	b.n	70004aba <HAL_RCCEx_GetPeriphCLKFreq+0x1552>
          if (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
70004a96:	4b45      	ldr	r3, [pc, #276]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004a98:	6f1b      	ldr	r3, [r3, #112]	@ 0x70
70004a9a:	f003 0302 	and.w	r3, r3, #2
70004a9e:	2b00      	cmp	r3, #0
70004aa0:	d00d      	beq.n	70004abe <HAL_RCCEx_GetPeriphCLKFreq+0x1556>
            frequency = LSE_VALUE;
70004aa2:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
70004aa6:	617b      	str	r3, [r7, #20]
          break;
70004aa8:	e009      	b.n	70004abe <HAL_RCCEx_GetPeriphCLKFreq+0x1556>
          break;
70004aaa:	bf00      	nop
70004aac:	e097      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004aae:	bf00      	nop
70004ab0:	e095      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004ab2:	bf00      	nop
70004ab4:	e093      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004ab6:	bf00      	nop
70004ab8:	e091      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004aba:	bf00      	nop
70004abc:	e08f      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004abe:	bf00      	nop
      break;
70004ac0:	e08d      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USBPHYC_SOURCE();
70004ac2:	4b3a      	ldr	r3, [pc, #232]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004ac4:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70004ac6:	f403 5340 	and.w	r3, r3, #12288	@ 0x3000
70004aca:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70004acc:	693b      	ldr	r3, [r7, #16]
70004ace:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70004ad2:	d01d      	beq.n	70004b10 <HAL_RCCEx_GetPeriphCLKFreq+0x15a8>
70004ad4:	693b      	ldr	r3, [r7, #16]
70004ad6:	f5b3 5f00 	cmp.w	r3, #8192	@ 0x2000
70004ada:	d823      	bhi.n	70004b24 <HAL_RCCEx_GetPeriphCLKFreq+0x15bc>
70004adc:	693b      	ldr	r3, [r7, #16]
70004ade:	2b00      	cmp	r3, #0
70004ae0:	d004      	beq.n	70004aec <HAL_RCCEx_GetPeriphCLKFreq+0x1584>
70004ae2:	693b      	ldr	r3, [r7, #16]
70004ae4:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
70004ae8:	d009      	beq.n	70004afe <HAL_RCCEx_GetPeriphCLKFreq+0x1596>
          break;
70004aea:	e01b      	b.n	70004b24 <HAL_RCCEx_GetPeriphCLKFreq+0x15bc>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70004aec:	4b2f      	ldr	r3, [pc, #188]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004aee:	681b      	ldr	r3, [r3, #0]
70004af0:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70004af4:	2b00      	cmp	r3, #0
70004af6:	d017      	beq.n	70004b28 <HAL_RCCEx_GetPeriphCLKFreq+0x15c0>
            frequency = HSE_VALUE;
70004af8:	4b2f      	ldr	r3, [pc, #188]	@ (70004bb8 <HAL_RCCEx_GetPeriphCLKFreq+0x1650>)
70004afa:	617b      	str	r3, [r7, #20]
          break;
70004afc:	e014      	b.n	70004b28 <HAL_RCCEx_GetPeriphCLKFreq+0x15c0>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70004afe:	4b2b      	ldr	r3, [pc, #172]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004b00:	681b      	ldr	r3, [r3, #0]
70004b02:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70004b06:	2b00      	cmp	r3, #0
70004b08:	d010      	beq.n	70004b2c <HAL_RCCEx_GetPeriphCLKFreq+0x15c4>
            frequency = (HSE_VALUE >> 1UL);
70004b0a:	4b2c      	ldr	r3, [pc, #176]	@ (70004bbc <HAL_RCCEx_GetPeriphCLKFreq+0x1654>)
70004b0c:	617b      	str	r3, [r7, #20]
          break;
70004b0e:	e00d      	b.n	70004b2c <HAL_RCCEx_GetPeriphCLKFreq+0x15c4>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004b10:	4b26      	ldr	r3, [pc, #152]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004b12:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004b14:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
70004b18:	2b00      	cmp	r3, #0
70004b1a:	d009      	beq.n	70004b30 <HAL_RCCEx_GetPeriphCLKFreq+0x15c8>
            frequency = HAL_RCC_GetPLL3QFreq();
70004b1c:	f7fd fc4c 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
70004b20:	6178      	str	r0, [r7, #20]
          break;
70004b22:	e005      	b.n	70004b30 <HAL_RCCEx_GetPeriphCLKFreq+0x15c8>
          break;
70004b24:	bf00      	nop
70004b26:	e05a      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004b28:	bf00      	nop
70004b2a:	e058      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004b2c:	bf00      	nop
70004b2e:	e056      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004b30:	bf00      	nop
      break;
70004b32:	e054      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      clocksource = __HAL_RCC_GET_USBOTGFS_SOURCE();
70004b34:	4b1d      	ldr	r3, [pc, #116]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004b36:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70004b38:	f403 4340 	and.w	r3, r3, #49152	@ 0xc000
70004b3c:	613b      	str	r3, [r7, #16]
      switch (clocksource)
70004b3e:	693b      	ldr	r3, [r7, #16]
70004b40:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
70004b44:	d02f      	beq.n	70004ba6 <HAL_RCCEx_GetPeriphCLKFreq+0x163e>
70004b46:	693b      	ldr	r3, [r7, #16]
70004b48:	f5b3 4f40 	cmp.w	r3, #49152	@ 0xc000
70004b4c:	d83a      	bhi.n	70004bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x165c>
70004b4e:	693b      	ldr	r3, [r7, #16]
70004b50:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
70004b54:	d01e      	beq.n	70004b94 <HAL_RCCEx_GetPeriphCLKFreq+0x162c>
70004b56:	693b      	ldr	r3, [r7, #16]
70004b58:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
70004b5c:	d832      	bhi.n	70004bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x165c>
70004b5e:	693b      	ldr	r3, [r7, #16]
70004b60:	2b00      	cmp	r3, #0
70004b62:	d004      	beq.n	70004b6e <HAL_RCCEx_GetPeriphCLKFreq+0x1606>
70004b64:	693b      	ldr	r3, [r7, #16]
70004b66:	f5b3 4f80 	cmp.w	r3, #16384	@ 0x4000
70004b6a:	d009      	beq.n	70004b80 <HAL_RCCEx_GetPeriphCLKFreq+0x1618>
          break;
70004b6c:	e02a      	b.n	70004bc4 <HAL_RCCEx_GetPeriphCLKFreq+0x165c>
          if (READ_BIT(RCC->CR, RCC_CR_HSI48RDY) != 0U)
70004b6e:	4b0f      	ldr	r3, [pc, #60]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004b70:	681b      	ldr	r3, [r3, #0]
70004b72:	f403 5300 	and.w	r3, r3, #8192	@ 0x2000
70004b76:	2b00      	cmp	r3, #0
70004b78:	d026      	beq.n	70004bc8 <HAL_RCCEx_GetPeriphCLKFreq+0x1660>
            frequency = HSI48_VALUE;
70004b7a:	4b11      	ldr	r3, [pc, #68]	@ (70004bc0 <HAL_RCCEx_GetPeriphCLKFreq+0x1658>)
70004b7c:	617b      	str	r3, [r7, #20]
          break;
70004b7e:	e023      	b.n	70004bc8 <HAL_RCCEx_GetPeriphCLKFreq+0x1660>
          if (__HAL_RCC_GET_PLL3CLKOUT_CONFIG(RCC_PLL_QCLK) != 0U)
70004b80:	4b0a      	ldr	r3, [pc, #40]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004b82:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004b84:	f003 5380 	and.w	r3, r3, #268435456	@ 0x10000000
70004b88:	2b00      	cmp	r3, #0
70004b8a:	d01f      	beq.n	70004bcc <HAL_RCCEx_GetPeriphCLKFreq+0x1664>
            frequency = HAL_RCC_GetPLL3QFreq();
70004b8c:	f7fd fc14 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
70004b90:	6178      	str	r0, [r7, #20]
          break;
70004b92:	e01b      	b.n	70004bcc <HAL_RCCEx_GetPeriphCLKFreq+0x1664>
          if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70004b94:	4b05      	ldr	r3, [pc, #20]	@ (70004bac <HAL_RCCEx_GetPeriphCLKFreq+0x1644>)
70004b96:	681b      	ldr	r3, [r3, #0]
70004b98:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70004b9c:	2b00      	cmp	r3, #0
70004b9e:	d017      	beq.n	70004bd0 <HAL_RCCEx_GetPeriphCLKFreq+0x1668>
            frequency = HSE_VALUE;
70004ba0:	4b05      	ldr	r3, [pc, #20]	@ (70004bb8 <HAL_RCCEx_GetPeriphCLKFreq+0x1650>)
70004ba2:	617b      	str	r3, [r7, #20]
          break;
70004ba4:	e014      	b.n	70004bd0 <HAL_RCCEx_GetPeriphCLKFreq+0x1668>
          break;
70004ba6:	bf00      	nop
70004ba8:	e019      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
70004baa:	bf00      	nop
70004bac:	58024400 	.word	0x58024400
70004bb0:	03d09000 	.word	0x03d09000
70004bb4:	003d0900 	.word	0x003d0900
70004bb8:	016e3600 	.word	0x016e3600
70004bbc:	00b71b00 	.word	0x00b71b00
70004bc0:	02dc6c00 	.word	0x02dc6c00
          break;
70004bc4:	bf00      	nop
70004bc6:	e00a      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004bc8:	bf00      	nop
70004bca:	e008      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004bcc:	bf00      	nop
70004bce:	e006      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
          break;
70004bd0:	bf00      	nop
      break;
70004bd2:	e004      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      break;
70004bd4:	bf00      	nop
70004bd6:	e002      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      break;
70004bd8:	bf00      	nop
70004bda:	e000      	b.n	70004bde <HAL_RCCEx_GetPeriphCLKFreq+0x1676>
      break;
70004bdc:	bf00      	nop
  }

  return frequency;
70004bde:	697b      	ldr	r3, [r7, #20]
}
70004be0:	4618      	mov	r0, r3
70004be2:	3718      	adds	r7, #24
70004be4:	46bd      	mov	sp, r7
70004be6:	bd80      	pop	{r7, pc}

70004be8 <HAL_RCCEx_EnableClockProtection>:
  *            @arg RCC_CLOCKPROTECT_FMC     FMC clock protection
  *            @arg RCC_CLOCKPROTECT_XSPI    XSPIs clock protection
  * @retval None
  */
void HAL_RCCEx_EnableClockProtection(uint32_t ProtectClk)
{
70004be8:	b480      	push	{r7}
70004bea:	b083      	sub	sp, #12
70004bec:	af00      	add	r7, sp, #0
70004bee:	6078      	str	r0, [r7, #4]
  /* Check the parameter */
  assert_param(IS_RCC_CLOCKPROTECTION(ProtectClk));

  SET_BIT(RCC->CKPROTR, ProtectClk);
70004bf0:	4b06      	ldr	r3, [pc, #24]	@ (70004c0c <HAL_RCCEx_EnableClockProtection+0x24>)
70004bf2:	f8d3 2100 	ldr.w	r2, [r3, #256]	@ 0x100
70004bf6:	4905      	ldr	r1, [pc, #20]	@ (70004c0c <HAL_RCCEx_EnableClockProtection+0x24>)
70004bf8:	687b      	ldr	r3, [r7, #4]
70004bfa:	4313      	orrs	r3, r2
70004bfc:	f8c1 3100 	str.w	r3, [r1, #256]	@ 0x100
}
70004c00:	bf00      	nop
70004c02:	370c      	adds	r7, #12
70004c04:	46bd      	mov	sp, r7
70004c06:	f85d 7b04 	ldr.w	r7, [sp], #4
70004c0a:	4770      	bx	lr
70004c0c:	58024400 	.word	0x58024400

70004c10 <RCC_GetCLKPFreq>:
/**
  * @brief  Compute PLL2 VCO output frequency
  * @retval Value of PLL2 VCO output frequency
  */
static uint32_t RCC_GetCLKPFreq(void)
{
70004c10:	b480      	push	{r7}
70004c12:	b083      	sub	sp, #12
70004c14:	af00      	add	r7, sp, #0
  uint32_t frequency = 0U;
70004c16:	2300      	movs	r3, #0
70004c18:	607b      	str	r3, [r7, #4]
  uint32_t ckpclocksource;

  ckpclocksource = __HAL_RCC_GET_CLKP_SOURCE();
70004c1a:	4b1f      	ldr	r3, [pc, #124]	@ (70004c98 <RCC_GetCLKPFreq+0x88>)
70004c1c:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70004c1e:	f003 5340 	and.w	r3, r3, #805306368	@ 0x30000000
70004c22:	603b      	str	r3, [r7, #0]

  if (ckpclocksource == RCC_CLKPSOURCE_HSI)
70004c24:	683b      	ldr	r3, [r7, #0]
70004c26:	2b00      	cmp	r3, #0
70004c28:	d115      	bne.n	70004c56 <RCC_GetCLKPFreq+0x46>
  {
    if (READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
70004c2a:	4b1b      	ldr	r3, [pc, #108]	@ (70004c98 <RCC_GetCLKPFreq+0x88>)
70004c2c:	681b      	ldr	r3, [r3, #0]
70004c2e:	f003 0304 	and.w	r3, r3, #4
70004c32:	2b00      	cmp	r3, #0
70004c34:	d028      	beq.n	70004c88 <RCC_GetCLKPFreq+0x78>
    {
      if (READ_BIT(RCC->CR, RCC_CR_HSIDIVF) != 0U)
70004c36:	4b18      	ldr	r3, [pc, #96]	@ (70004c98 <RCC_GetCLKPFreq+0x88>)
70004c38:	681b      	ldr	r3, [r3, #0]
70004c3a:	f003 0320 	and.w	r3, r3, #32
70004c3e:	2b00      	cmp	r3, #0
70004c40:	d022      	beq.n	70004c88 <RCC_GetCLKPFreq+0x78>
      {
        frequency = (HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> RCC_CR_HSIDIV_Pos));
70004c42:	4b15      	ldr	r3, [pc, #84]	@ (70004c98 <RCC_GetCLKPFreq+0x88>)
70004c44:	681b      	ldr	r3, [r3, #0]
70004c46:	08db      	lsrs	r3, r3, #3
70004c48:	f003 0303 	and.w	r3, r3, #3
70004c4c:	4a13      	ldr	r2, [pc, #76]	@ (70004c9c <RCC_GetCLKPFreq+0x8c>)
70004c4e:	fa22 f303 	lsr.w	r3, r2, r3
70004c52:	607b      	str	r3, [r7, #4]
70004c54:	e018      	b.n	70004c88 <RCC_GetCLKPFreq+0x78>
      {
        /* Can't retrieve HSIDIV value */
      }
    }
  }
  else if (ckpclocksource == RCC_CLKPSOURCE_CSI)
70004c56:	683b      	ldr	r3, [r7, #0]
70004c58:	f1b3 5f80 	cmp.w	r3, #268435456	@ 0x10000000
70004c5c:	d108      	bne.n	70004c70 <RCC_GetCLKPFreq+0x60>
  {
    if (READ_BIT(RCC->CR, RCC_CR_CSIRDY) != 0U)
70004c5e:	4b0e      	ldr	r3, [pc, #56]	@ (70004c98 <RCC_GetCLKPFreq+0x88>)
70004c60:	681b      	ldr	r3, [r3, #0]
70004c62:	f403 7380 	and.w	r3, r3, #256	@ 0x100
70004c66:	2b00      	cmp	r3, #0
70004c68:	d00e      	beq.n	70004c88 <RCC_GetCLKPFreq+0x78>
    {
      frequency = CSI_VALUE;
70004c6a:	4b0d      	ldr	r3, [pc, #52]	@ (70004ca0 <RCC_GetCLKPFreq+0x90>)
70004c6c:	607b      	str	r3, [r7, #4]
70004c6e:	e00b      	b.n	70004c88 <RCC_GetCLKPFreq+0x78>
    }
  }
  else if (ckpclocksource == RCC_CLKPSOURCE_HSE)
70004c70:	683b      	ldr	r3, [r7, #0]
70004c72:	f1b3 5f00 	cmp.w	r3, #536870912	@ 0x20000000
70004c76:	d107      	bne.n	70004c88 <RCC_GetCLKPFreq+0x78>
  {
    if (READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
70004c78:	4b07      	ldr	r3, [pc, #28]	@ (70004c98 <RCC_GetCLKPFreq+0x88>)
70004c7a:	681b      	ldr	r3, [r3, #0]
70004c7c:	f403 3300 	and.w	r3, r3, #131072	@ 0x20000
70004c80:	2b00      	cmp	r3, #0
70004c82:	d001      	beq.n	70004c88 <RCC_GetCLKPFreq+0x78>
    {
      frequency = HSE_VALUE;
70004c84:	4b07      	ldr	r3, [pc, #28]	@ (70004ca4 <RCC_GetCLKPFreq+0x94>)
70004c86:	607b      	str	r3, [r7, #4]
  {
    /* Nothing to do, case the CKPER is disabled */
    /* frequency is by default set to 0          */
  }

  return frequency;
70004c88:	687b      	ldr	r3, [r7, #4]
}
70004c8a:	4618      	mov	r0, r3
70004c8c:	370c      	adds	r7, #12
70004c8e:	46bd      	mov	sp, r7
70004c90:	f85d 7b04 	ldr.w	r7, [sp], #4
70004c94:	4770      	bx	lr
70004c96:	bf00      	nop
70004c98:	58024400 	.word	0x58024400
70004c9c:	03d09000 	.word	0x03d09000
70004ca0:	003d0900 	.word	0x003d0900
70004ca4:	016e3600 	.word	0x016e3600

70004ca8 <HAL_UART_Init>:
  *        parameters in the UART_InitTypeDef and initialize the associated handle.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Init(UART_HandleTypeDef *huart)
{
70004ca8:	b580      	push	{r7, lr}
70004caa:	b082      	sub	sp, #8
70004cac:	af00      	add	r7, sp, #0
70004cae:	6078      	str	r0, [r7, #4]
  /* Check the UART handle allocation */
  if (huart == NULL)
70004cb0:	687b      	ldr	r3, [r7, #4]
70004cb2:	2b00      	cmp	r3, #0
70004cb4:	d101      	bne.n	70004cba <HAL_UART_Init+0x12>
  {
    return HAL_ERROR;
70004cb6:	2301      	movs	r3, #1
70004cb8:	e042      	b.n	70004d40 <HAL_UART_Init+0x98>
  {
    /* Check the parameters */
    assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));
  }

  if (huart->gState == HAL_UART_STATE_RESET)
70004cba:	687b      	ldr	r3, [r7, #4]
70004cbc:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
70004cc0:	2b00      	cmp	r3, #0
70004cc2:	d106      	bne.n	70004cd2 <HAL_UART_Init+0x2a>
  {
    /* Allocate lock resource and initialize it */
    huart->Lock = HAL_UNLOCKED;
70004cc4:	687b      	ldr	r3, [r7, #4]
70004cc6:	2200      	movs	r2, #0
70004cc8:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

    /* Init the low level hardware */
    huart->MspInitCallback(huart);
#else
    /* Init the low level hardware : GPIO, CLOCK */
    HAL_UART_MspInit(huart);
70004ccc:	6878      	ldr	r0, [r7, #4]
70004cce:	f7fb fee3 	bl	70000a98 <HAL_UART_MspInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */
  }

  huart->gState = HAL_UART_STATE_BUSY;
70004cd2:	687b      	ldr	r3, [r7, #4]
70004cd4:	2224      	movs	r2, #36	@ 0x24
70004cd6:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  __HAL_UART_DISABLE(huart);
70004cda:	687b      	ldr	r3, [r7, #4]
70004cdc:	681b      	ldr	r3, [r3, #0]
70004cde:	681a      	ldr	r2, [r3, #0]
70004ce0:	687b      	ldr	r3, [r7, #4]
70004ce2:	681b      	ldr	r3, [r3, #0]
70004ce4:	f022 0201 	bic.w	r2, r2, #1
70004ce8:	601a      	str	r2, [r3, #0]

  /* Perform advanced settings configuration */
  /* For some items, configuration requires to be done prior TE and RE bits are set */
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
70004cea:	687b      	ldr	r3, [r7, #4]
70004cec:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70004cee:	2b00      	cmp	r3, #0
70004cf0:	d002      	beq.n	70004cf8 <HAL_UART_Init+0x50>
  {
    UART_AdvFeatureConfig(huart);
70004cf2:	6878      	ldr	r0, [r7, #4]
70004cf4:	f000 fc58 	bl	700055a8 <UART_AdvFeatureConfig>
  }

  /* Set the UART Communication parameters */
  if (UART_SetConfig(huart) == HAL_ERROR)
70004cf8:	6878      	ldr	r0, [r7, #4]
70004cfa:	f000 f8bf 	bl	70004e7c <UART_SetConfig>
70004cfe:	4603      	mov	r3, r0
70004d00:	2b01      	cmp	r3, #1
70004d02:	d101      	bne.n	70004d08 <HAL_UART_Init+0x60>
  {
    return HAL_ERROR;
70004d04:	2301      	movs	r3, #1
70004d06:	e01b      	b.n	70004d40 <HAL_UART_Init+0x98>
  }

  /* In asynchronous mode, the following bits must be kept cleared:
  - LINEN and CLKEN bits in the USART_CR2 register,
  - SCEN, HDSEL and IREN  bits in the USART_CR3 register.*/
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
70004d08:	687b      	ldr	r3, [r7, #4]
70004d0a:	681b      	ldr	r3, [r3, #0]
70004d0c:	685a      	ldr	r2, [r3, #4]
70004d0e:	687b      	ldr	r3, [r7, #4]
70004d10:	681b      	ldr	r3, [r3, #0]
70004d12:	f422 4290 	bic.w	r2, r2, #18432	@ 0x4800
70004d16:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
70004d18:	687b      	ldr	r3, [r7, #4]
70004d1a:	681b      	ldr	r3, [r3, #0]
70004d1c:	689a      	ldr	r2, [r3, #8]
70004d1e:	687b      	ldr	r3, [r7, #4]
70004d20:	681b      	ldr	r3, [r3, #0]
70004d22:	f022 022a 	bic.w	r2, r2, #42	@ 0x2a
70004d26:	609a      	str	r2, [r3, #8]

  __HAL_UART_ENABLE(huart);
70004d28:	687b      	ldr	r3, [r7, #4]
70004d2a:	681b      	ldr	r3, [r3, #0]
70004d2c:	681a      	ldr	r2, [r3, #0]
70004d2e:	687b      	ldr	r3, [r7, #4]
70004d30:	681b      	ldr	r3, [r3, #0]
70004d32:	f042 0201 	orr.w	r2, r2, #1
70004d36:	601a      	str	r2, [r3, #0]

  /* TEACK and/or REACK to check before moving huart->gState and huart->RxState to Ready */
  return (UART_CheckIdleState(huart));
70004d38:	6878      	ldr	r0, [r7, #4]
70004d3a:	f000 fcd7 	bl	700056ec <UART_CheckIdleState>
70004d3e:	4603      	mov	r3, r0
}
70004d40:	4618      	mov	r0, r3
70004d42:	3708      	adds	r7, #8
70004d44:	46bd      	mov	sp, r7
70004d46:	bd80      	pop	{r7, pc}

70004d48 <HAL_UART_Transmit>:
  * @param Size    Amount of data elements (u8 or u16) to be sent.
  * @param Timeout Timeout duration.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_Transmit(UART_HandleTypeDef *huart, const uint8_t *pData, uint16_t Size, uint32_t Timeout)
{
70004d48:	b580      	push	{r7, lr}
70004d4a:	b08a      	sub	sp, #40	@ 0x28
70004d4c:	af02      	add	r7, sp, #8
70004d4e:	60f8      	str	r0, [r7, #12]
70004d50:	60b9      	str	r1, [r7, #8]
70004d52:	603b      	str	r3, [r7, #0]
70004d54:	4613      	mov	r3, r2
70004d56:	80fb      	strh	r3, [r7, #6]
  const uint8_t  *pdata8bits;
  const uint16_t *pdata16bits;
  uint32_t tickstart;

  /* Check that a Tx process is not already ongoing */
  if (huart->gState == HAL_UART_STATE_READY)
70004d58:	68fb      	ldr	r3, [r7, #12]
70004d5a:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
70004d5e:	2b20      	cmp	r3, #32
70004d60:	f040 8086 	bne.w	70004e70 <HAL_UART_Transmit+0x128>
  {
    if ((pData == NULL) || (Size == 0U))
70004d64:	68bb      	ldr	r3, [r7, #8]
70004d66:	2b00      	cmp	r3, #0
70004d68:	d002      	beq.n	70004d70 <HAL_UART_Transmit+0x28>
70004d6a:	88fb      	ldrh	r3, [r7, #6]
70004d6c:	2b00      	cmp	r3, #0
70004d6e:	d101      	bne.n	70004d74 <HAL_UART_Transmit+0x2c>
    {
      return  HAL_ERROR;
70004d70:	2301      	movs	r3, #1
70004d72:	e07e      	b.n	70004e72 <HAL_UART_Transmit+0x12a>
    }

    huart->ErrorCode = HAL_UART_ERROR_NONE;
70004d74:	68fb      	ldr	r3, [r7, #12]
70004d76:	2200      	movs	r2, #0
70004d78:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
    huart->gState = HAL_UART_STATE_BUSY_TX;
70004d7c:	68fb      	ldr	r3, [r7, #12]
70004d7e:	2221      	movs	r2, #33	@ 0x21
70004d80:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    /* Init tickstart for timeout management */
    tickstart = HAL_GetTick();
70004d84:	f7fc fcde 	bl	70001744 <HAL_GetTick>
70004d88:	6178      	str	r0, [r7, #20]

    huart->TxXferSize  = Size;
70004d8a:	68fb      	ldr	r3, [r7, #12]
70004d8c:	88fa      	ldrh	r2, [r7, #6]
70004d8e:	f8a3 2054 	strh.w	r2, [r3, #84]	@ 0x54
    huart->TxXferCount = Size;
70004d92:	68fb      	ldr	r3, [r7, #12]
70004d94:	88fa      	ldrh	r2, [r7, #6]
70004d96:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56

    /* In case of 9bits/No Parity transfer, pData needs to be handled as a uint16_t pointer */
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
70004d9a:	68fb      	ldr	r3, [r7, #12]
70004d9c:	689b      	ldr	r3, [r3, #8]
70004d9e:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
70004da2:	d108      	bne.n	70004db6 <HAL_UART_Transmit+0x6e>
70004da4:	68fb      	ldr	r3, [r7, #12]
70004da6:	691b      	ldr	r3, [r3, #16]
70004da8:	2b00      	cmp	r3, #0
70004daa:	d104      	bne.n	70004db6 <HAL_UART_Transmit+0x6e>
    {
      pdata8bits  = NULL;
70004dac:	2300      	movs	r3, #0
70004dae:	61fb      	str	r3, [r7, #28]
      pdata16bits = (const uint16_t *) pData;
70004db0:	68bb      	ldr	r3, [r7, #8]
70004db2:	61bb      	str	r3, [r7, #24]
70004db4:	e003      	b.n	70004dbe <HAL_UART_Transmit+0x76>
    }
    else
    {
      pdata8bits  = pData;
70004db6:	68bb      	ldr	r3, [r7, #8]
70004db8:	61fb      	str	r3, [r7, #28]
      pdata16bits = NULL;
70004dba:	2300      	movs	r3, #0
70004dbc:	61bb      	str	r3, [r7, #24]
    }

    while (huart->TxXferCount > 0U)
70004dbe:	e03a      	b.n	70004e36 <HAL_UART_Transmit+0xee>
    {
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
70004dc0:	683b      	ldr	r3, [r7, #0]
70004dc2:	9300      	str	r3, [sp, #0]
70004dc4:	697b      	ldr	r3, [r7, #20]
70004dc6:	2200      	movs	r2, #0
70004dc8:	2180      	movs	r1, #128	@ 0x80
70004dca:	68f8      	ldr	r0, [r7, #12]
70004dcc:	f000 fd38 	bl	70005840 <UART_WaitOnFlagUntilTimeout>
70004dd0:	4603      	mov	r3, r0
70004dd2:	2b00      	cmp	r3, #0
70004dd4:	d005      	beq.n	70004de2 <HAL_UART_Transmit+0x9a>
      {

        huart->gState = HAL_UART_STATE_READY;
70004dd6:	68fb      	ldr	r3, [r7, #12]
70004dd8:	2220      	movs	r2, #32
70004dda:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

        return HAL_TIMEOUT;
70004dde:	2303      	movs	r3, #3
70004de0:	e047      	b.n	70004e72 <HAL_UART_Transmit+0x12a>
      }
      if (pdata8bits == NULL)
70004de2:	69fb      	ldr	r3, [r7, #28]
70004de4:	2b00      	cmp	r3, #0
70004de6:	d10b      	bne.n	70004e00 <HAL_UART_Transmit+0xb8>
      {
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
70004de8:	69bb      	ldr	r3, [r7, #24]
70004dea:	881b      	ldrh	r3, [r3, #0]
70004dec:	461a      	mov	r2, r3
70004dee:	68fb      	ldr	r3, [r7, #12]
70004df0:	681b      	ldr	r3, [r3, #0]
70004df2:	f3c2 0208 	ubfx	r2, r2, #0, #9
70004df6:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata16bits++;
70004df8:	69bb      	ldr	r3, [r7, #24]
70004dfa:	3302      	adds	r3, #2
70004dfc:	61bb      	str	r3, [r7, #24]
70004dfe:	e007      	b.n	70004e10 <HAL_UART_Transmit+0xc8>
      }
      else
      {
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
70004e00:	69fb      	ldr	r3, [r7, #28]
70004e02:	781a      	ldrb	r2, [r3, #0]
70004e04:	68fb      	ldr	r3, [r7, #12]
70004e06:	681b      	ldr	r3, [r3, #0]
70004e08:	629a      	str	r2, [r3, #40]	@ 0x28
        pdata8bits++;
70004e0a:	69fb      	ldr	r3, [r7, #28]
70004e0c:	3301      	adds	r3, #1
70004e0e:	61fb      	str	r3, [r7, #28]
      }
      if ((huart->gState & HAL_UART_STATE_BUSY_TX) == HAL_UART_STATE_BUSY_TX)
70004e10:	68fb      	ldr	r3, [r7, #12]
70004e12:	f8d3 3088 	ldr.w	r3, [r3, #136]	@ 0x88
70004e16:	f003 0321 	and.w	r3, r3, #33	@ 0x21
70004e1a:	2b21      	cmp	r3, #33	@ 0x21
70004e1c:	d109      	bne.n	70004e32 <HAL_UART_Transmit+0xea>
      {
        huart->TxXferCount--;
70004e1e:	68fb      	ldr	r3, [r7, #12]
70004e20:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
70004e24:	b29b      	uxth	r3, r3
70004e26:	3b01      	subs	r3, #1
70004e28:	b29a      	uxth	r2, r3
70004e2a:	68fb      	ldr	r3, [r7, #12]
70004e2c:	f8a3 2056 	strh.w	r2, [r3, #86]	@ 0x56
70004e30:	e001      	b.n	70004e36 <HAL_UART_Transmit+0xee>
      }
      else
      {
        /* Process was aborted during the transmission */
        return HAL_ERROR;
70004e32:	2301      	movs	r3, #1
70004e34:	e01d      	b.n	70004e72 <HAL_UART_Transmit+0x12a>
    while (huart->TxXferCount > 0U)
70004e36:	68fb      	ldr	r3, [r7, #12]
70004e38:	f8b3 3056 	ldrh.w	r3, [r3, #86]	@ 0x56
70004e3c:	b29b      	uxth	r3, r3
70004e3e:	2b00      	cmp	r3, #0
70004e40:	d1be      	bne.n	70004dc0 <HAL_UART_Transmit+0x78>
      }
    }

    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
70004e42:	683b      	ldr	r3, [r7, #0]
70004e44:	9300      	str	r3, [sp, #0]
70004e46:	697b      	ldr	r3, [r7, #20]
70004e48:	2200      	movs	r2, #0
70004e4a:	2140      	movs	r1, #64	@ 0x40
70004e4c:	68f8      	ldr	r0, [r7, #12]
70004e4e:	f000 fcf7 	bl	70005840 <UART_WaitOnFlagUntilTimeout>
70004e52:	4603      	mov	r3, r0
70004e54:	2b00      	cmp	r3, #0
70004e56:	d005      	beq.n	70004e64 <HAL_UART_Transmit+0x11c>
    {
      huart->gState = HAL_UART_STATE_READY;
70004e58:	68fb      	ldr	r3, [r7, #12]
70004e5a:	2220      	movs	r2, #32
70004e5c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      return HAL_TIMEOUT;
70004e60:	2303      	movs	r3, #3
70004e62:	e006      	b.n	70004e72 <HAL_UART_Transmit+0x12a>
    }

    /* At end of Tx process, restore huart->gState to Ready */
    huart->gState = HAL_UART_STATE_READY;
70004e64:	68fb      	ldr	r3, [r7, #12]
70004e66:	2220      	movs	r2, #32
70004e68:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

    return HAL_OK;
70004e6c:	2300      	movs	r3, #0
70004e6e:	e000      	b.n	70004e72 <HAL_UART_Transmit+0x12a>
  }
  else
  {
    return HAL_BUSY;
70004e70:	2302      	movs	r3, #2
  }
}
70004e72:	4618      	mov	r0, r3
70004e74:	3720      	adds	r7, #32
70004e76:	46bd      	mov	sp, r7
70004e78:	bd80      	pop	{r7, pc}
	...

70004e7c <UART_SetConfig>:
  * @brief Configure the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_SetConfig(UART_HandleTypeDef *huart)
{
70004e7c:	e92d 4fb0 	stmdb	sp!, {r4, r5, r7, r8, r9, sl, fp, lr}
70004e80:	b08c      	sub	sp, #48	@ 0x30
70004e82:	af00      	add	r7, sp, #0
70004e84:	6178      	str	r0, [r7, #20]
  uint32_t tmpreg;
  uint16_t brrtemp;
  UART_ClockSourceTypeDef clocksource;
  uint32_t usartdiv;
  HAL_StatusTypeDef ret               = HAL_OK;
70004e86:	2300      	movs	r3, #0
70004e88:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
70004e8c:	697b      	ldr	r3, [r7, #20]
70004e8e:	689a      	ldr	r2, [r3, #8]
70004e90:	697b      	ldr	r3, [r7, #20]
70004e92:	691b      	ldr	r3, [r3, #16]
70004e94:	431a      	orrs	r2, r3
70004e96:	697b      	ldr	r3, [r7, #20]
70004e98:	695b      	ldr	r3, [r3, #20]
70004e9a:	431a      	orrs	r2, r3
70004e9c:	697b      	ldr	r3, [r7, #20]
70004e9e:	69db      	ldr	r3, [r3, #28]
70004ea0:	4313      	orrs	r3, r2
70004ea2:	62fb      	str	r3, [r7, #44]	@ 0x2c
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
70004ea4:	697b      	ldr	r3, [r7, #20]
70004ea6:	681b      	ldr	r3, [r3, #0]
70004ea8:	681a      	ldr	r2, [r3, #0]
70004eaa:	4bb3      	ldr	r3, [pc, #716]	@ (70005178 <UART_SetConfig+0x2fc>)
70004eac:	4013      	ands	r3, r2
70004eae:	697a      	ldr	r2, [r7, #20]
70004eb0:	6812      	ldr	r2, [r2, #0]
70004eb2:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
70004eb4:	430b      	orrs	r3, r1
70004eb6:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
70004eb8:	697b      	ldr	r3, [r7, #20]
70004eba:	681b      	ldr	r3, [r3, #0]
70004ebc:	685b      	ldr	r3, [r3, #4]
70004ebe:	f423 5140 	bic.w	r1, r3, #12288	@ 0x3000
70004ec2:	697b      	ldr	r3, [r7, #20]
70004ec4:	68da      	ldr	r2, [r3, #12]
70004ec6:	697b      	ldr	r3, [r7, #20]
70004ec8:	681b      	ldr	r3, [r3, #0]
70004eca:	430a      	orrs	r2, r1
70004ecc:	605a      	str	r2, [r3, #4]
  /* Configure
  * - UART HardWare Flow Control: set CTSE and RTSE bits according
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
70004ece:	697b      	ldr	r3, [r7, #20]
70004ed0:	699b      	ldr	r3, [r3, #24]
70004ed2:	62fb      	str	r3, [r7, #44]	@ 0x2c

  if (!(UART_INSTANCE_LOWPOWER(huart)))
70004ed4:	697b      	ldr	r3, [r7, #20]
70004ed6:	681b      	ldr	r3, [r3, #0]
70004ed8:	4aa8      	ldr	r2, [pc, #672]	@ (7000517c <UART_SetConfig+0x300>)
70004eda:	4293      	cmp	r3, r2
70004edc:	d004      	beq.n	70004ee8 <UART_SetConfig+0x6c>
  {
    tmpreg |= huart->Init.OneBitSampling;
70004ede:	697b      	ldr	r3, [r7, #20]
70004ee0:	6a1b      	ldr	r3, [r3, #32]
70004ee2:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
70004ee4:	4313      	orrs	r3, r2
70004ee6:	62fb      	str	r3, [r7, #44]	@ 0x2c
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
70004ee8:	697b      	ldr	r3, [r7, #20]
70004eea:	681b      	ldr	r3, [r3, #0]
70004eec:	689a      	ldr	r2, [r3, #8]
70004eee:	4ba4      	ldr	r3, [pc, #656]	@ (70005180 <UART_SetConfig+0x304>)
70004ef0:	4013      	ands	r3, r2
70004ef2:	697a      	ldr	r2, [r7, #20]
70004ef4:	6812      	ldr	r2, [r2, #0]
70004ef6:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
70004ef8:	430b      	orrs	r3, r1
70004efa:	6093      	str	r3, [r2, #8]

  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
70004efc:	697b      	ldr	r3, [r7, #20]
70004efe:	681b      	ldr	r3, [r3, #0]
70004f00:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70004f02:	f023 010f 	bic.w	r1, r3, #15
70004f06:	697b      	ldr	r3, [r7, #20]
70004f08:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
70004f0a:	697b      	ldr	r3, [r7, #20]
70004f0c:	681b      	ldr	r3, [r3, #0]
70004f0e:	430a      	orrs	r2, r1
70004f10:	62da      	str	r2, [r3, #44]	@ 0x2c

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
70004f12:	697b      	ldr	r3, [r7, #20]
70004f14:	681b      	ldr	r3, [r3, #0]
70004f16:	4a9b      	ldr	r2, [pc, #620]	@ (70005184 <UART_SetConfig+0x308>)
70004f18:	4293      	cmp	r3, r2
70004f1a:	d131      	bne.n	70004f80 <UART_SetConfig+0x104>
70004f1c:	4b9a      	ldr	r3, [pc, #616]	@ (70005188 <UART_SetConfig+0x30c>)
70004f1e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70004f20:	f003 0307 	and.w	r3, r3, #7
70004f24:	2b05      	cmp	r3, #5
70004f26:	d827      	bhi.n	70004f78 <UART_SetConfig+0xfc>
70004f28:	a201      	add	r2, pc, #4	@ (adr r2, 70004f30 <UART_SetConfig+0xb4>)
70004f2a:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70004f2e:	bf00      	nop
70004f30:	70004f49 	.word	0x70004f49
70004f34:	70004f51 	.word	0x70004f51
70004f38:	70004f59 	.word	0x70004f59
70004f3c:	70004f61 	.word	0x70004f61
70004f40:	70004f69 	.word	0x70004f69
70004f44:	70004f71 	.word	0x70004f71
70004f48:	2301      	movs	r3, #1
70004f4a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004f4e:	e0a0      	b.n	70005092 <UART_SetConfig+0x216>
70004f50:	2304      	movs	r3, #4
70004f52:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004f56:	e09c      	b.n	70005092 <UART_SetConfig+0x216>
70004f58:	2308      	movs	r3, #8
70004f5a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004f5e:	e098      	b.n	70005092 <UART_SetConfig+0x216>
70004f60:	2310      	movs	r3, #16
70004f62:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004f66:	e094      	b.n	70005092 <UART_SetConfig+0x216>
70004f68:	2320      	movs	r3, #32
70004f6a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004f6e:	e090      	b.n	70005092 <UART_SetConfig+0x216>
70004f70:	2340      	movs	r3, #64	@ 0x40
70004f72:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004f76:	e08c      	b.n	70005092 <UART_SetConfig+0x216>
70004f78:	2380      	movs	r3, #128	@ 0x80
70004f7a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004f7e:	e088      	b.n	70005092 <UART_SetConfig+0x216>
70004f80:	697b      	ldr	r3, [r7, #20]
70004f82:	681b      	ldr	r3, [r3, #0]
70004f84:	4a81      	ldr	r2, [pc, #516]	@ (7000518c <UART_SetConfig+0x310>)
70004f86:	4293      	cmp	r3, r2
70004f88:	d018      	beq.n	70004fbc <UART_SetConfig+0x140>
70004f8a:	697b      	ldr	r3, [r7, #20]
70004f8c:	681b      	ldr	r3, [r3, #0]
70004f8e:	4a80      	ldr	r2, [pc, #512]	@ (70005190 <UART_SetConfig+0x314>)
70004f90:	4293      	cmp	r3, r2
70004f92:	d013      	beq.n	70004fbc <UART_SetConfig+0x140>
70004f94:	697b      	ldr	r3, [r7, #20]
70004f96:	681b      	ldr	r3, [r3, #0]
70004f98:	4a7e      	ldr	r2, [pc, #504]	@ (70005194 <UART_SetConfig+0x318>)
70004f9a:	4293      	cmp	r3, r2
70004f9c:	d00e      	beq.n	70004fbc <UART_SetConfig+0x140>
70004f9e:	697b      	ldr	r3, [r7, #20]
70004fa0:	681b      	ldr	r3, [r3, #0]
70004fa2:	4a7d      	ldr	r2, [pc, #500]	@ (70005198 <UART_SetConfig+0x31c>)
70004fa4:	4293      	cmp	r3, r2
70004fa6:	d009      	beq.n	70004fbc <UART_SetConfig+0x140>
70004fa8:	697b      	ldr	r3, [r7, #20]
70004faa:	681b      	ldr	r3, [r3, #0]
70004fac:	4a7b      	ldr	r2, [pc, #492]	@ (7000519c <UART_SetConfig+0x320>)
70004fae:	4293      	cmp	r3, r2
70004fb0:	d004      	beq.n	70004fbc <UART_SetConfig+0x140>
70004fb2:	697b      	ldr	r3, [r7, #20]
70004fb4:	681b      	ldr	r3, [r3, #0]
70004fb6:	4a7a      	ldr	r2, [pc, #488]	@ (700051a0 <UART_SetConfig+0x324>)
70004fb8:	4293      	cmp	r3, r2
70004fba:	d131      	bne.n	70005020 <UART_SetConfig+0x1a4>
70004fbc:	4b72      	ldr	r3, [pc, #456]	@ (70005188 <UART_SetConfig+0x30c>)
70004fbe:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70004fc0:	f003 0307 	and.w	r3, r3, #7
70004fc4:	2b05      	cmp	r3, #5
70004fc6:	d827      	bhi.n	70005018 <UART_SetConfig+0x19c>
70004fc8:	a201      	add	r2, pc, #4	@ (adr r2, 70004fd0 <UART_SetConfig+0x154>)
70004fca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70004fce:	bf00      	nop
70004fd0:	70004fe9 	.word	0x70004fe9
70004fd4:	70004ff1 	.word	0x70004ff1
70004fd8:	70004ff9 	.word	0x70004ff9
70004fdc:	70005001 	.word	0x70005001
70004fe0:	70005009 	.word	0x70005009
70004fe4:	70005011 	.word	0x70005011
70004fe8:	2300      	movs	r3, #0
70004fea:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004fee:	e016      	b.n	7000501e <UART_SetConfig+0x1a2>
70004ff0:	2304      	movs	r3, #4
70004ff2:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004ff6:	e012      	b.n	7000501e <UART_SetConfig+0x1a2>
70004ff8:	2308      	movs	r3, #8
70004ffa:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70004ffe:	e00e      	b.n	7000501e <UART_SetConfig+0x1a2>
70005000:	2310      	movs	r3, #16
70005002:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70005006:	e00a      	b.n	7000501e <UART_SetConfig+0x1a2>
70005008:	2320      	movs	r3, #32
7000500a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000500e:	e006      	b.n	7000501e <UART_SetConfig+0x1a2>
70005010:	2340      	movs	r3, #64	@ 0x40
70005012:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70005016:	e002      	b.n	7000501e <UART_SetConfig+0x1a2>
70005018:	2380      	movs	r3, #128	@ 0x80
7000501a:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000501e:	e038      	b.n	70005092 <UART_SetConfig+0x216>
70005020:	697b      	ldr	r3, [r7, #20]
70005022:	681b      	ldr	r3, [r3, #0]
70005024:	4a55      	ldr	r2, [pc, #340]	@ (7000517c <UART_SetConfig+0x300>)
70005026:	4293      	cmp	r3, r2
70005028:	d130      	bne.n	7000508c <UART_SetConfig+0x210>
7000502a:	4b57      	ldr	r3, [pc, #348]	@ (70005188 <UART_SetConfig+0x30c>)
7000502c:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
7000502e:	f003 0307 	and.w	r3, r3, #7
70005032:	2b05      	cmp	r3, #5
70005034:	d826      	bhi.n	70005084 <UART_SetConfig+0x208>
70005036:	a201      	add	r2, pc, #4	@ (adr r2, 7000503c <UART_SetConfig+0x1c0>)
70005038:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
7000503c:	70005055 	.word	0x70005055
70005040:	7000505d 	.word	0x7000505d
70005044:	70005065 	.word	0x70005065
70005048:	7000506d 	.word	0x7000506d
7000504c:	70005075 	.word	0x70005075
70005050:	7000507d 	.word	0x7000507d
70005054:	2302      	movs	r3, #2
70005056:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000505a:	e01a      	b.n	70005092 <UART_SetConfig+0x216>
7000505c:	2304      	movs	r3, #4
7000505e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70005062:	e016      	b.n	70005092 <UART_SetConfig+0x216>
70005064:	2308      	movs	r3, #8
70005066:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000506a:	e012      	b.n	70005092 <UART_SetConfig+0x216>
7000506c:	2310      	movs	r3, #16
7000506e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70005072:	e00e      	b.n	70005092 <UART_SetConfig+0x216>
70005074:	2320      	movs	r3, #32
70005076:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000507a:	e00a      	b.n	70005092 <UART_SetConfig+0x216>
7000507c:	2340      	movs	r3, #64	@ 0x40
7000507e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
70005082:	e006      	b.n	70005092 <UART_SetConfig+0x216>
70005084:	2380      	movs	r3, #128	@ 0x80
70005086:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b
7000508a:	e002      	b.n	70005092 <UART_SetConfig+0x216>
7000508c:	2380      	movs	r3, #128	@ 0x80
7000508e:	f887 302b 	strb.w	r3, [r7, #43]	@ 0x2b

  /* Check LPUART instance */
  if (UART_INSTANCE_LOWPOWER(huart))
70005092:	697b      	ldr	r3, [r7, #20]
70005094:	681b      	ldr	r3, [r3, #0]
70005096:	4a39      	ldr	r2, [pc, #228]	@ (7000517c <UART_SetConfig+0x300>)
70005098:	4293      	cmp	r3, r2
7000509a:	f040 80fe 	bne.w	7000529a <UART_SetConfig+0x41e>
  {
    /* Retrieve frequency clock */
    switch (clocksource)
7000509e:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
700050a2:	2b20      	cmp	r3, #32
700050a4:	dc48      	bgt.n	70005138 <UART_SetConfig+0x2bc>
700050a6:	2b02      	cmp	r3, #2
700050a8:	f2c0 8088 	blt.w	700051bc <UART_SetConfig+0x340>
700050ac:	3b02      	subs	r3, #2
700050ae:	2b1e      	cmp	r3, #30
700050b0:	f200 8084 	bhi.w	700051bc <UART_SetConfig+0x340>
700050b4:	a201      	add	r2, pc, #4	@ (adr r2, 700050bc <UART_SetConfig+0x240>)
700050b6:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
700050ba:	bf00      	nop
700050bc:	7000514f 	.word	0x7000514f
700050c0:	700051bd 	.word	0x700051bd
700050c4:	7000513f 	.word	0x7000513f
700050c8:	700051bd 	.word	0x700051bd
700050cc:	700051bd 	.word	0x700051bd
700050d0:	700051bd 	.word	0x700051bd
700050d4:	70005147 	.word	0x70005147
700050d8:	700051bd 	.word	0x700051bd
700050dc:	700051bd 	.word	0x700051bd
700050e0:	700051bd 	.word	0x700051bd
700050e4:	700051bd 	.word	0x700051bd
700050e8:	700051bd 	.word	0x700051bd
700050ec:	700051bd 	.word	0x700051bd
700050f0:	700051bd 	.word	0x700051bd
700050f4:	70005157 	.word	0x70005157
700050f8:	700051bd 	.word	0x700051bd
700050fc:	700051bd 	.word	0x700051bd
70005100:	700051bd 	.word	0x700051bd
70005104:	700051bd 	.word	0x700051bd
70005108:	700051bd 	.word	0x700051bd
7000510c:	700051bd 	.word	0x700051bd
70005110:	700051bd 	.word	0x700051bd
70005114:	700051bd 	.word	0x700051bd
70005118:	700051bd 	.word	0x700051bd
7000511c:	700051bd 	.word	0x700051bd
70005120:	700051bd 	.word	0x700051bd
70005124:	700051bd 	.word	0x700051bd
70005128:	700051bd 	.word	0x700051bd
7000512c:	700051bd 	.word	0x700051bd
70005130:	700051bd 	.word	0x700051bd
70005134:	700051af 	.word	0x700051af
70005138:	2b40      	cmp	r3, #64	@ 0x40
7000513a:	d03b      	beq.n	700051b4 <UART_SetConfig+0x338>
7000513c:	e03e      	b.n	700051bc <UART_SetConfig+0x340>
    {
      case UART_CLOCKSOURCE_PLL2Q:
        pclk = HAL_RCC_GetPLL2QFreq();
7000513e:	f7fd f8cb 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
70005142:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70005144:	e040      	b.n	700051c8 <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_PLL3Q:
        pclk = HAL_RCC_GetPLL3QFreq();
70005146:	f7fd f937 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
7000514a:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
7000514c:	e03c      	b.n	700051c8 <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_PCLK4:
        pclk = HAL_RCC_GetPCLK4Freq();
7000514e:	f7fd f87b 	bl	70002248 <HAL_RCC_GetPCLK4Freq>
70005152:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70005154:	e038      	b.n	700051c8 <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
70005156:	4b0c      	ldr	r3, [pc, #48]	@ (70005188 <UART_SetConfig+0x30c>)
70005158:	681b      	ldr	r3, [r3, #0]
7000515a:	f003 0320 	and.w	r3, r3, #32
7000515e:	2b00      	cmp	r3, #0
70005160:	d022      	beq.n	700051a8 <UART_SetConfig+0x32c>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
70005162:	4b09      	ldr	r3, [pc, #36]	@ (70005188 <UART_SetConfig+0x30c>)
70005164:	681b      	ldr	r3, [r3, #0]
70005166:	08db      	lsrs	r3, r3, #3
70005168:	f003 0303 	and.w	r3, r3, #3
7000516c:	4a0d      	ldr	r2, [pc, #52]	@ (700051a4 <UART_SetConfig+0x328>)
7000516e:	fa22 f303 	lsr.w	r3, r2, r3
70005172:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
70005174:	e028      	b.n	700051c8 <UART_SetConfig+0x34c>
70005176:	bf00      	nop
70005178:	cfff69f3 	.word	0xcfff69f3
7000517c:	58000c00 	.word	0x58000c00
70005180:	11fff4ff 	.word	0x11fff4ff
70005184:	42001000 	.word	0x42001000
70005188:	58024400 	.word	0x58024400
7000518c:	40004400 	.word	0x40004400
70005190:	40004800 	.word	0x40004800
70005194:	40004c00 	.word	0x40004c00
70005198:	40005000 	.word	0x40005000
7000519c:	40007800 	.word	0x40007800
700051a0:	40007c00 	.word	0x40007c00
700051a4:	03d09000 	.word	0x03d09000
          pclk = (uint32_t) HSI_VALUE;
700051a8:	4b99      	ldr	r3, [pc, #612]	@ (70005410 <UART_SetConfig+0x594>)
700051aa:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
700051ac:	e00c      	b.n	700051c8 <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
700051ae:	4b99      	ldr	r3, [pc, #612]	@ (70005414 <UART_SetConfig+0x598>)
700051b0:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
700051b2:	e009      	b.n	700051c8 <UART_SetConfig+0x34c>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
700051b4:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
700051b8:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
700051ba:	e005      	b.n	700051c8 <UART_SetConfig+0x34c>
      default:
        pclk = 0U;
700051bc:	2300      	movs	r3, #0
700051be:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = HAL_ERROR;
700051c0:	2301      	movs	r3, #1
700051c2:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
        break;
700051c6:	bf00      	nop
    }

    /* If proper clock source reported */
    if (pclk != 0U)
700051c8:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700051ca:	2b00      	cmp	r3, #0
700051cc:	f000 81ce 	beq.w	7000556c <UART_SetConfig+0x6f0>
    {
      /* Compute clock after Prescaler */
      lpuart_ker_ck_pres = (pclk / UARTPrescTable[huart->Init.ClockPrescaler]);
700051d0:	697b      	ldr	r3, [r7, #20]
700051d2:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
700051d4:	4a90      	ldr	r2, [pc, #576]	@ (70005418 <UART_SetConfig+0x59c>)
700051d6:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700051da:	461a      	mov	r2, r3
700051dc:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700051de:	fbb3 f3f2 	udiv	r3, r3, r2
700051e2:	61bb      	str	r3, [r7, #24]

      /* Ensure that Frequency clock is in the range [3 * baudrate, 4096 * baudrate] */
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
700051e4:	697b      	ldr	r3, [r7, #20]
700051e6:	685a      	ldr	r2, [r3, #4]
700051e8:	4613      	mov	r3, r2
700051ea:	005b      	lsls	r3, r3, #1
700051ec:	4413      	add	r3, r2
700051ee:	69ba      	ldr	r2, [r7, #24]
700051f0:	429a      	cmp	r2, r3
700051f2:	d305      	bcc.n	70005200 <UART_SetConfig+0x384>
          (lpuart_ker_ck_pres > (4096U * huart->Init.BaudRate)))
700051f4:	697b      	ldr	r3, [r7, #20]
700051f6:	685b      	ldr	r3, [r3, #4]
700051f8:	031b      	lsls	r3, r3, #12
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
700051fa:	69ba      	ldr	r2, [r7, #24]
700051fc:	429a      	cmp	r2, r3
700051fe:	d903      	bls.n	70005208 <UART_SetConfig+0x38c>
      {
        ret = HAL_ERROR;
70005200:	2301      	movs	r3, #1
70005202:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
70005206:	e1b1      	b.n	7000556c <UART_SetConfig+0x6f0>
      }
      else
      {
        /* Check computed UsartDiv value is in allocated range
           (it is forbidden to write values lower than 0x300 in the LPUART_BRR register) */
        usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
70005208:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
7000520a:	2200      	movs	r2, #0
7000520c:	60bb      	str	r3, [r7, #8]
7000520e:	60fa      	str	r2, [r7, #12]
70005210:	697b      	ldr	r3, [r7, #20]
70005212:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
70005214:	4a80      	ldr	r2, [pc, #512]	@ (70005418 <UART_SetConfig+0x59c>)
70005216:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
7000521a:	b29b      	uxth	r3, r3
7000521c:	2200      	movs	r2, #0
7000521e:	603b      	str	r3, [r7, #0]
70005220:	607a      	str	r2, [r7, #4]
70005222:	e9d7 2300 	ldrd	r2, r3, [r7]
70005226:	e9d7 0102 	ldrd	r0, r1, [r7, #8]
7000522a:	f7fb f8c9 	bl	700003c0 <__aeabi_uldivmod>
7000522e:	4602      	mov	r2, r0
70005230:	460b      	mov	r3, r1
70005232:	4610      	mov	r0, r2
70005234:	4619      	mov	r1, r3
70005236:	f04f 0200 	mov.w	r2, #0
7000523a:	f04f 0300 	mov.w	r3, #0
7000523e:	020b      	lsls	r3, r1, #8
70005240:	ea43 6310 	orr.w	r3, r3, r0, lsr #24
70005244:	0202      	lsls	r2, r0, #8
70005246:	6979      	ldr	r1, [r7, #20]
70005248:	6849      	ldr	r1, [r1, #4]
7000524a:	0849      	lsrs	r1, r1, #1
7000524c:	2000      	movs	r0, #0
7000524e:	460c      	mov	r4, r1
70005250:	4605      	mov	r5, r0
70005252:	eb12 0804 	adds.w	r8, r2, r4
70005256:	eb43 0905 	adc.w	r9, r3, r5
7000525a:	697b      	ldr	r3, [r7, #20]
7000525c:	685b      	ldr	r3, [r3, #4]
7000525e:	2200      	movs	r2, #0
70005260:	469a      	mov	sl, r3
70005262:	4693      	mov	fp, r2
70005264:	4652      	mov	r2, sl
70005266:	465b      	mov	r3, fp
70005268:	4640      	mov	r0, r8
7000526a:	4649      	mov	r1, r9
7000526c:	f7fb f8a8 	bl	700003c0 <__aeabi_uldivmod>
70005270:	4602      	mov	r2, r0
70005272:	460b      	mov	r3, r1
70005274:	4613      	mov	r3, r2
70005276:	623b      	str	r3, [r7, #32]
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
70005278:	6a3b      	ldr	r3, [r7, #32]
7000527a:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
7000527e:	d308      	bcc.n	70005292 <UART_SetConfig+0x416>
70005280:	6a3b      	ldr	r3, [r7, #32]
70005282:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
70005286:	d204      	bcs.n	70005292 <UART_SetConfig+0x416>
        {
          huart->Instance->BRR = usartdiv;
70005288:	697b      	ldr	r3, [r7, #20]
7000528a:	681b      	ldr	r3, [r3, #0]
7000528c:	6a3a      	ldr	r2, [r7, #32]
7000528e:	60da      	str	r2, [r3, #12]
70005290:	e16c      	b.n	7000556c <UART_SetConfig+0x6f0>
        }
        else
        {
          ret = HAL_ERROR;
70005292:	2301      	movs	r3, #1
70005294:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
70005298:	e168      	b.n	7000556c <UART_SetConfig+0x6f0>
      } /* if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) ||
                (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (pclk != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
7000529a:	697b      	ldr	r3, [r7, #20]
7000529c:	69db      	ldr	r3, [r3, #28]
7000529e:	f5b3 4f00 	cmp.w	r3, #32768	@ 0x8000
700052a2:	f040 80bd 	bne.w	70005420 <UART_SetConfig+0x5a4>
  {
    switch (clocksource)
700052a6:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
700052aa:	2b20      	cmp	r3, #32
700052ac:	dc48      	bgt.n	70005340 <UART_SetConfig+0x4c4>
700052ae:	2b00      	cmp	r3, #0
700052b0:	db73      	blt.n	7000539a <UART_SetConfig+0x51e>
700052b2:	2b20      	cmp	r3, #32
700052b4:	d871      	bhi.n	7000539a <UART_SetConfig+0x51e>
700052b6:	a201      	add	r2, pc, #4	@ (adr r2, 700052bc <UART_SetConfig+0x440>)
700052b8:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
700052bc:	70005347 	.word	0x70005347
700052c0:	7000534f 	.word	0x7000534f
700052c4:	7000539b 	.word	0x7000539b
700052c8:	7000539b 	.word	0x7000539b
700052cc:	70005357 	.word	0x70005357
700052d0:	7000539b 	.word	0x7000539b
700052d4:	7000539b 	.word	0x7000539b
700052d8:	7000539b 	.word	0x7000539b
700052dc:	7000535f 	.word	0x7000535f
700052e0:	7000539b 	.word	0x7000539b
700052e4:	7000539b 	.word	0x7000539b
700052e8:	7000539b 	.word	0x7000539b
700052ec:	7000539b 	.word	0x7000539b
700052f0:	7000539b 	.word	0x7000539b
700052f4:	7000539b 	.word	0x7000539b
700052f8:	7000539b 	.word	0x7000539b
700052fc:	70005367 	.word	0x70005367
70005300:	7000539b 	.word	0x7000539b
70005304:	7000539b 	.word	0x7000539b
70005308:	7000539b 	.word	0x7000539b
7000530c:	7000539b 	.word	0x7000539b
70005310:	7000539b 	.word	0x7000539b
70005314:	7000539b 	.word	0x7000539b
70005318:	7000539b 	.word	0x7000539b
7000531c:	7000539b 	.word	0x7000539b
70005320:	7000539b 	.word	0x7000539b
70005324:	7000539b 	.word	0x7000539b
70005328:	7000539b 	.word	0x7000539b
7000532c:	7000539b 	.word	0x7000539b
70005330:	7000539b 	.word	0x7000539b
70005334:	7000539b 	.word	0x7000539b
70005338:	7000539b 	.word	0x7000539b
7000533c:	7000538d 	.word	0x7000538d
70005340:	2b40      	cmp	r3, #64	@ 0x40
70005342:	d026      	beq.n	70005392 <UART_SetConfig+0x516>
70005344:	e029      	b.n	7000539a <UART_SetConfig+0x51e>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
70005346:	f7fc ff47 	bl	700021d8 <HAL_RCC_GetPCLK1Freq>
7000534a:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
7000534c:	e02b      	b.n	700053a6 <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
7000534e:	f7fc ff5f 	bl	70002210 <HAL_RCC_GetPCLK2Freq>
70005352:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70005354:	e027      	b.n	700053a6 <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_PLL2Q:
        pclk = HAL_RCC_GetPLL2QFreq();
70005356:	f7fc ffbf 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
7000535a:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
7000535c:	e023      	b.n	700053a6 <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_PLL3Q:
        pclk = HAL_RCC_GetPLL3QFreq();
7000535e:	f7fd f82b 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
70005362:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
70005364:	e01f      	b.n	700053a6 <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
70005366:	4b2d      	ldr	r3, [pc, #180]	@ (7000541c <UART_SetConfig+0x5a0>)
70005368:	681b      	ldr	r3, [r3, #0]
7000536a:	f003 0320 	and.w	r3, r3, #32
7000536e:	2b00      	cmp	r3, #0
70005370:	d009      	beq.n	70005386 <UART_SetConfig+0x50a>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
70005372:	4b2a      	ldr	r3, [pc, #168]	@ (7000541c <UART_SetConfig+0x5a0>)
70005374:	681b      	ldr	r3, [r3, #0]
70005376:	08db      	lsrs	r3, r3, #3
70005378:	f003 0303 	and.w	r3, r3, #3
7000537c:	4a24      	ldr	r2, [pc, #144]	@ (70005410 <UART_SetConfig+0x594>)
7000537e:	fa22 f303 	lsr.w	r3, r2, r3
70005382:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
70005384:	e00f      	b.n	700053a6 <UART_SetConfig+0x52a>
          pclk = (uint32_t) HSI_VALUE;
70005386:	4b22      	ldr	r3, [pc, #136]	@ (70005410 <UART_SetConfig+0x594>)
70005388:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
7000538a:	e00c      	b.n	700053a6 <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
7000538c:	4b21      	ldr	r3, [pc, #132]	@ (70005414 <UART_SetConfig+0x598>)
7000538e:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
70005390:	e009      	b.n	700053a6 <UART_SetConfig+0x52a>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
70005392:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
70005396:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
70005398:	e005      	b.n	700053a6 <UART_SetConfig+0x52a>
      default:
        pclk = 0U;
7000539a:	2300      	movs	r3, #0
7000539c:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = HAL_ERROR;
7000539e:	2301      	movs	r3, #1
700053a0:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
        break;
700053a4:	bf00      	nop
    }

    /* USARTDIV must be greater than or equal to 0d16 */
    if (pclk != 0U)
700053a6:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700053a8:	2b00      	cmp	r3, #0
700053aa:	f000 80df 	beq.w	7000556c <UART_SetConfig+0x6f0>
    {
      usartdiv = (uint32_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
700053ae:	697b      	ldr	r3, [r7, #20]
700053b0:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
700053b2:	4a19      	ldr	r2, [pc, #100]	@ (70005418 <UART_SetConfig+0x59c>)
700053b4:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
700053b8:	461a      	mov	r2, r3
700053ba:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700053bc:	fbb3 f3f2 	udiv	r3, r3, r2
700053c0:	005a      	lsls	r2, r3, #1
700053c2:	697b      	ldr	r3, [r7, #20]
700053c4:	685b      	ldr	r3, [r3, #4]
700053c6:	085b      	lsrs	r3, r3, #1
700053c8:	441a      	add	r2, r3
700053ca:	697b      	ldr	r3, [r7, #20]
700053cc:	685b      	ldr	r3, [r3, #4]
700053ce:	fbb2 f3f3 	udiv	r3, r2, r3
700053d2:	623b      	str	r3, [r7, #32]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
700053d4:	6a3b      	ldr	r3, [r7, #32]
700053d6:	2b0f      	cmp	r3, #15
700053d8:	d916      	bls.n	70005408 <UART_SetConfig+0x58c>
700053da:	6a3b      	ldr	r3, [r7, #32]
700053dc:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
700053e0:	d212      	bcs.n	70005408 <UART_SetConfig+0x58c>
      {
        brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
700053e2:	6a3b      	ldr	r3, [r7, #32]
700053e4:	b29b      	uxth	r3, r3
700053e6:	f023 030f 	bic.w	r3, r3, #15
700053ea:	83fb      	strh	r3, [r7, #30]
        brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
700053ec:	6a3b      	ldr	r3, [r7, #32]
700053ee:	085b      	lsrs	r3, r3, #1
700053f0:	b29b      	uxth	r3, r3
700053f2:	f003 0307 	and.w	r3, r3, #7
700053f6:	b29a      	uxth	r2, r3
700053f8:	8bfb      	ldrh	r3, [r7, #30]
700053fa:	4313      	orrs	r3, r2
700053fc:	83fb      	strh	r3, [r7, #30]
        huart->Instance->BRR = brrtemp;
700053fe:	697b      	ldr	r3, [r7, #20]
70005400:	681b      	ldr	r3, [r3, #0]
70005402:	8bfa      	ldrh	r2, [r7, #30]
70005404:	60da      	str	r2, [r3, #12]
70005406:	e0b1      	b.n	7000556c <UART_SetConfig+0x6f0>
      }
      else
      {
        ret = HAL_ERROR;
70005408:	2301      	movs	r3, #1
7000540a:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
7000540e:	e0ad      	b.n	7000556c <UART_SetConfig+0x6f0>
70005410:	03d09000 	.word	0x03d09000
70005414:	003d0900 	.word	0x003d0900
70005418:	70009e54 	.word	0x70009e54
7000541c:	58024400 	.word	0x58024400
      }
    }
  }
  else
  {
    switch (clocksource)
70005420:	f897 302b 	ldrb.w	r3, [r7, #43]	@ 0x2b
70005424:	2b20      	cmp	r3, #32
70005426:	dc49      	bgt.n	700054bc <UART_SetConfig+0x640>
70005428:	2b00      	cmp	r3, #0
7000542a:	db74      	blt.n	70005516 <UART_SetConfig+0x69a>
7000542c:	2b20      	cmp	r3, #32
7000542e:	d872      	bhi.n	70005516 <UART_SetConfig+0x69a>
70005430:	a201      	add	r2, pc, #4	@ (adr r2, 70005438 <UART_SetConfig+0x5bc>)
70005432:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70005436:	bf00      	nop
70005438:	700054c3 	.word	0x700054c3
7000543c:	700054cb 	.word	0x700054cb
70005440:	70005517 	.word	0x70005517
70005444:	70005517 	.word	0x70005517
70005448:	700054d3 	.word	0x700054d3
7000544c:	70005517 	.word	0x70005517
70005450:	70005517 	.word	0x70005517
70005454:	70005517 	.word	0x70005517
70005458:	700054db 	.word	0x700054db
7000545c:	70005517 	.word	0x70005517
70005460:	70005517 	.word	0x70005517
70005464:	70005517 	.word	0x70005517
70005468:	70005517 	.word	0x70005517
7000546c:	70005517 	.word	0x70005517
70005470:	70005517 	.word	0x70005517
70005474:	70005517 	.word	0x70005517
70005478:	700054e3 	.word	0x700054e3
7000547c:	70005517 	.word	0x70005517
70005480:	70005517 	.word	0x70005517
70005484:	70005517 	.word	0x70005517
70005488:	70005517 	.word	0x70005517
7000548c:	70005517 	.word	0x70005517
70005490:	70005517 	.word	0x70005517
70005494:	70005517 	.word	0x70005517
70005498:	70005517 	.word	0x70005517
7000549c:	70005517 	.word	0x70005517
700054a0:	70005517 	.word	0x70005517
700054a4:	70005517 	.word	0x70005517
700054a8:	70005517 	.word	0x70005517
700054ac:	70005517 	.word	0x70005517
700054b0:	70005517 	.word	0x70005517
700054b4:	70005517 	.word	0x70005517
700054b8:	70005509 	.word	0x70005509
700054bc:	2b40      	cmp	r3, #64	@ 0x40
700054be:	d026      	beq.n	7000550e <UART_SetConfig+0x692>
700054c0:	e029      	b.n	70005516 <UART_SetConfig+0x69a>
    {
      case UART_CLOCKSOURCE_PCLK1:
        pclk = HAL_RCC_GetPCLK1Freq();
700054c2:	f7fc fe89 	bl	700021d8 <HAL_RCC_GetPCLK1Freq>
700054c6:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700054c8:	e02b      	b.n	70005522 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_PCLK2:
        pclk = HAL_RCC_GetPCLK2Freq();
700054ca:	f7fc fea1 	bl	70002210 <HAL_RCC_GetPCLK2Freq>
700054ce:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700054d0:	e027      	b.n	70005522 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_PLL2Q:
        pclk = HAL_RCC_GetPLL2QFreq();
700054d2:	f7fc ff01 	bl	700022d8 <HAL_RCC_GetPLL2QFreq>
700054d6:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700054d8:	e023      	b.n	70005522 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_PLL3Q:
        pclk = HAL_RCC_GetPLL3QFreq();
700054da:	f7fc ff6d 	bl	700023b8 <HAL_RCC_GetPLL3QFreq>
700054de:	6278      	str	r0, [r7, #36]	@ 0x24
        break;
700054e0:	e01f      	b.n	70005522 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_HSI:
        if (__HAL_RCC_GET_FLAG(RCC_FLAG_HSIDIV) != 0U)
700054e2:	4b2d      	ldr	r3, [pc, #180]	@ (70005598 <UART_SetConfig+0x71c>)
700054e4:	681b      	ldr	r3, [r3, #0]
700054e6:	f003 0320 	and.w	r3, r3, #32
700054ea:	2b00      	cmp	r3, #0
700054ec:	d009      	beq.n	70005502 <UART_SetConfig+0x686>
        {
          pclk = (uint32_t)(HSI_VALUE >> (__HAL_RCC_GET_HSI_DIVIDER() >> 3U));
700054ee:	4b2a      	ldr	r3, [pc, #168]	@ (70005598 <UART_SetConfig+0x71c>)
700054f0:	681b      	ldr	r3, [r3, #0]
700054f2:	08db      	lsrs	r3, r3, #3
700054f4:	f003 0303 	and.w	r3, r3, #3
700054f8:	4a28      	ldr	r2, [pc, #160]	@ (7000559c <UART_SetConfig+0x720>)
700054fa:	fa22 f303 	lsr.w	r3, r2, r3
700054fe:	627b      	str	r3, [r7, #36]	@ 0x24
        }
        else
        {
          pclk = (uint32_t) HSI_VALUE;
        }
        break;
70005500:	e00f      	b.n	70005522 <UART_SetConfig+0x6a6>
          pclk = (uint32_t) HSI_VALUE;
70005502:	4b26      	ldr	r3, [pc, #152]	@ (7000559c <UART_SetConfig+0x720>)
70005504:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
70005506:	e00c      	b.n	70005522 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_CSI:
        pclk = (uint32_t) CSI_VALUE;
70005508:	4b25      	ldr	r3, [pc, #148]	@ (700055a0 <UART_SetConfig+0x724>)
7000550a:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
7000550c:	e009      	b.n	70005522 <UART_SetConfig+0x6a6>
      case UART_CLOCKSOURCE_LSE:
        pclk = (uint32_t) LSE_VALUE;
7000550e:	f44f 4300 	mov.w	r3, #32768	@ 0x8000
70005512:	627b      	str	r3, [r7, #36]	@ 0x24
        break;
70005514:	e005      	b.n	70005522 <UART_SetConfig+0x6a6>
      default:
        pclk = 0U;
70005516:	2300      	movs	r3, #0
70005518:	627b      	str	r3, [r7, #36]	@ 0x24
        ret = HAL_ERROR;
7000551a:	2301      	movs	r3, #1
7000551c:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
        break;
70005520:	bf00      	nop
    }

    if (pclk != 0U)
70005522:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
70005524:	2b00      	cmp	r3, #0
70005526:	d021      	beq.n	7000556c <UART_SetConfig+0x6f0>
    {
      /* USARTDIV must be greater than or equal to 0d16 */
      usartdiv = (uint32_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
70005528:	697b      	ldr	r3, [r7, #20]
7000552a:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
7000552c:	4a1d      	ldr	r2, [pc, #116]	@ (700055a4 <UART_SetConfig+0x728>)
7000552e:	f832 3013 	ldrh.w	r3, [r2, r3, lsl #1]
70005532:	461a      	mov	r2, r3
70005534:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
70005536:	fbb3 f2f2 	udiv	r2, r3, r2
7000553a:	697b      	ldr	r3, [r7, #20]
7000553c:	685b      	ldr	r3, [r3, #4]
7000553e:	085b      	lsrs	r3, r3, #1
70005540:	441a      	add	r2, r3
70005542:	697b      	ldr	r3, [r7, #20]
70005544:	685b      	ldr	r3, [r3, #4]
70005546:	fbb2 f3f3 	udiv	r3, r2, r3
7000554a:	623b      	str	r3, [r7, #32]
      if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
7000554c:	6a3b      	ldr	r3, [r7, #32]
7000554e:	2b0f      	cmp	r3, #15
70005550:	d909      	bls.n	70005566 <UART_SetConfig+0x6ea>
70005552:	6a3b      	ldr	r3, [r7, #32]
70005554:	f5b3 3f80 	cmp.w	r3, #65536	@ 0x10000
70005558:	d205      	bcs.n	70005566 <UART_SetConfig+0x6ea>
      {
        huart->Instance->BRR = (uint16_t)usartdiv;
7000555a:	6a3b      	ldr	r3, [r7, #32]
7000555c:	b29a      	uxth	r2, r3
7000555e:	697b      	ldr	r3, [r7, #20]
70005560:	681b      	ldr	r3, [r3, #0]
70005562:	60da      	str	r2, [r3, #12]
70005564:	e002      	b.n	7000556c <UART_SetConfig+0x6f0>
      }
      else
      {
        ret = HAL_ERROR;
70005566:	2301      	movs	r3, #1
70005568:	f887 302a 	strb.w	r3, [r7, #42]	@ 0x2a
      }
    }
  }

  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
7000556c:	697b      	ldr	r3, [r7, #20]
7000556e:	2201      	movs	r2, #1
70005570:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
  huart->NbRxDataToProcess = 1;
70005574:	697b      	ldr	r3, [r7, #20]
70005576:	2201      	movs	r2, #1
70005578:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
7000557c:	697b      	ldr	r3, [r7, #20]
7000557e:	2200      	movs	r2, #0
70005580:	675a      	str	r2, [r3, #116]	@ 0x74
  huart->TxISR = NULL;
70005582:	697b      	ldr	r3, [r7, #20]
70005584:	2200      	movs	r2, #0
70005586:	679a      	str	r2, [r3, #120]	@ 0x78

  return ret;
70005588:	f897 302a 	ldrb.w	r3, [r7, #42]	@ 0x2a
}
7000558c:	4618      	mov	r0, r3
7000558e:	3730      	adds	r7, #48	@ 0x30
70005590:	46bd      	mov	sp, r7
70005592:	e8bd 8fb0 	ldmia.w	sp!, {r4, r5, r7, r8, r9, sl, fp, pc}
70005596:	bf00      	nop
70005598:	58024400 	.word	0x58024400
7000559c:	03d09000 	.word	0x03d09000
700055a0:	003d0900 	.word	0x003d0900
700055a4:	70009e54 	.word	0x70009e54

700055a8 <UART_AdvFeatureConfig>:
  * @brief Configure the UART peripheral advanced features.
  * @param huart UART handle.
  * @retval None
  */
void UART_AdvFeatureConfig(UART_HandleTypeDef *huart)
{
700055a8:	b480      	push	{r7}
700055aa:	b083      	sub	sp, #12
700055ac:	af00      	add	r7, sp, #0
700055ae:	6078      	str	r0, [r7, #4]
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
700055b0:	687b      	ldr	r3, [r7, #4]
700055b2:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700055b4:	f003 0308 	and.w	r3, r3, #8
700055b8:	2b00      	cmp	r3, #0
700055ba:	d00a      	beq.n	700055d2 <UART_AdvFeatureConfig+0x2a>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
700055bc:	687b      	ldr	r3, [r7, #4]
700055be:	681b      	ldr	r3, [r3, #0]
700055c0:	685b      	ldr	r3, [r3, #4]
700055c2:	f423 4100 	bic.w	r1, r3, #32768	@ 0x8000
700055c6:	687b      	ldr	r3, [r7, #4]
700055c8:	6b9a      	ldr	r2, [r3, #56]	@ 0x38
700055ca:	687b      	ldr	r3, [r7, #4]
700055cc:	681b      	ldr	r3, [r3, #0]
700055ce:	430a      	orrs	r2, r1
700055d0:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
700055d2:	687b      	ldr	r3, [r7, #4]
700055d4:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700055d6:	f003 0301 	and.w	r3, r3, #1
700055da:	2b00      	cmp	r3, #0
700055dc:	d00a      	beq.n	700055f4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
700055de:	687b      	ldr	r3, [r7, #4]
700055e0:	681b      	ldr	r3, [r3, #0]
700055e2:	685b      	ldr	r3, [r3, #4]
700055e4:	f423 3100 	bic.w	r1, r3, #131072	@ 0x20000
700055e8:	687b      	ldr	r3, [r7, #4]
700055ea:	6ada      	ldr	r2, [r3, #44]	@ 0x2c
700055ec:	687b      	ldr	r3, [r7, #4]
700055ee:	681b      	ldr	r3, [r3, #0]
700055f0:	430a      	orrs	r2, r1
700055f2:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
700055f4:	687b      	ldr	r3, [r7, #4]
700055f6:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700055f8:	f003 0302 	and.w	r3, r3, #2
700055fc:	2b00      	cmp	r3, #0
700055fe:	d00a      	beq.n	70005616 <UART_AdvFeatureConfig+0x6e>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
70005600:	687b      	ldr	r3, [r7, #4]
70005602:	681b      	ldr	r3, [r3, #0]
70005604:	685b      	ldr	r3, [r3, #4]
70005606:	f423 3180 	bic.w	r1, r3, #65536	@ 0x10000
7000560a:	687b      	ldr	r3, [r7, #4]
7000560c:	6b1a      	ldr	r2, [r3, #48]	@ 0x30
7000560e:	687b      	ldr	r3, [r7, #4]
70005610:	681b      	ldr	r3, [r3, #0]
70005612:	430a      	orrs	r2, r1
70005614:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
70005616:	687b      	ldr	r3, [r7, #4]
70005618:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
7000561a:	f003 0304 	and.w	r3, r3, #4
7000561e:	2b00      	cmp	r3, #0
70005620:	d00a      	beq.n	70005638 <UART_AdvFeatureConfig+0x90>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
70005622:	687b      	ldr	r3, [r7, #4]
70005624:	681b      	ldr	r3, [r3, #0]
70005626:	685b      	ldr	r3, [r3, #4]
70005628:	f423 2180 	bic.w	r1, r3, #262144	@ 0x40000
7000562c:	687b      	ldr	r3, [r7, #4]
7000562e:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
70005630:	687b      	ldr	r3, [r7, #4]
70005632:	681b      	ldr	r3, [r3, #0]
70005634:	430a      	orrs	r2, r1
70005636:	605a      	str	r2, [r3, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
70005638:	687b      	ldr	r3, [r7, #4]
7000563a:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
7000563c:	f003 0310 	and.w	r3, r3, #16
70005640:	2b00      	cmp	r3, #0
70005642:	d00a      	beq.n	7000565a <UART_AdvFeatureConfig+0xb2>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
70005644:	687b      	ldr	r3, [r7, #4]
70005646:	681b      	ldr	r3, [r3, #0]
70005648:	689b      	ldr	r3, [r3, #8]
7000564a:	f423 5180 	bic.w	r1, r3, #4096	@ 0x1000
7000564e:	687b      	ldr	r3, [r7, #4]
70005650:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
70005652:	687b      	ldr	r3, [r7, #4]
70005654:	681b      	ldr	r3, [r3, #0]
70005656:	430a      	orrs	r2, r1
70005658:	609a      	str	r2, [r3, #8]
  }

#if defined(HAL_DMA_MODULE_ENABLED)
  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
7000565a:	687b      	ldr	r3, [r7, #4]
7000565c:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
7000565e:	f003 0320 	and.w	r3, r3, #32
70005662:	2b00      	cmp	r3, #0
70005664:	d00a      	beq.n	7000567c <UART_AdvFeatureConfig+0xd4>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
70005666:	687b      	ldr	r3, [r7, #4]
70005668:	681b      	ldr	r3, [r3, #0]
7000566a:	689b      	ldr	r3, [r3, #8]
7000566c:	f423 5100 	bic.w	r1, r3, #8192	@ 0x2000
70005670:	687b      	ldr	r3, [r7, #4]
70005672:	6c1a      	ldr	r2, [r3, #64]	@ 0x40
70005674:	687b      	ldr	r3, [r7, #4]
70005676:	681b      	ldr	r3, [r3, #0]
70005678:	430a      	orrs	r2, r1
7000567a:	609a      	str	r2, [r3, #8]
  }
#endif /* HAL_DMA_MODULE_ENABLED */

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
7000567c:	687b      	ldr	r3, [r7, #4]
7000567e:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
70005680:	f003 0340 	and.w	r3, r3, #64	@ 0x40
70005684:	2b00      	cmp	r3, #0
70005686:	d01a      	beq.n	700056be <UART_AdvFeatureConfig+0x116>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
70005688:	687b      	ldr	r3, [r7, #4]
7000568a:	681b      	ldr	r3, [r3, #0]
7000568c:	685b      	ldr	r3, [r3, #4]
7000568e:	f423 1180 	bic.w	r1, r3, #1048576	@ 0x100000
70005692:	687b      	ldr	r3, [r7, #4]
70005694:	6c5a      	ldr	r2, [r3, #68]	@ 0x44
70005696:	687b      	ldr	r3, [r7, #4]
70005698:	681b      	ldr	r3, [r3, #0]
7000569a:	430a      	orrs	r2, r1
7000569c:	605a      	str	r2, [r3, #4]
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
7000569e:	687b      	ldr	r3, [r7, #4]
700056a0:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
700056a2:	f5b3 1f80 	cmp.w	r3, #1048576	@ 0x100000
700056a6:	d10a      	bne.n	700056be <UART_AdvFeatureConfig+0x116>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
700056a8:	687b      	ldr	r3, [r7, #4]
700056aa:	681b      	ldr	r3, [r3, #0]
700056ac:	685b      	ldr	r3, [r3, #4]
700056ae:	f423 01c0 	bic.w	r1, r3, #6291456	@ 0x600000
700056b2:	687b      	ldr	r3, [r7, #4]
700056b4:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
700056b6:	687b      	ldr	r3, [r7, #4]
700056b8:	681b      	ldr	r3, [r3, #0]
700056ba:	430a      	orrs	r2, r1
700056bc:	605a      	str	r2, [r3, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
700056be:	687b      	ldr	r3, [r7, #4]
700056c0:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700056c2:	f003 0380 	and.w	r3, r3, #128	@ 0x80
700056c6:	2b00      	cmp	r3, #0
700056c8:	d00a      	beq.n	700056e0 <UART_AdvFeatureConfig+0x138>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
700056ca:	687b      	ldr	r3, [r7, #4]
700056cc:	681b      	ldr	r3, [r3, #0]
700056ce:	685b      	ldr	r3, [r3, #4]
700056d0:	f423 2100 	bic.w	r1, r3, #524288	@ 0x80000
700056d4:	687b      	ldr	r3, [r7, #4]
700056d6:	6cda      	ldr	r2, [r3, #76]	@ 0x4c
700056d8:	687b      	ldr	r3, [r7, #4]
700056da:	681b      	ldr	r3, [r3, #0]
700056dc:	430a      	orrs	r2, r1
700056de:	605a      	str	r2, [r3, #4]
  }
}
700056e0:	bf00      	nop
700056e2:	370c      	adds	r7, #12
700056e4:	46bd      	mov	sp, r7
700056e6:	f85d 7b04 	ldr.w	r7, [sp], #4
700056ea:	4770      	bx	lr

700056ec <UART_CheckIdleState>:
  * @brief Check the UART Idle State.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef UART_CheckIdleState(UART_HandleTypeDef *huart)
{
700056ec:	b580      	push	{r7, lr}
700056ee:	b098      	sub	sp, #96	@ 0x60
700056f0:	af02      	add	r7, sp, #8
700056f2:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Initialize the UART ErrorCode */
  huart->ErrorCode = HAL_UART_ERROR_NONE;
700056f4:	687b      	ldr	r3, [r7, #4]
700056f6:	2200      	movs	r2, #0
700056f8:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

  /* Init tickstart for timeout management */
  tickstart = HAL_GetTick();
700056fc:	f7fc f822 	bl	70001744 <HAL_GetTick>
70005700:	6578      	str	r0, [r7, #84]	@ 0x54

  /* Check if the Transmitter is enabled */
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
70005702:	687b      	ldr	r3, [r7, #4]
70005704:	681b      	ldr	r3, [r3, #0]
70005706:	681b      	ldr	r3, [r3, #0]
70005708:	f003 0308 	and.w	r3, r3, #8
7000570c:	2b08      	cmp	r3, #8
7000570e:	d12f      	bne.n	70005770 <UART_CheckIdleState+0x84>
  {
    /* Wait until TEACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
70005710:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
70005714:	9300      	str	r3, [sp, #0]
70005716:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
70005718:	2200      	movs	r2, #0
7000571a:	f44f 1100 	mov.w	r1, #2097152	@ 0x200000
7000571e:	6878      	ldr	r0, [r7, #4]
70005720:	f000 f88e 	bl	70005840 <UART_WaitOnFlagUntilTimeout>
70005724:	4603      	mov	r3, r0
70005726:	2b00      	cmp	r3, #0
70005728:	d022      	beq.n	70005770 <UART_CheckIdleState+0x84>
    {
      /* Disable TXE interrupt for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_TXEIE_TXFNFIE));
7000572a:	687b      	ldr	r3, [r7, #4]
7000572c:	681b      	ldr	r3, [r3, #0]
7000572e:	63bb      	str	r3, [r7, #56]	@ 0x38
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70005730:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
70005732:	e853 3f00 	ldrex	r3, [r3]
70005736:	637b      	str	r3, [r7, #52]	@ 0x34
   return(result);
70005738:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
7000573a:	f023 0380 	bic.w	r3, r3, #128	@ 0x80
7000573e:	653b      	str	r3, [r7, #80]	@ 0x50
70005740:	687b      	ldr	r3, [r7, #4]
70005742:	681b      	ldr	r3, [r3, #0]
70005744:	461a      	mov	r2, r3
70005746:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
70005748:	647b      	str	r3, [r7, #68]	@ 0x44
7000574a:	643a      	str	r2, [r7, #64]	@ 0x40
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
7000574c:	6c39      	ldr	r1, [r7, #64]	@ 0x40
7000574e:	6c7a      	ldr	r2, [r7, #68]	@ 0x44
70005750:	e841 2300 	strex	r3, r2, [r1]
70005754:	63fb      	str	r3, [r7, #60]	@ 0x3c
   return(result);
70005756:	6bfb      	ldr	r3, [r7, #60]	@ 0x3c
70005758:	2b00      	cmp	r3, #0
7000575a:	d1e6      	bne.n	7000572a <UART_CheckIdleState+0x3e>

      huart->gState = HAL_UART_STATE_READY;
7000575c:	687b      	ldr	r3, [r7, #4]
7000575e:	2220      	movs	r2, #32
70005760:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

      __HAL_UNLOCK(huart);
70005764:	687b      	ldr	r3, [r7, #4]
70005766:	2200      	movs	r2, #0
70005768:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
7000576c:	2303      	movs	r3, #3
7000576e:	e063      	b.n	70005838 <UART_CheckIdleState+0x14c>
    }
  }

  /* Check if the Receiver is enabled */
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
70005770:	687b      	ldr	r3, [r7, #4]
70005772:	681b      	ldr	r3, [r3, #0]
70005774:	681b      	ldr	r3, [r3, #0]
70005776:	f003 0304 	and.w	r3, r3, #4
7000577a:	2b04      	cmp	r3, #4
7000577c:	d149      	bne.n	70005812 <UART_CheckIdleState+0x126>
  {
    /* Wait until REACK flag is set */
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
7000577e:	f06f 437e 	mvn.w	r3, #4261412864	@ 0xfe000000
70005782:	9300      	str	r3, [sp, #0]
70005784:	6d7b      	ldr	r3, [r7, #84]	@ 0x54
70005786:	2200      	movs	r2, #0
70005788:	f44f 0180 	mov.w	r1, #4194304	@ 0x400000
7000578c:	6878      	ldr	r0, [r7, #4]
7000578e:	f000 f857 	bl	70005840 <UART_WaitOnFlagUntilTimeout>
70005792:	4603      	mov	r3, r0
70005794:	2b00      	cmp	r3, #0
70005796:	d03c      	beq.n	70005812 <UART_CheckIdleState+0x126>
    {
      /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error)
      interrupts for the interrupt process */
      ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
70005798:	687b      	ldr	r3, [r7, #4]
7000579a:	681b      	ldr	r3, [r3, #0]
7000579c:	627b      	str	r3, [r7, #36]	@ 0x24
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
7000579e:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
700057a0:	e853 3f00 	ldrex	r3, [r3]
700057a4:	623b      	str	r3, [r7, #32]
   return(result);
700057a6:	6a3b      	ldr	r3, [r7, #32]
700057a8:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
700057ac:	64fb      	str	r3, [r7, #76]	@ 0x4c
700057ae:	687b      	ldr	r3, [r7, #4]
700057b0:	681b      	ldr	r3, [r3, #0]
700057b2:	461a      	mov	r2, r3
700057b4:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
700057b6:	633b      	str	r3, [r7, #48]	@ 0x30
700057b8:	62fa      	str	r2, [r7, #44]	@ 0x2c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
700057ba:	6af9      	ldr	r1, [r7, #44]	@ 0x2c
700057bc:	6b3a      	ldr	r2, [r7, #48]	@ 0x30
700057be:	e841 2300 	strex	r3, r2, [r1]
700057c2:	62bb      	str	r3, [r7, #40]	@ 0x28
   return(result);
700057c4:	6abb      	ldr	r3, [r7, #40]	@ 0x28
700057c6:	2b00      	cmp	r3, #0
700057c8:	d1e6      	bne.n	70005798 <UART_CheckIdleState+0xac>
      ATOMIC_CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
700057ca:	687b      	ldr	r3, [r7, #4]
700057cc:	681b      	ldr	r3, [r3, #0]
700057ce:	3308      	adds	r3, #8
700057d0:	613b      	str	r3, [r7, #16]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
700057d2:	693b      	ldr	r3, [r7, #16]
700057d4:	e853 3f00 	ldrex	r3, [r3]
700057d8:	60fb      	str	r3, [r7, #12]
   return(result);
700057da:	68fb      	ldr	r3, [r7, #12]
700057dc:	f023 0301 	bic.w	r3, r3, #1
700057e0:	64bb      	str	r3, [r7, #72]	@ 0x48
700057e2:	687b      	ldr	r3, [r7, #4]
700057e4:	681b      	ldr	r3, [r3, #0]
700057e6:	3308      	adds	r3, #8
700057e8:	6cba      	ldr	r2, [r7, #72]	@ 0x48
700057ea:	61fa      	str	r2, [r7, #28]
700057ec:	61bb      	str	r3, [r7, #24]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
700057ee:	69b9      	ldr	r1, [r7, #24]
700057f0:	69fa      	ldr	r2, [r7, #28]
700057f2:	e841 2300 	strex	r3, r2, [r1]
700057f6:	617b      	str	r3, [r7, #20]
   return(result);
700057f8:	697b      	ldr	r3, [r7, #20]
700057fa:	2b00      	cmp	r3, #0
700057fc:	d1e5      	bne.n	700057ca <UART_CheckIdleState+0xde>

      huart->RxState = HAL_UART_STATE_READY;
700057fe:	687b      	ldr	r3, [r7, #4]
70005800:	2220      	movs	r2, #32
70005802:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c

      __HAL_UNLOCK(huart);
70005806:	687b      	ldr	r3, [r7, #4]
70005808:	2200      	movs	r2, #0
7000580a:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

      /* Timeout occurred */
      return HAL_TIMEOUT;
7000580e:	2303      	movs	r3, #3
70005810:	e012      	b.n	70005838 <UART_CheckIdleState+0x14c>
    }
  }

  /* Initialize the UART State */
  huart->gState = HAL_UART_STATE_READY;
70005812:	687b      	ldr	r3, [r7, #4]
70005814:	2220      	movs	r2, #32
70005816:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  huart->RxState = HAL_UART_STATE_READY;
7000581a:	687b      	ldr	r3, [r7, #4]
7000581c:	2220      	movs	r2, #32
7000581e:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
70005822:	687b      	ldr	r3, [r7, #4]
70005824:	2200      	movs	r2, #0
70005826:	66da      	str	r2, [r3, #108]	@ 0x6c
  huart->RxEventType = HAL_UART_RXEVENT_TC;
70005828:	687b      	ldr	r3, [r7, #4]
7000582a:	2200      	movs	r2, #0
7000582c:	671a      	str	r2, [r3, #112]	@ 0x70

  __HAL_UNLOCK(huart);
7000582e:	687b      	ldr	r3, [r7, #4]
70005830:	2200      	movs	r2, #0
70005832:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
70005836:	2300      	movs	r3, #0
}
70005838:	4618      	mov	r0, r3
7000583a:	3758      	adds	r7, #88	@ 0x58
7000583c:	46bd      	mov	sp, r7
7000583e:	bd80      	pop	{r7, pc}

70005840 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
70005840:	b580      	push	{r7, lr}
70005842:	b084      	sub	sp, #16
70005844:	af00      	add	r7, sp, #0
70005846:	60f8      	str	r0, [r7, #12]
70005848:	60b9      	str	r1, [r7, #8]
7000584a:	603b      	str	r3, [r7, #0]
7000584c:	4613      	mov	r3, r2
7000584e:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
70005850:	e04f      	b.n	700058f2 <UART_WaitOnFlagUntilTimeout+0xb2>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
70005852:	69bb      	ldr	r3, [r7, #24]
70005854:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
70005858:	d04b      	beq.n	700058f2 <UART_WaitOnFlagUntilTimeout+0xb2>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
7000585a:	f7fb ff73 	bl	70001744 <HAL_GetTick>
7000585e:	4602      	mov	r2, r0
70005860:	683b      	ldr	r3, [r7, #0]
70005862:	1ad3      	subs	r3, r2, r3
70005864:	69ba      	ldr	r2, [r7, #24]
70005866:	429a      	cmp	r2, r3
70005868:	d302      	bcc.n	70005870 <UART_WaitOnFlagUntilTimeout+0x30>
7000586a:	69bb      	ldr	r3, [r7, #24]
7000586c:	2b00      	cmp	r3, #0
7000586e:	d101      	bne.n	70005874 <UART_WaitOnFlagUntilTimeout+0x34>
      {

        return HAL_TIMEOUT;
70005870:	2303      	movs	r3, #3
70005872:	e04e      	b.n	70005912 <UART_WaitOnFlagUntilTimeout+0xd2>
      }

      if ((READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U) && (Flag != UART_FLAG_TXE) && (Flag != UART_FLAG_TC))
70005874:	68fb      	ldr	r3, [r7, #12]
70005876:	681b      	ldr	r3, [r3, #0]
70005878:	681b      	ldr	r3, [r3, #0]
7000587a:	f003 0304 	and.w	r3, r3, #4
7000587e:	2b00      	cmp	r3, #0
70005880:	d037      	beq.n	700058f2 <UART_WaitOnFlagUntilTimeout+0xb2>
70005882:	68bb      	ldr	r3, [r7, #8]
70005884:	2b80      	cmp	r3, #128	@ 0x80
70005886:	d034      	beq.n	700058f2 <UART_WaitOnFlagUntilTimeout+0xb2>
70005888:	68bb      	ldr	r3, [r7, #8]
7000588a:	2b40      	cmp	r3, #64	@ 0x40
7000588c:	d031      	beq.n	700058f2 <UART_WaitOnFlagUntilTimeout+0xb2>
      {
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_ORE) == SET)
7000588e:	68fb      	ldr	r3, [r7, #12]
70005890:	681b      	ldr	r3, [r3, #0]
70005892:	69db      	ldr	r3, [r3, #28]
70005894:	f003 0308 	and.w	r3, r3, #8
70005898:	2b08      	cmp	r3, #8
7000589a:	d110      	bne.n	700058be <UART_WaitOnFlagUntilTimeout+0x7e>
        {
          /* Clear Overrun Error flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_OREF);
7000589c:	68fb      	ldr	r3, [r7, #12]
7000589e:	681b      	ldr	r3, [r3, #0]
700058a0:	2208      	movs	r2, #8
700058a2:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
700058a4:	68f8      	ldr	r0, [r7, #12]
700058a6:	f000 f839 	bl	7000591c <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_ORE;
700058aa:	68fb      	ldr	r3, [r7, #12]
700058ac:	2208      	movs	r2, #8
700058ae:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
700058b2:	68fb      	ldr	r3, [r7, #12]
700058b4:	2200      	movs	r2, #0
700058b6:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_ERROR;
700058ba:	2301      	movs	r3, #1
700058bc:	e029      	b.n	70005912 <UART_WaitOnFlagUntilTimeout+0xd2>
        }
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
700058be:	68fb      	ldr	r3, [r7, #12]
700058c0:	681b      	ldr	r3, [r3, #0]
700058c2:	69db      	ldr	r3, [r3, #28]
700058c4:	f403 6300 	and.w	r3, r3, #2048	@ 0x800
700058c8:	f5b3 6f00 	cmp.w	r3, #2048	@ 0x800
700058cc:	d111      	bne.n	700058f2 <UART_WaitOnFlagUntilTimeout+0xb2>
        {
          /* Clear Receiver Timeout flag*/
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
700058ce:	68fb      	ldr	r3, [r7, #12]
700058d0:	681b      	ldr	r3, [r3, #0]
700058d2:	f44f 6200 	mov.w	r2, #2048	@ 0x800
700058d6:	621a      	str	r2, [r3, #32]

          /* Blocking error : transfer is aborted
          Set the UART state ready to be able to start again the process,
          Disable Rx Interrupts if ongoing */
          UART_EndRxTransfer(huart);
700058d8:	68f8      	ldr	r0, [r7, #12]
700058da:	f000 f81f 	bl	7000591c <UART_EndRxTransfer>

          huart->ErrorCode = HAL_UART_ERROR_RTO;
700058de:	68fb      	ldr	r3, [r7, #12]
700058e0:	2220      	movs	r2, #32
700058e2:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90

          /* Process Unlocked */
          __HAL_UNLOCK(huart);
700058e6:	68fb      	ldr	r3, [r7, #12]
700058e8:	2200      	movs	r2, #0
700058ea:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

          return HAL_TIMEOUT;
700058ee:	2303      	movs	r3, #3
700058f0:	e00f      	b.n	70005912 <UART_WaitOnFlagUntilTimeout+0xd2>
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
700058f2:	68fb      	ldr	r3, [r7, #12]
700058f4:	681b      	ldr	r3, [r3, #0]
700058f6:	69da      	ldr	r2, [r3, #28]
700058f8:	68bb      	ldr	r3, [r7, #8]
700058fa:	4013      	ands	r3, r2
700058fc:	68ba      	ldr	r2, [r7, #8]
700058fe:	429a      	cmp	r2, r3
70005900:	bf0c      	ite	eq
70005902:	2301      	moveq	r3, #1
70005904:	2300      	movne	r3, #0
70005906:	b2db      	uxtb	r3, r3
70005908:	461a      	mov	r2, r3
7000590a:	79fb      	ldrb	r3, [r7, #7]
7000590c:	429a      	cmp	r2, r3
7000590e:	d0a0      	beq.n	70005852 <UART_WaitOnFlagUntilTimeout+0x12>
        }
      }
    }
  }
  return HAL_OK;
70005910:	2300      	movs	r3, #0
}
70005912:	4618      	mov	r0, r3
70005914:	3710      	adds	r7, #16
70005916:	46bd      	mov	sp, r7
70005918:	bd80      	pop	{r7, pc}
	...

7000591c <UART_EndRxTransfer>:
  * @brief  End ongoing Rx transfer on UART peripheral (following error detection or Reception completion).
  * @param  huart UART handle.
  * @retval None
  */
static void UART_EndRxTransfer(UART_HandleTypeDef *huart)
{
7000591c:	b480      	push	{r7}
7000591e:	b095      	sub	sp, #84	@ 0x54
70005920:	af00      	add	r7, sp, #0
70005922:	6078      	str	r0, [r7, #4]
  /* Disable RXNE, PE and ERR (Frame error, noise error, overrun error) interrupts */
  ATOMIC_CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE));
70005924:	687b      	ldr	r3, [r7, #4]
70005926:	681b      	ldr	r3, [r3, #0]
70005928:	637b      	str	r3, [r7, #52]	@ 0x34
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
7000592a:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
7000592c:	e853 3f00 	ldrex	r3, [r3]
70005930:	633b      	str	r3, [r7, #48]	@ 0x30
   return(result);
70005932:	6b3b      	ldr	r3, [r7, #48]	@ 0x30
70005934:	f423 7390 	bic.w	r3, r3, #288	@ 0x120
70005938:	64fb      	str	r3, [r7, #76]	@ 0x4c
7000593a:	687b      	ldr	r3, [r7, #4]
7000593c:	681b      	ldr	r3, [r3, #0]
7000593e:	461a      	mov	r2, r3
70005940:	6cfb      	ldr	r3, [r7, #76]	@ 0x4c
70005942:	643b      	str	r3, [r7, #64]	@ 0x40
70005944:	63fa      	str	r2, [r7, #60]	@ 0x3c
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
70005946:	6bf9      	ldr	r1, [r7, #60]	@ 0x3c
70005948:	6c3a      	ldr	r2, [r7, #64]	@ 0x40
7000594a:	e841 2300 	strex	r3, r2, [r1]
7000594e:	63bb      	str	r3, [r7, #56]	@ 0x38
   return(result);
70005950:	6bbb      	ldr	r3, [r7, #56]	@ 0x38
70005952:	2b00      	cmp	r3, #0
70005954:	d1e6      	bne.n	70005924 <UART_EndRxTransfer+0x8>
  ATOMIC_CLEAR_BIT(huart->Instance->CR3, (USART_CR3_EIE | USART_CR3_RXFTIE));
70005956:	687b      	ldr	r3, [r7, #4]
70005958:	681b      	ldr	r3, [r3, #0]
7000595a:	3308      	adds	r3, #8
7000595c:	623b      	str	r3, [r7, #32]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
7000595e:	6a3b      	ldr	r3, [r7, #32]
70005960:	e853 3f00 	ldrex	r3, [r3]
70005964:	61fb      	str	r3, [r7, #28]
   return(result);
70005966:	69fa      	ldr	r2, [r7, #28]
70005968:	4b1e      	ldr	r3, [pc, #120]	@ (700059e4 <UART_EndRxTransfer+0xc8>)
7000596a:	4013      	ands	r3, r2
7000596c:	64bb      	str	r3, [r7, #72]	@ 0x48
7000596e:	687b      	ldr	r3, [r7, #4]
70005970:	681b      	ldr	r3, [r3, #0]
70005972:	3308      	adds	r3, #8
70005974:	6cba      	ldr	r2, [r7, #72]	@ 0x48
70005976:	62fa      	str	r2, [r7, #44]	@ 0x2c
70005978:	62bb      	str	r3, [r7, #40]	@ 0x28
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
7000597a:	6ab9      	ldr	r1, [r7, #40]	@ 0x28
7000597c:	6afa      	ldr	r2, [r7, #44]	@ 0x2c
7000597e:	e841 2300 	strex	r3, r2, [r1]
70005982:	627b      	str	r3, [r7, #36]	@ 0x24
   return(result);
70005984:	6a7b      	ldr	r3, [r7, #36]	@ 0x24
70005986:	2b00      	cmp	r3, #0
70005988:	d1e5      	bne.n	70005956 <UART_EndRxTransfer+0x3a>

  /* In case of reception waiting for IDLE event, disable also the IDLE IE interrupt source */
  if (huart->ReceptionType == HAL_UART_RECEPTION_TOIDLE)
7000598a:	687b      	ldr	r3, [r7, #4]
7000598c:	6edb      	ldr	r3, [r3, #108]	@ 0x6c
7000598e:	2b01      	cmp	r3, #1
70005990:	d118      	bne.n	700059c4 <UART_EndRxTransfer+0xa8>
  {
    ATOMIC_CLEAR_BIT(huart->Instance->CR1, USART_CR1_IDLEIE);
70005992:	687b      	ldr	r3, [r7, #4]
70005994:	681b      	ldr	r3, [r3, #0]
70005996:	60fb      	str	r3, [r7, #12]
   __ASM volatile ("ldrex %0, %1" : "=r" (result) : "Q" (*addr) );
70005998:	68fb      	ldr	r3, [r7, #12]
7000599a:	e853 3f00 	ldrex	r3, [r3]
7000599e:	60bb      	str	r3, [r7, #8]
   return(result);
700059a0:	68bb      	ldr	r3, [r7, #8]
700059a2:	f023 0310 	bic.w	r3, r3, #16
700059a6:	647b      	str	r3, [r7, #68]	@ 0x44
700059a8:	687b      	ldr	r3, [r7, #4]
700059aa:	681b      	ldr	r3, [r3, #0]
700059ac:	461a      	mov	r2, r3
700059ae:	6c7b      	ldr	r3, [r7, #68]	@ 0x44
700059b0:	61bb      	str	r3, [r7, #24]
700059b2:	617a      	str	r2, [r7, #20]
   __ASM volatile ("strex %0, %2, %1" : "=&r" (result), "=Q" (*addr) : "r" (value) );
700059b4:	6979      	ldr	r1, [r7, #20]
700059b6:	69ba      	ldr	r2, [r7, #24]
700059b8:	e841 2300 	strex	r3, r2, [r1]
700059bc:	613b      	str	r3, [r7, #16]
   return(result);
700059be:	693b      	ldr	r3, [r7, #16]
700059c0:	2b00      	cmp	r3, #0
700059c2:	d1e6      	bne.n	70005992 <UART_EndRxTransfer+0x76>
  }

  /* At end of Rx process, restore huart->RxState to Ready */
  huart->RxState = HAL_UART_STATE_READY;
700059c4:	687b      	ldr	r3, [r7, #4]
700059c6:	2220      	movs	r2, #32
700059c8:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  huart->ReceptionType = HAL_UART_RECEPTION_STANDARD;
700059cc:	687b      	ldr	r3, [r7, #4]
700059ce:	2200      	movs	r2, #0
700059d0:	66da      	str	r2, [r3, #108]	@ 0x6c

  /* Reset RxIsr function pointer */
  huart->RxISR = NULL;
700059d2:	687b      	ldr	r3, [r7, #4]
700059d4:	2200      	movs	r2, #0
700059d6:	675a      	str	r2, [r3, #116]	@ 0x74
}
700059d8:	bf00      	nop
700059da:	3754      	adds	r7, #84	@ 0x54
700059dc:	46bd      	mov	sp, r7
700059de:	f85d 7b04 	ldr.w	r7, [sp], #4
700059e2:	4770      	bx	lr
700059e4:	effffffe 	.word	0xeffffffe

700059e8 <HAL_UARTEx_DisableFifoMode>:
  * @brief  Disable the FIFO mode.
  * @param huart      UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_DisableFifoMode(UART_HandleTypeDef *huart)
{
700059e8:	b480      	push	{r7}
700059ea:	b085      	sub	sp, #20
700059ec:	af00      	add	r7, sp, #0
700059ee:	6078      	str	r0, [r7, #4]

  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));

  /* Process Locked */
  __HAL_LOCK(huart);
700059f0:	687b      	ldr	r3, [r7, #4]
700059f2:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
700059f6:	2b01      	cmp	r3, #1
700059f8:	d101      	bne.n	700059fe <HAL_UARTEx_DisableFifoMode+0x16>
700059fa:	2302      	movs	r3, #2
700059fc:	e027      	b.n	70005a4e <HAL_UARTEx_DisableFifoMode+0x66>
700059fe:	687b      	ldr	r3, [r7, #4]
70005a00:	2201      	movs	r2, #1
70005a02:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
70005a06:	687b      	ldr	r3, [r7, #4]
70005a08:	2224      	movs	r2, #36	@ 0x24
70005a0a:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
70005a0e:	687b      	ldr	r3, [r7, #4]
70005a10:	681b      	ldr	r3, [r3, #0]
70005a12:	681b      	ldr	r3, [r3, #0]
70005a14:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
70005a16:	687b      	ldr	r3, [r7, #4]
70005a18:	681b      	ldr	r3, [r3, #0]
70005a1a:	681a      	ldr	r2, [r3, #0]
70005a1c:	687b      	ldr	r3, [r7, #4]
70005a1e:	681b      	ldr	r3, [r3, #0]
70005a20:	f022 0201 	bic.w	r2, r2, #1
70005a24:	601a      	str	r2, [r3, #0]

  /* Disable FIFO mode */
  CLEAR_BIT(tmpcr1, USART_CR1_FIFOEN);
70005a26:	68fb      	ldr	r3, [r7, #12]
70005a28:	f023 5300 	bic.w	r3, r3, #536870912	@ 0x20000000
70005a2c:	60fb      	str	r3, [r7, #12]
  huart->FifoMode = UART_FIFOMODE_DISABLE;
70005a2e:	687b      	ldr	r3, [r7, #4]
70005a30:	2200      	movs	r2, #0
70005a32:	665a      	str	r2, [r3, #100]	@ 0x64

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
70005a34:	687b      	ldr	r3, [r7, #4]
70005a36:	681b      	ldr	r3, [r3, #0]
70005a38:	68fa      	ldr	r2, [r7, #12]
70005a3a:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
70005a3c:	687b      	ldr	r3, [r7, #4]
70005a3e:	2220      	movs	r2, #32
70005a40:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
70005a44:	687b      	ldr	r3, [r7, #4]
70005a46:	2200      	movs	r2, #0
70005a48:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
70005a4c:	2300      	movs	r3, #0
}
70005a4e:	4618      	mov	r0, r3
70005a50:	3714      	adds	r7, #20
70005a52:	46bd      	mov	sp, r7
70005a54:	f85d 7b04 	ldr.w	r7, [sp], #4
70005a58:	4770      	bx	lr

70005a5a <HAL_UARTEx_SetTxFifoThreshold>:
  *            @arg @ref UART_TXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_TXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetTxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
70005a5a:	b580      	push	{r7, lr}
70005a5c:	b084      	sub	sp, #16
70005a5e:	af00      	add	r7, sp, #0
70005a60:	6078      	str	r0, [r7, #4]
70005a62:	6039      	str	r1, [r7, #0]
  /* Check parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_TXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
70005a64:	687b      	ldr	r3, [r7, #4]
70005a66:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
70005a6a:	2b01      	cmp	r3, #1
70005a6c:	d101      	bne.n	70005a72 <HAL_UARTEx_SetTxFifoThreshold+0x18>
70005a6e:	2302      	movs	r3, #2
70005a70:	e02d      	b.n	70005ace <HAL_UARTEx_SetTxFifoThreshold+0x74>
70005a72:	687b      	ldr	r3, [r7, #4]
70005a74:	2201      	movs	r2, #1
70005a76:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
70005a7a:	687b      	ldr	r3, [r7, #4]
70005a7c:	2224      	movs	r2, #36	@ 0x24
70005a7e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
70005a82:	687b      	ldr	r3, [r7, #4]
70005a84:	681b      	ldr	r3, [r3, #0]
70005a86:	681b      	ldr	r3, [r3, #0]
70005a88:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
70005a8a:	687b      	ldr	r3, [r7, #4]
70005a8c:	681b      	ldr	r3, [r3, #0]
70005a8e:	681a      	ldr	r2, [r3, #0]
70005a90:	687b      	ldr	r3, [r7, #4]
70005a92:	681b      	ldr	r3, [r3, #0]
70005a94:	f022 0201 	bic.w	r2, r2, #1
70005a98:	601a      	str	r2, [r3, #0]

  /* Update TX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_TXFTCFG, Threshold);
70005a9a:	687b      	ldr	r3, [r7, #4]
70005a9c:	681b      	ldr	r3, [r3, #0]
70005a9e:	689b      	ldr	r3, [r3, #8]
70005aa0:	f023 4160 	bic.w	r1, r3, #3758096384	@ 0xe0000000
70005aa4:	687b      	ldr	r3, [r7, #4]
70005aa6:	681b      	ldr	r3, [r3, #0]
70005aa8:	683a      	ldr	r2, [r7, #0]
70005aaa:	430a      	orrs	r2, r1
70005aac:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
70005aae:	6878      	ldr	r0, [r7, #4]
70005ab0:	f000 f850 	bl	70005b54 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
70005ab4:	687b      	ldr	r3, [r7, #4]
70005ab6:	681b      	ldr	r3, [r3, #0]
70005ab8:	68fa      	ldr	r2, [r7, #12]
70005aba:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
70005abc:	687b      	ldr	r3, [r7, #4]
70005abe:	2220      	movs	r2, #32
70005ac0:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
70005ac4:	687b      	ldr	r3, [r7, #4]
70005ac6:	2200      	movs	r2, #0
70005ac8:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
70005acc:	2300      	movs	r3, #0
}
70005ace:	4618      	mov	r0, r3
70005ad0:	3710      	adds	r7, #16
70005ad2:	46bd      	mov	sp, r7
70005ad4:	bd80      	pop	{r7, pc}

70005ad6 <HAL_UARTEx_SetRxFifoThreshold>:
  *            @arg @ref UART_RXFIFO_THRESHOLD_7_8
  *            @arg @ref UART_RXFIFO_THRESHOLD_8_8
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UARTEx_SetRxFifoThreshold(UART_HandleTypeDef *huart, uint32_t Threshold)
{
70005ad6:	b580      	push	{r7, lr}
70005ad8:	b084      	sub	sp, #16
70005ada:	af00      	add	r7, sp, #0
70005adc:	6078      	str	r0, [r7, #4]
70005ade:	6039      	str	r1, [r7, #0]
  /* Check the parameters */
  assert_param(IS_UART_FIFO_INSTANCE(huart->Instance));
  assert_param(IS_UART_RXFIFO_THRESHOLD(Threshold));

  /* Process Locked */
  __HAL_LOCK(huart);
70005ae0:	687b      	ldr	r3, [r7, #4]
70005ae2:	f893 3084 	ldrb.w	r3, [r3, #132]	@ 0x84
70005ae6:	2b01      	cmp	r3, #1
70005ae8:	d101      	bne.n	70005aee <HAL_UARTEx_SetRxFifoThreshold+0x18>
70005aea:	2302      	movs	r3, #2
70005aec:	e02d      	b.n	70005b4a <HAL_UARTEx_SetRxFifoThreshold+0x74>
70005aee:	687b      	ldr	r3, [r7, #4]
70005af0:	2201      	movs	r2, #1
70005af2:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  huart->gState = HAL_UART_STATE_BUSY;
70005af6:	687b      	ldr	r3, [r7, #4]
70005af8:	2224      	movs	r2, #36	@ 0x24
70005afa:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Save actual UART configuration */
  tmpcr1 = READ_REG(huart->Instance->CR1);
70005afe:	687b      	ldr	r3, [r7, #4]
70005b00:	681b      	ldr	r3, [r3, #0]
70005b02:	681b      	ldr	r3, [r3, #0]
70005b04:	60fb      	str	r3, [r7, #12]

  /* Disable UART */
  __HAL_UART_DISABLE(huart);
70005b06:	687b      	ldr	r3, [r7, #4]
70005b08:	681b      	ldr	r3, [r3, #0]
70005b0a:	681a      	ldr	r2, [r3, #0]
70005b0c:	687b      	ldr	r3, [r7, #4]
70005b0e:	681b      	ldr	r3, [r3, #0]
70005b10:	f022 0201 	bic.w	r2, r2, #1
70005b14:	601a      	str	r2, [r3, #0]

  /* Update RX threshold configuration */
  MODIFY_REG(huart->Instance->CR3, USART_CR3_RXFTCFG, Threshold);
70005b16:	687b      	ldr	r3, [r7, #4]
70005b18:	681b      	ldr	r3, [r3, #0]
70005b1a:	689b      	ldr	r3, [r3, #8]
70005b1c:	f023 6160 	bic.w	r1, r3, #234881024	@ 0xe000000
70005b20:	687b      	ldr	r3, [r7, #4]
70005b22:	681b      	ldr	r3, [r3, #0]
70005b24:	683a      	ldr	r2, [r7, #0]
70005b26:	430a      	orrs	r2, r1
70005b28:	609a      	str	r2, [r3, #8]

  /* Determine the number of data to process during RX/TX ISR execution */
  UARTEx_SetNbDataToProcess(huart);
70005b2a:	6878      	ldr	r0, [r7, #4]
70005b2c:	f000 f812 	bl	70005b54 <UARTEx_SetNbDataToProcess>

  /* Restore UART configuration */
  WRITE_REG(huart->Instance->CR1, tmpcr1);
70005b30:	687b      	ldr	r3, [r7, #4]
70005b32:	681b      	ldr	r3, [r3, #0]
70005b34:	68fa      	ldr	r2, [r7, #12]
70005b36:	601a      	str	r2, [r3, #0]

  huart->gState = HAL_UART_STATE_READY;
70005b38:	687b      	ldr	r3, [r7, #4]
70005b3a:	2220      	movs	r2, #32
70005b3c:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88

  /* Process Unlocked */
  __HAL_UNLOCK(huart);
70005b40:	687b      	ldr	r3, [r7, #4]
70005b42:	2200      	movs	r2, #0
70005b44:	f883 2084 	strb.w	r2, [r3, #132]	@ 0x84

  return HAL_OK;
70005b48:	2300      	movs	r3, #0
}
70005b4a:	4618      	mov	r0, r3
70005b4c:	3710      	adds	r7, #16
70005b4e:	46bd      	mov	sp, r7
70005b50:	bd80      	pop	{r7, pc}
	...

70005b54 <UARTEx_SetNbDataToProcess>:
  *       the UART configuration registers.
  * @param huart UART handle.
  * @retval None
  */
static void UARTEx_SetNbDataToProcess(UART_HandleTypeDef *huart)
{
70005b54:	b480      	push	{r7}
70005b56:	b085      	sub	sp, #20
70005b58:	af00      	add	r7, sp, #0
70005b5a:	6078      	str	r0, [r7, #4]
  uint8_t rx_fifo_threshold;
  uint8_t tx_fifo_threshold;
  static const uint8_t numerator[] = {1U, 1U, 1U, 3U, 7U, 1U, 0U, 0U};
  static const uint8_t denominator[] = {8U, 4U, 2U, 4U, 8U, 1U, 1U, 1U};

  if (huart->FifoMode == UART_FIFOMODE_DISABLE)
70005b5c:	687b      	ldr	r3, [r7, #4]
70005b5e:	6e5b      	ldr	r3, [r3, #100]	@ 0x64
70005b60:	2b00      	cmp	r3, #0
70005b62:	d108      	bne.n	70005b76 <UARTEx_SetNbDataToProcess+0x22>
  {
    huart->NbTxDataToProcess = 1U;
70005b64:	687b      	ldr	r3, [r7, #4]
70005b66:	2201      	movs	r2, #1
70005b68:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = 1U;
70005b6c:	687b      	ldr	r3, [r7, #4]
70005b6e:	2201      	movs	r2, #1
70005b70:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
                               (uint16_t)denominator[tx_fifo_threshold];
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
                               (uint16_t)denominator[rx_fifo_threshold];
  }
}
70005b74:	e031      	b.n	70005bda <UARTEx_SetNbDataToProcess+0x86>
    rx_fifo_depth = RX_FIFO_DEPTH;
70005b76:	2310      	movs	r3, #16
70005b78:	73fb      	strb	r3, [r7, #15]
    tx_fifo_depth = TX_FIFO_DEPTH;
70005b7a:	2310      	movs	r3, #16
70005b7c:	73bb      	strb	r3, [r7, #14]
    rx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_RXFTCFG) >> USART_CR3_RXFTCFG_Pos);
70005b7e:	687b      	ldr	r3, [r7, #4]
70005b80:	681b      	ldr	r3, [r3, #0]
70005b82:	689b      	ldr	r3, [r3, #8]
70005b84:	0e5b      	lsrs	r3, r3, #25
70005b86:	b2db      	uxtb	r3, r3
70005b88:	f003 0307 	and.w	r3, r3, #7
70005b8c:	737b      	strb	r3, [r7, #13]
    tx_fifo_threshold = (uint8_t)(READ_BIT(huart->Instance->CR3, USART_CR3_TXFTCFG) >> USART_CR3_TXFTCFG_Pos);
70005b8e:	687b      	ldr	r3, [r7, #4]
70005b90:	681b      	ldr	r3, [r3, #0]
70005b92:	689b      	ldr	r3, [r3, #8]
70005b94:	0f5b      	lsrs	r3, r3, #29
70005b96:	b2db      	uxtb	r3, r3
70005b98:	f003 0307 	and.w	r3, r3, #7
70005b9c:	733b      	strb	r3, [r7, #12]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
70005b9e:	7bbb      	ldrb	r3, [r7, #14]
70005ba0:	7b3a      	ldrb	r2, [r7, #12]
70005ba2:	4911      	ldr	r1, [pc, #68]	@ (70005be8 <UARTEx_SetNbDataToProcess+0x94>)
70005ba4:	5c8a      	ldrb	r2, [r1, r2]
70005ba6:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[tx_fifo_threshold];
70005baa:	7b3a      	ldrb	r2, [r7, #12]
70005bac:	490f      	ldr	r1, [pc, #60]	@ (70005bec <UARTEx_SetNbDataToProcess+0x98>)
70005bae:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbTxDataToProcess = ((uint16_t)tx_fifo_depth * numerator[tx_fifo_threshold]) /
70005bb0:	fb93 f3f2 	sdiv	r3, r3, r2
70005bb4:	b29a      	uxth	r2, r3
70005bb6:	687b      	ldr	r3, [r7, #4]
70005bb8:	f8a3 206a 	strh.w	r2, [r3, #106]	@ 0x6a
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
70005bbc:	7bfb      	ldrb	r3, [r7, #15]
70005bbe:	7b7a      	ldrb	r2, [r7, #13]
70005bc0:	4909      	ldr	r1, [pc, #36]	@ (70005be8 <UARTEx_SetNbDataToProcess+0x94>)
70005bc2:	5c8a      	ldrb	r2, [r1, r2]
70005bc4:	fb02 f303 	mul.w	r3, r2, r3
                               (uint16_t)denominator[rx_fifo_threshold];
70005bc8:	7b7a      	ldrb	r2, [r7, #13]
70005bca:	4908      	ldr	r1, [pc, #32]	@ (70005bec <UARTEx_SetNbDataToProcess+0x98>)
70005bcc:	5c8a      	ldrb	r2, [r1, r2]
    huart->NbRxDataToProcess = ((uint16_t)rx_fifo_depth * numerator[rx_fifo_threshold]) /
70005bce:	fb93 f3f2 	sdiv	r3, r3, r2
70005bd2:	b29a      	uxth	r2, r3
70005bd4:	687b      	ldr	r3, [r7, #4]
70005bd6:	f8a3 2068 	strh.w	r2, [r3, #104]	@ 0x68
}
70005bda:	bf00      	nop
70005bdc:	3714      	adds	r7, #20
70005bde:	46bd      	mov	sp, r7
70005be0:	f85d 7b04 	ldr.w	r7, [sp], #4
70005be4:	4770      	bx	lr
70005be6:	bf00      	nop
70005be8:	70009e6c 	.word	0x70009e6c
70005bec:	70009e74 	.word	0x70009e74

70005bf0 <HAL_XSPI_Init>:
  *         in the XSPI_InitTypeDef and initialize the associated handle.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Init(XSPI_HandleTypeDef *hxspi)
{
70005bf0:	b580      	push	{r7, lr}
70005bf2:	b086      	sub	sp, #24
70005bf4:	af02      	add	r7, sp, #8
70005bf6:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
70005bf8:	2300      	movs	r3, #0
70005bfa:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
70005bfc:	f7fb fda2 	bl	70001744 <HAL_GetTick>
70005c00:	60b8      	str	r0, [r7, #8]

  /* Check the XSPI handle allocation */
  if (hxspi == NULL)
70005c02:	687b      	ldr	r3, [r7, #4]
70005c04:	2b00      	cmp	r3, #0
70005c06:	d102      	bne.n	70005c0e <HAL_XSPI_Init+0x1e>
  {
    status = HAL_ERROR;
70005c08:	2301      	movs	r3, #1
70005c0a:	73fb      	strb	r3, [r7, #15]
70005c0c:	e0c8      	b.n	70005da0 <HAL_XSPI_Init+0x1b0>
    assert_param(IS_XSPI_CS_BOUND(hxspi->Init.ChipSelectBoundary));
    assert_param(IS_XSPI_FIFO_THRESHOLD_BYTE(hxspi->Init.FifoThresholdByte));
    assert_param(IS_XSPI_MAXTRAN(hxspi->Init.MaxTran));
    assert_param(IS_XSPI_CSSEL(hxspi->Init.MemorySelect));
    /* Initialize error code */
    hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
70005c0e:	687b      	ldr	r3, [r7, #4]
70005c10:	2200      	movs	r2, #0
70005c12:	659a      	str	r2, [r3, #88]	@ 0x58

    /* Check if the state is the reset state */
    if (hxspi->State == HAL_XSPI_STATE_RESET)
70005c14:	687b      	ldr	r3, [r7, #4]
70005c16:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70005c18:	2b00      	cmp	r3, #0
70005c1a:	f040 80c1 	bne.w	70005da0 <HAL_XSPI_Init+0x1b0>

      /* Init the low level hardware */
      hxspi->MspInitCallback(hxspi);
#else
      /* Initialization of the low level hardware */
      HAL_XSPI_MspInit(hxspi);
70005c1e:	6878      	ldr	r0, [r7, #4]
70005c20:	f7fa ff9c 	bl	70000b5c <HAL_XSPI_MspInit>
#endif /* defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U) */

      /* Configure the default timeout for the XSPI memory access */
      (void)HAL_XSPI_SetTimeout(hxspi, HAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70005c24:	f241 3188 	movw	r1, #5000	@ 0x1388
70005c28:	6878      	ldr	r0, [r7, #4]
70005c2a:	f000 fb7e 	bl	7000632a <HAL_XSPI_SetTimeout>

      /* Configure memory type, device size, chip select high time, free running clock, clock mode */
      MODIFY_REG(hxspi->Instance->DCR1,
70005c2e:	687b      	ldr	r3, [r7, #4]
70005c30:	681b      	ldr	r3, [r3, #0]
70005c32:	689a      	ldr	r2, [r3, #8]
70005c34:	4b5d      	ldr	r3, [pc, #372]	@ (70005dac <HAL_XSPI_Init+0x1bc>)
70005c36:	4013      	ands	r3, r2
70005c38:	687a      	ldr	r2, [r7, #4]
70005c3a:	68d1      	ldr	r1, [r2, #12]
70005c3c:	687a      	ldr	r2, [r7, #4]
70005c3e:	6912      	ldr	r2, [r2, #16]
70005c40:	0412      	lsls	r2, r2, #16
70005c42:	4311      	orrs	r1, r2
70005c44:	687a      	ldr	r2, [r7, #4]
70005c46:	6952      	ldr	r2, [r2, #20]
70005c48:	3a01      	subs	r2, #1
70005c4a:	0212      	lsls	r2, r2, #8
70005c4c:	4311      	orrs	r1, r2
70005c4e:	687a      	ldr	r2, [r7, #4]
70005c50:	69d2      	ldr	r2, [r2, #28]
70005c52:	4311      	orrs	r1, r2
70005c54:	687a      	ldr	r2, [r7, #4]
70005c56:	6812      	ldr	r2, [r2, #0]
70005c58:	430b      	orrs	r3, r1
70005c5a:	6093      	str	r3, [r2, #8]
                 (XSPI_DCR1_MTYP | XSPI_DCR1_DEVSIZE | XSPI_DCR1_CSHT | XSPI_DCR1_FRCK | XSPI_DCR1_CKMODE),
                 (hxspi->Init.MemoryType | ((hxspi->Init.MemorySize) << XSPI_DCR1_DEVSIZE_Pos) |
                  ((hxspi->Init.ChipSelectHighTimeCycle - 1U) << XSPI_DCR1_CSHT_Pos) | hxspi->Init.ClockMode));

      /* Configure wrap size */
      MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_WRAPSIZE, hxspi->Init.WrapSize);
70005c5c:	687b      	ldr	r3, [r7, #4]
70005c5e:	681b      	ldr	r3, [r3, #0]
70005c60:	68db      	ldr	r3, [r3, #12]
70005c62:	f423 21e0 	bic.w	r1, r3, #458752	@ 0x70000
70005c66:	687b      	ldr	r3, [r7, #4]
70005c68:	6a1a      	ldr	r2, [r3, #32]
70005c6a:	687b      	ldr	r3, [r7, #4]
70005c6c:	681b      	ldr	r3, [r3, #0]
70005c6e:	430a      	orrs	r2, r1
70005c70:	60da      	str	r2, [r3, #12]

      /* Configure chip select boundary */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_CSBOUND, (hxspi->Init.ChipSelectBoundary << XSPI_DCR3_CSBOUND_Pos));
70005c72:	687b      	ldr	r3, [r7, #4]
70005c74:	681b      	ldr	r3, [r3, #0]
70005c76:	691b      	ldr	r3, [r3, #16]
70005c78:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
70005c7c:	687b      	ldr	r3, [r7, #4]
70005c7e:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
70005c80:	041a      	lsls	r2, r3, #16
70005c82:	687b      	ldr	r3, [r7, #4]
70005c84:	681b      	ldr	r3, [r3, #0]
70005c86:	430a      	orrs	r2, r1
70005c88:	611a      	str	r2, [r3, #16]

      /* Configure maximum transfer */
      MODIFY_REG(hxspi->Instance->DCR3, XSPI_DCR3_MAXTRAN, \
70005c8a:	687b      	ldr	r3, [r7, #4]
70005c8c:	681b      	ldr	r3, [r3, #0]
70005c8e:	691b      	ldr	r3, [r3, #16]
70005c90:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
70005c94:	687b      	ldr	r3, [r7, #4]
70005c96:	6b5a      	ldr	r2, [r3, #52]	@ 0x34
70005c98:	687b      	ldr	r3, [r7, #4]
70005c9a:	681b      	ldr	r3, [r3, #0]
70005c9c:	430a      	orrs	r2, r1
70005c9e:	611a      	str	r2, [r3, #16]
                 (hxspi->Init.MaxTran << XSPI_DCR3_MAXTRAN_Pos));

      /* Configure refresh */
      hxspi->Instance->DCR4 = hxspi->Init.Refresh;
70005ca0:	687b      	ldr	r3, [r7, #4]
70005ca2:	681b      	ldr	r3, [r3, #0]
70005ca4:	687a      	ldr	r2, [r7, #4]
70005ca6:	6b92      	ldr	r2, [r2, #56]	@ 0x38
70005ca8:	615a      	str	r2, [r3, #20]

      /* Configure FIFO threshold */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FTHRES, ((hxspi->Init.FifoThresholdByte - 1U) << XSPI_CR_FTHRES_Pos));
70005caa:	687b      	ldr	r3, [r7, #4]
70005cac:	681b      	ldr	r3, [r3, #0]
70005cae:	681b      	ldr	r3, [r3, #0]
70005cb0:	f423 51f8 	bic.w	r1, r3, #7936	@ 0x1f00
70005cb4:	687b      	ldr	r3, [r7, #4]
70005cb6:	685b      	ldr	r3, [r3, #4]
70005cb8:	3b01      	subs	r3, #1
70005cba:	021a      	lsls	r2, r3, #8
70005cbc:	687b      	ldr	r3, [r7, #4]
70005cbe:	681b      	ldr	r3, [r3, #0]
70005cc0:	430a      	orrs	r2, r1
70005cc2:	601a      	str	r2, [r3, #0]

      /* Wait till busy flag is reset */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
70005cc4:	687b      	ldr	r3, [r7, #4]
70005cc6:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
70005cc8:	9300      	str	r3, [sp, #0]
70005cca:	68bb      	ldr	r3, [r7, #8]
70005ccc:	2200      	movs	r2, #0
70005cce:	2120      	movs	r1, #32
70005cd0:	6878      	ldr	r0, [r7, #4]
70005cd2:	f000 fc29 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
70005cd6:	4603      	mov	r3, r0
70005cd8:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
70005cda:	7bfb      	ldrb	r3, [r7, #15]
70005cdc:	2b00      	cmp	r3, #0
70005cde:	d15f      	bne.n	70005da0 <HAL_XSPI_Init+0x1b0>
      {
        /* Configure clock prescaler */
        MODIFY_REG(hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER,
70005ce0:	687b      	ldr	r3, [r7, #4]
70005ce2:	681b      	ldr	r3, [r3, #0]
70005ce4:	68db      	ldr	r3, [r3, #12]
70005ce6:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
70005cea:	687b      	ldr	r3, [r7, #4]
70005cec:	6a5a      	ldr	r2, [r3, #36]	@ 0x24
70005cee:	687b      	ldr	r3, [r7, #4]
70005cf0:	681b      	ldr	r3, [r3, #0]
70005cf2:	430a      	orrs	r2, r1
70005cf4:	60da      	str	r2, [r3, #12]
                   ((hxspi->Init.ClockPrescaler) << XSPI_DCR2_PRESCALER_Pos));

        if (IS_XSPI_ALL_INSTANCE(hxspi->Instance))
70005cf6:	687b      	ldr	r3, [r7, #4]
70005cf8:	681b      	ldr	r3, [r3, #0]
70005cfa:	4a2d      	ldr	r2, [pc, #180]	@ (70005db0 <HAL_XSPI_Init+0x1c0>)
70005cfc:	4293      	cmp	r3, r2
70005cfe:	d004      	beq.n	70005d0a <HAL_XSPI_Init+0x11a>
70005d00:	687b      	ldr	r3, [r7, #4]
70005d02:	681b      	ldr	r3, [r3, #0]
70005d04:	4a2b      	ldr	r2, [pc, #172]	@ (70005db4 <HAL_XSPI_Init+0x1c4>)
70005d06:	4293      	cmp	r3, r2
70005d08:	d10f      	bne.n	70005d2a <HAL_XSPI_Init+0x13a>
        {
          /* The configuration of clock prescaler trigger automatically a calibration process.
          So it is necessary to wait the calibration is complete */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
70005d0a:	687b      	ldr	r3, [r7, #4]
70005d0c:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
70005d0e:	9300      	str	r3, [sp, #0]
70005d10:	68bb      	ldr	r3, [r7, #8]
70005d12:	2200      	movs	r2, #0
70005d14:	2120      	movs	r1, #32
70005d16:	6878      	ldr	r0, [r7, #4]
70005d18:	f000 fc06 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
70005d1c:	4603      	mov	r3, r0
70005d1e:	73fb      	strb	r3, [r7, #15]
          if (status != HAL_OK)
70005d20:	7bfb      	ldrb	r3, [r7, #15]
70005d22:	2b00      	cmp	r3, #0
70005d24:	d001      	beq.n	70005d2a <HAL_XSPI_Init+0x13a>
          {
            return status;
70005d26:	7bfb      	ldrb	r3, [r7, #15]
70005d28:	e03b      	b.n	70005da2 <HAL_XSPI_Init+0x1b2>
          }
        }
        /* Configure Dual Memory mode and CS Selection */
        MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_DMM | XSPI_CR_CSSEL),
70005d2a:	687b      	ldr	r3, [r7, #4]
70005d2c:	681b      	ldr	r3, [r3, #0]
70005d2e:	681a      	ldr	r2, [r3, #0]
70005d30:	4b21      	ldr	r3, [pc, #132]	@ (70005db8 <HAL_XSPI_Init+0x1c8>)
70005d32:	4013      	ands	r3, r2
70005d34:	687a      	ldr	r2, [r7, #4]
70005d36:	6891      	ldr	r1, [r2, #8]
70005d38:	687a      	ldr	r2, [r7, #4]
70005d3a:	6bd2      	ldr	r2, [r2, #60]	@ 0x3c
70005d3c:	4311      	orrs	r1, r2
70005d3e:	687a      	ldr	r2, [r7, #4]
70005d40:	6812      	ldr	r2, [r2, #0]
70005d42:	430b      	orrs	r3, r1
70005d44:	6013      	str	r3, [r2, #0]
                   (hxspi->Init.MemoryMode | hxspi->Init.MemorySelect));

        /* Configure sample shifting */
        MODIFY_REG(hxspi->Instance->TCR, (XSPI_TCR_SSHIFT), hxspi->Init.SampleShifting);
70005d46:	687b      	ldr	r3, [r7, #4]
70005d48:	681b      	ldr	r3, [r3, #0]
70005d4a:	f8d3 3108 	ldr.w	r3, [r3, #264]	@ 0x108
70005d4e:	f023 4180 	bic.w	r1, r3, #1073741824	@ 0x40000000
70005d52:	687b      	ldr	r3, [r7, #4]
70005d54:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
70005d56:	687b      	ldr	r3, [r7, #4]
70005d58:	681b      	ldr	r3, [r3, #0]
70005d5a:	430a      	orrs	r2, r1
70005d5c:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108

        /* Enable XSPI */
        HAL_XSPI_ENABLE(hxspi);
70005d60:	687b      	ldr	r3, [r7, #4]
70005d62:	681b      	ldr	r3, [r3, #0]
70005d64:	681a      	ldr	r2, [r3, #0]
70005d66:	687b      	ldr	r3, [r7, #4]
70005d68:	681b      	ldr	r3, [r3, #0]
70005d6a:	f042 0201 	orr.w	r2, r2, #1
70005d6e:	601a      	str	r2, [r3, #0]

        /* Enable free running clock if needed : must be done after XSPI enable */
        if (hxspi->Init.FreeRunningClock == HAL_XSPI_FREERUNCLK_ENABLE)
70005d70:	687b      	ldr	r3, [r7, #4]
70005d72:	699b      	ldr	r3, [r3, #24]
70005d74:	2b02      	cmp	r3, #2
70005d76:	d107      	bne.n	70005d88 <HAL_XSPI_Init+0x198>
        {
          SET_BIT(hxspi->Instance->DCR1, XSPI_DCR1_FRCK);
70005d78:	687b      	ldr	r3, [r7, #4]
70005d7a:	681b      	ldr	r3, [r3, #0]
70005d7c:	689a      	ldr	r2, [r3, #8]
70005d7e:	687b      	ldr	r3, [r7, #4]
70005d80:	681b      	ldr	r3, [r3, #0]
70005d82:	f042 0202 	orr.w	r2, r2, #2
70005d86:	609a      	str	r2, [r3, #8]
        }

        /* Initialize the XSPI state */
        if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
70005d88:	687b      	ldr	r3, [r7, #4]
70005d8a:	68db      	ldr	r3, [r3, #12]
70005d8c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
70005d90:	d103      	bne.n	70005d9a <HAL_XSPI_Init+0x1aa>
        {
          hxspi->State = HAL_XSPI_STATE_HYPERBUS_INIT;
70005d92:	687b      	ldr	r3, [r7, #4]
70005d94:	2201      	movs	r2, #1
70005d96:	655a      	str	r2, [r3, #84]	@ 0x54
70005d98:	e002      	b.n	70005da0 <HAL_XSPI_Init+0x1b0>
        }
        else
        {
          hxspi->State = HAL_XSPI_STATE_READY;
70005d9a:	687b      	ldr	r3, [r7, #4]
70005d9c:	2202      	movs	r2, #2
70005d9e:	655a      	str	r2, [r3, #84]	@ 0x54
        }
      }
    }
  }
  return status;
70005da0:	7bfb      	ldrb	r3, [r7, #15]
}
70005da2:	4618      	mov	r0, r3
70005da4:	3710      	adds	r7, #16
70005da6:	46bd      	mov	sp, r7
70005da8:	bd80      	pop	{r7, pc}
70005daa:	bf00      	nop
70005dac:	f8e0c0fc 	.word	0xf8e0c0fc
70005db0:	52005000 	.word	0x52005000
70005db4:	5200a000 	.word	0x5200a000
70005db8:	feffffbf 	.word	0xfeffffbf

70005dbc <HAL_XSPI_Command>:
  * @param  pCmd     : structure that contains the command configuration information
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Command(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd, uint32_t Timeout)
{
70005dbc:	b580      	push	{r7, lr}
70005dbe:	b08a      	sub	sp, #40	@ 0x28
70005dc0:	af02      	add	r7, sp, #8
70005dc2:	60f8      	str	r0, [r7, #12]
70005dc4:	60b9      	str	r1, [r7, #8]
70005dc6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t state;
  uint32_t tickstart = HAL_GetTick();
70005dc8:	f7fb fcbc 	bl	70001744 <HAL_GetTick>
70005dcc:	61b8      	str	r0, [r7, #24]
    assert_param(IS_XSPI_ALT_BYTES_DTR_MODE(pCmd->AlternateBytesDTRMode));
  }

  assert_param(IS_XSPI_DATA_MODE(hxspi->Init.MemoryType, pCmd->DataMode));

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
70005dce:	68bb      	ldr	r3, [r7, #8]
70005dd0:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70005dd2:	2b00      	cmp	r3, #0
  }

  assert_param(IS_XSPI_DQS_MODE(pCmd->DQSMode));

  /* Check the state of the driver */
  state = hxspi->State;
70005dd4:	68fb      	ldr	r3, [r7, #12]
70005dd6:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70005dd8:	617b      	str	r3, [r7, #20]
  if (((state == HAL_XSPI_STATE_READY)         && (hxspi->Init.MemoryType != HAL_XSPI_MEMTYPE_HYPERBUS)) ||
70005dda:	697b      	ldr	r3, [r7, #20]
70005ddc:	2b02      	cmp	r3, #2
70005dde:	d104      	bne.n	70005dea <HAL_XSPI_Command+0x2e>
70005de0:	68fb      	ldr	r3, [r7, #12]
70005de2:	68db      	ldr	r3, [r3, #12]
70005de4:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
70005de8:	d115      	bne.n	70005e16 <HAL_XSPI_Command+0x5a>
70005dea:	697b      	ldr	r3, [r7, #20]
70005dec:	2b14      	cmp	r3, #20
70005dee:	d107      	bne.n	70005e00 <HAL_XSPI_Command+0x44>
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
70005df0:	68bb      	ldr	r3, [r7, #8]
70005df2:	681b      	ldr	r3, [r3, #0]
70005df4:	2b02      	cmp	r3, #2
70005df6:	d00e      	beq.n	70005e16 <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
70005df8:	68bb      	ldr	r3, [r7, #8]
70005dfa:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_READ_CMD_CFG)  && ((pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG) ||
70005dfc:	2b03      	cmp	r3, #3
70005dfe:	d00a      	beq.n	70005e16 <HAL_XSPI_Command+0x5a>
                                                   (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))) ||
70005e00:	697b      	ldr	r3, [r7, #20]
70005e02:	2b24      	cmp	r3, #36	@ 0x24
70005e04:	d15e      	bne.n	70005ec4 <HAL_XSPI_Command+0x108>
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
70005e06:	68bb      	ldr	r3, [r7, #8]
70005e08:	681b      	ldr	r3, [r3, #0]
      ((state == HAL_XSPI_STATE_WRITE_CMD_CFG) &&
70005e0a:	2b01      	cmp	r3, #1
70005e0c:	d003      	beq.n	70005e16 <HAL_XSPI_Command+0x5a>
        (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG))))
70005e0e:	68bb      	ldr	r3, [r7, #8]
70005e10:	681b      	ldr	r3, [r3, #0]
       ((pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)  ||
70005e12:	2b03      	cmp	r3, #3
70005e14:	d156      	bne.n	70005ec4 <HAL_XSPI_Command+0x108>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
70005e16:	687b      	ldr	r3, [r7, #4]
70005e18:	9300      	str	r3, [sp, #0]
70005e1a:	69bb      	ldr	r3, [r7, #24]
70005e1c:	2200      	movs	r2, #0
70005e1e:	2120      	movs	r1, #32
70005e20:	68f8      	ldr	r0, [r7, #12]
70005e22:	f000 fb81 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
70005e26:	4603      	mov	r3, r0
70005e28:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
70005e2a:	7ffb      	ldrb	r3, [r7, #31]
70005e2c:	2b00      	cmp	r3, #0
70005e2e:	d146      	bne.n	70005ebe <HAL_XSPI_Command+0x102>
    {
      /* Initialize error code */
      hxspi->ErrorCode = HAL_XSPI_ERROR_NONE;
70005e30:	68fb      	ldr	r3, [r7, #12]
70005e32:	2200      	movs	r2, #0
70005e34:	659a      	str	r2, [r3, #88]	@ 0x58

      /* Configure the registers */
      status = XSPI_ConfigCmd(hxspi, pCmd);
70005e36:	68b9      	ldr	r1, [r7, #8]
70005e38:	68f8      	ldr	r0, [r7, #12]
70005e3a:	f000 fbab 	bl	70006594 <XSPI_ConfigCmd>
70005e3e:	4603      	mov	r3, r0
70005e40:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
70005e42:	7ffb      	ldrb	r3, [r7, #31]
70005e44:	2b00      	cmp	r3, #0
70005e46:	d143      	bne.n	70005ed0 <HAL_XSPI_Command+0x114>
      {
        if (pCmd->DataMode == HAL_XSPI_DATA_NONE)
70005e48:	68bb      	ldr	r3, [r7, #8]
70005e4a:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70005e4c:	2b00      	cmp	r3, #0
70005e4e:	d10e      	bne.n	70005e6e <HAL_XSPI_Command+0xb2>
        {
          /* When there is no data phase, the transfer start as soon as the configuration is done
             so wait until BUSY flag is reset to go back in idle state. */
          status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
70005e50:	687b      	ldr	r3, [r7, #4]
70005e52:	9300      	str	r3, [sp, #0]
70005e54:	69bb      	ldr	r3, [r7, #24]
70005e56:	2200      	movs	r2, #0
70005e58:	2120      	movs	r1, #32
70005e5a:	68f8      	ldr	r0, [r7, #12]
70005e5c:	f000 fb64 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
70005e60:	4603      	mov	r3, r0
70005e62:	77fb      	strb	r3, [r7, #31]

          /* Clear TC flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
70005e64:	68fb      	ldr	r3, [r7, #12]
70005e66:	681b      	ldr	r3, [r3, #0]
70005e68:	2202      	movs	r2, #2
70005e6a:	625a      	str	r2, [r3, #36]	@ 0x24
    if (status == HAL_OK)
70005e6c:	e030      	b.n	70005ed0 <HAL_XSPI_Command+0x114>
        }
        else
        {
          /* Update the state */
          if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
70005e6e:	68bb      	ldr	r3, [r7, #8]
70005e70:	681b      	ldr	r3, [r3, #0]
70005e72:	2b00      	cmp	r3, #0
70005e74:	d103      	bne.n	70005e7e <HAL_XSPI_Command+0xc2>
          {
            hxspi->State = HAL_XSPI_STATE_CMD_CFG;
70005e76:	68fb      	ldr	r3, [r7, #12]
70005e78:	2204      	movs	r2, #4
70005e7a:	655a      	str	r2, [r3, #84]	@ 0x54
    if (status == HAL_OK)
70005e7c:	e028      	b.n	70005ed0 <HAL_XSPI_Command+0x114>
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_READ_CFG)
70005e7e:	68bb      	ldr	r3, [r7, #8]
70005e80:	681b      	ldr	r3, [r3, #0]
70005e82:	2b01      	cmp	r3, #1
70005e84:	d10b      	bne.n	70005e9e <HAL_XSPI_Command+0xe2>
          {
            if (hxspi->State == HAL_XSPI_STATE_WRITE_CMD_CFG)
70005e86:	68fb      	ldr	r3, [r7, #12]
70005e88:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70005e8a:	2b24      	cmp	r3, #36	@ 0x24
70005e8c:	d103      	bne.n	70005e96 <HAL_XSPI_Command+0xda>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
70005e8e:	68fb      	ldr	r3, [r7, #12]
70005e90:	2204      	movs	r2, #4
70005e92:	655a      	str	r2, [r3, #84]	@ 0x54
    if (status == HAL_OK)
70005e94:	e01c      	b.n	70005ed0 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_READ_CMD_CFG;
70005e96:	68fb      	ldr	r3, [r7, #12]
70005e98:	2214      	movs	r2, #20
70005e9a:	655a      	str	r2, [r3, #84]	@ 0x54
    if (status == HAL_OK)
70005e9c:	e018      	b.n	70005ed0 <HAL_XSPI_Command+0x114>
            }
          }
          else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
70005e9e:	68bb      	ldr	r3, [r7, #8]
70005ea0:	681b      	ldr	r3, [r3, #0]
70005ea2:	2b02      	cmp	r3, #2
70005ea4:	d114      	bne.n	70005ed0 <HAL_XSPI_Command+0x114>
          {
            if (hxspi->State == HAL_XSPI_STATE_READ_CMD_CFG)
70005ea6:	68fb      	ldr	r3, [r7, #12]
70005ea8:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70005eaa:	2b14      	cmp	r3, #20
70005eac:	d103      	bne.n	70005eb6 <HAL_XSPI_Command+0xfa>
            {
              hxspi->State = HAL_XSPI_STATE_CMD_CFG;
70005eae:	68fb      	ldr	r3, [r7, #12]
70005eb0:	2204      	movs	r2, #4
70005eb2:	655a      	str	r2, [r3, #84]	@ 0x54
    if (status == HAL_OK)
70005eb4:	e00c      	b.n	70005ed0 <HAL_XSPI_Command+0x114>
            }
            else
            {
              hxspi->State = HAL_XSPI_STATE_WRITE_CMD_CFG;
70005eb6:	68fb      	ldr	r3, [r7, #12]
70005eb8:	2224      	movs	r2, #36	@ 0x24
70005eba:	655a      	str	r2, [r3, #84]	@ 0x54
    if (status == HAL_OK)
70005ebc:	e008      	b.n	70005ed0 <HAL_XSPI_Command+0x114>
        }
      }
    }
    else
    {
      status = HAL_BUSY;
70005ebe:	2302      	movs	r3, #2
70005ec0:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
70005ec2:	e005      	b.n	70005ed0 <HAL_XSPI_Command+0x114>
    }
  }
  else
  {
    status = HAL_ERROR;
70005ec4:	2301      	movs	r3, #1
70005ec6:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
70005ec8:	68fb      	ldr	r3, [r7, #12]
70005eca:	2210      	movs	r2, #16
70005ecc:	659a      	str	r2, [r3, #88]	@ 0x58
70005ece:	e000      	b.n	70005ed2 <HAL_XSPI_Command+0x116>
    if (status == HAL_OK)
70005ed0:	bf00      	nop
  }

  return status;
70005ed2:	7ffb      	ldrb	r3, [r7, #31]
}
70005ed4:	4618      	mov	r0, r3
70005ed6:	3720      	adds	r7, #32
70005ed8:	46bd      	mov	sp, r7
70005eda:	bd80      	pop	{r7, pc}

70005edc <HAL_XSPI_Transmit>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Write Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Transmit(XSPI_HandleTypeDef *hxspi, const uint8_t *pData, uint32_t Timeout)
{
70005edc:	b580      	push	{r7, lr}
70005ede:	b08a      	sub	sp, #40	@ 0x28
70005ee0:	af02      	add	r7, sp, #8
70005ee2:	60f8      	str	r0, [r7, #12]
70005ee4:	60b9      	str	r1, [r7, #8]
70005ee6:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
70005ee8:	f7fb fc2c 	bl	70001744 <HAL_GetTick>
70005eec:	61b8      	str	r0, [r7, #24]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
70005eee:	68fb      	ldr	r3, [r7, #12]
70005ef0:	681b      	ldr	r3, [r3, #0]
70005ef2:	3350      	adds	r3, #80	@ 0x50
70005ef4:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
70005ef6:	68bb      	ldr	r3, [r7, #8]
70005ef8:	2b00      	cmp	r3, #0
70005efa:	d105      	bne.n	70005f08 <HAL_XSPI_Transmit+0x2c>
  {
    status = HAL_ERROR;
70005efc:	2301      	movs	r3, #1
70005efe:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
70005f00:	68fb      	ldr	r3, [r7, #12]
70005f02:	2208      	movs	r2, #8
70005f04:	659a      	str	r2, [r3, #88]	@ 0x58
70005f06:	e057      	b.n	70005fb8 <HAL_XSPI_Transmit+0xdc>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
70005f08:	68fb      	ldr	r3, [r7, #12]
70005f0a:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70005f0c:	2b04      	cmp	r3, #4
70005f0e:	d14e      	bne.n	70005fae <HAL_XSPI_Transmit+0xd2>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
70005f10:	68fb      	ldr	r3, [r7, #12]
70005f12:	681b      	ldr	r3, [r3, #0]
70005f14:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70005f16:	1c5a      	adds	r2, r3, #1
70005f18:	68fb      	ldr	r3, [r7, #12]
70005f1a:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->XferSize  = hxspi->XferCount;
70005f1c:	68fb      	ldr	r3, [r7, #12]
70005f1e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
70005f20:	68fb      	ldr	r3, [r7, #12]
70005f22:	645a      	str	r2, [r3, #68]	@ 0x44
      hxspi->pBuffPtr  = (uint8_t *)pData;
70005f24:	68fb      	ldr	r3, [r7, #12]
70005f26:	68ba      	ldr	r2, [r7, #8]
70005f28:	641a      	str	r2, [r3, #64]	@ 0x40

      /* Configure CR register with functional mode as indirect write */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_WRITE);
70005f2a:	68fb      	ldr	r3, [r7, #12]
70005f2c:	681b      	ldr	r3, [r3, #0]
70005f2e:	681a      	ldr	r2, [r3, #0]
70005f30:	68fb      	ldr	r3, [r7, #12]
70005f32:	681b      	ldr	r3, [r3, #0]
70005f34:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
70005f38:	601a      	str	r2, [r3, #0]

      do
      {
        /* Wait till fifo threshold flag is set to send data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_FT, SET, tickstart, Timeout);
70005f3a:	687b      	ldr	r3, [r7, #4]
70005f3c:	9300      	str	r3, [sp, #0]
70005f3e:	69bb      	ldr	r3, [r7, #24]
70005f40:	2201      	movs	r2, #1
70005f42:	2104      	movs	r1, #4
70005f44:	68f8      	ldr	r0, [r7, #12]
70005f46:	f000 faef 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
70005f4a:	4603      	mov	r3, r0
70005f4c:	77fb      	strb	r3, [r7, #31]

        if (status != HAL_OK)
70005f4e:	7ffb      	ldrb	r3, [r7, #31]
70005f50:	2b00      	cmp	r3, #0
70005f52:	d113      	bne.n	70005f7c <HAL_XSPI_Transmit+0xa0>
        {
          break;
        }

        *((__IO uint8_t *)data_reg) = *hxspi->pBuffPtr;
70005f54:	68fb      	ldr	r3, [r7, #12]
70005f56:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70005f58:	781a      	ldrb	r2, [r3, #0]
70005f5a:	697b      	ldr	r3, [r7, #20]
70005f5c:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
70005f5e:	68fb      	ldr	r3, [r7, #12]
70005f60:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70005f62:	1c5a      	adds	r2, r3, #1
70005f64:	68fb      	ldr	r3, [r7, #12]
70005f66:	641a      	str	r2, [r3, #64]	@ 0x40
        hxspi->XferCount--;
70005f68:	68fb      	ldr	r3, [r7, #12]
70005f6a:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
70005f6c:	1e5a      	subs	r2, r3, #1
70005f6e:	68fb      	ldr	r3, [r7, #12]
70005f70:	649a      	str	r2, [r3, #72]	@ 0x48
      } while (hxspi->XferCount > 0U);
70005f72:	68fb      	ldr	r3, [r7, #12]
70005f74:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
70005f76:	2b00      	cmp	r3, #0
70005f78:	d1df      	bne.n	70005f3a <HAL_XSPI_Transmit+0x5e>
70005f7a:	e000      	b.n	70005f7e <HAL_XSPI_Transmit+0xa2>
          break;
70005f7c:	bf00      	nop

      if (status == HAL_OK)
70005f7e:	7ffb      	ldrb	r3, [r7, #31]
70005f80:	2b00      	cmp	r3, #0
70005f82:	d119      	bne.n	70005fb8 <HAL_XSPI_Transmit+0xdc>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
70005f84:	687b      	ldr	r3, [r7, #4]
70005f86:	9300      	str	r3, [sp, #0]
70005f88:	69bb      	ldr	r3, [r7, #24]
70005f8a:	2201      	movs	r2, #1
70005f8c:	2102      	movs	r1, #2
70005f8e:	68f8      	ldr	r0, [r7, #12]
70005f90:	f000 faca 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
70005f94:	4603      	mov	r3, r0
70005f96:	77fb      	strb	r3, [r7, #31]

        if (status == HAL_OK)
70005f98:	7ffb      	ldrb	r3, [r7, #31]
70005f9a:	2b00      	cmp	r3, #0
70005f9c:	d10c      	bne.n	70005fb8 <HAL_XSPI_Transmit+0xdc>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
70005f9e:	68fb      	ldr	r3, [r7, #12]
70005fa0:	681b      	ldr	r3, [r3, #0]
70005fa2:	2202      	movs	r2, #2
70005fa4:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
70005fa6:	68fb      	ldr	r3, [r7, #12]
70005fa8:	2202      	movs	r2, #2
70005faa:	655a      	str	r2, [r3, #84]	@ 0x54
70005fac:	e004      	b.n	70005fb8 <HAL_XSPI_Transmit+0xdc>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
70005fae:	2301      	movs	r3, #1
70005fb0:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
70005fb2:	68fb      	ldr	r3, [r7, #12]
70005fb4:	2210      	movs	r2, #16
70005fb6:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  return status;
70005fb8:	7ffb      	ldrb	r3, [r7, #31]
}
70005fba:	4618      	mov	r0, r3
70005fbc:	3720      	adds	r7, #32
70005fbe:	46bd      	mov	sp, r7
70005fc0:	bd80      	pop	{r7, pc}

70005fc2 <HAL_XSPI_Receive>:
  * @param  Timeout : Timeout duration
  * @note   This function is used only in Indirect Read Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Receive(XSPI_HandleTypeDef *hxspi, uint8_t *pData, uint32_t Timeout)
{
70005fc2:	b580      	push	{r7, lr}
70005fc4:	b08c      	sub	sp, #48	@ 0x30
70005fc6:	af02      	add	r7, sp, #8
70005fc8:	60f8      	str	r0, [r7, #12]
70005fca:	60b9      	str	r1, [r7, #8]
70005fcc:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
70005fce:	f7fb fbb9 	bl	70001744 <HAL_GetTick>
70005fd2:	6238      	str	r0, [r7, #32]
  __IO uint32_t *data_reg = &hxspi->Instance->DR;
70005fd4:	68fb      	ldr	r3, [r7, #12]
70005fd6:	681b      	ldr	r3, [r3, #0]
70005fd8:	3350      	adds	r3, #80	@ 0x50
70005fda:	61fb      	str	r3, [r7, #28]
  uint32_t addr_reg = hxspi->Instance->AR;
70005fdc:	68fb      	ldr	r3, [r7, #12]
70005fde:	681b      	ldr	r3, [r3, #0]
70005fe0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
70005fe2:	61bb      	str	r3, [r7, #24]
  uint32_t ir_reg = hxspi->Instance->IR;
70005fe4:	68fb      	ldr	r3, [r7, #12]
70005fe6:	681b      	ldr	r3, [r3, #0]
70005fe8:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
70005fec:	617b      	str	r3, [r7, #20]

  /* Check the data pointer allocation */
  if (pData == NULL)
70005fee:	68bb      	ldr	r3, [r7, #8]
70005ff0:	2b00      	cmp	r3, #0
70005ff2:	d106      	bne.n	70006002 <HAL_XSPI_Receive+0x40>
  {
    status = HAL_ERROR;
70005ff4:	2301      	movs	r3, #1
70005ff6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
70005ffa:	68fb      	ldr	r3, [r7, #12]
70005ffc:	2208      	movs	r2, #8
70005ffe:	659a      	str	r2, [r3, #88]	@ 0x58
70006000:	e07c      	b.n	700060fc <HAL_XSPI_Receive+0x13a>
  }
  else
  {
    /* Check the state */
    if (hxspi->State == HAL_XSPI_STATE_CMD_CFG)
70006002:	68fb      	ldr	r3, [r7, #12]
70006004:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70006006:	2b04      	cmp	r3, #4
70006008:	d172      	bne.n	700060f0 <HAL_XSPI_Receive+0x12e>
    {
      /* Configure counters and size */
      hxspi->XferCount = READ_REG(hxspi->Instance->DLR) + 1U;
7000600a:	68fb      	ldr	r3, [r7, #12]
7000600c:	681b      	ldr	r3, [r3, #0]
7000600e:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70006010:	1c5a      	adds	r2, r3, #1
70006012:	68fb      	ldr	r3, [r7, #12]
70006014:	649a      	str	r2, [r3, #72]	@ 0x48
      hxspi->XferSize  = hxspi->XferCount;
70006016:	68fb      	ldr	r3, [r7, #12]
70006018:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
7000601a:	68fb      	ldr	r3, [r7, #12]
7000601c:	645a      	str	r2, [r3, #68]	@ 0x44
      hxspi->pBuffPtr  = pData;
7000601e:	68fb      	ldr	r3, [r7, #12]
70006020:	68ba      	ldr	r2, [r7, #8]
70006022:	641a      	str	r2, [r3, #64]	@ 0x40

      /* Configure CR register with functional mode as indirect read */
      MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, XSPI_FUNCTIONAL_MODE_INDIRECT_READ);
70006024:	68fb      	ldr	r3, [r7, #12]
70006026:	681b      	ldr	r3, [r3, #0]
70006028:	681b      	ldr	r3, [r3, #0]
7000602a:	f023 5240 	bic.w	r2, r3, #805306368	@ 0x30000000
7000602e:	68fb      	ldr	r3, [r7, #12]
70006030:	681b      	ldr	r3, [r3, #0]
70006032:	f042 5280 	orr.w	r2, r2, #268435456	@ 0x10000000
70006036:	601a      	str	r2, [r3, #0]

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
70006038:	68fb      	ldr	r3, [r7, #12]
7000603a:	68db      	ldr	r3, [r3, #12]
7000603c:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
70006040:	d104      	bne.n	7000604c <HAL_XSPI_Receive+0x8a>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
70006042:	68fb      	ldr	r3, [r7, #12]
70006044:	681b      	ldr	r3, [r3, #0]
70006046:	69ba      	ldr	r2, [r7, #24]
70006048:	649a      	str	r2, [r3, #72]	@ 0x48
7000604a:	e011      	b.n	70006070 <HAL_XSPI_Receive+0xae>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
7000604c:	68fb      	ldr	r3, [r7, #12]
7000604e:	681b      	ldr	r3, [r3, #0]
70006050:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
70006054:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
70006058:	2b00      	cmp	r3, #0
7000605a:	d004      	beq.n	70006066 <HAL_XSPI_Receive+0xa4>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
7000605c:	68fb      	ldr	r3, [r7, #12]
7000605e:	681b      	ldr	r3, [r3, #0]
70006060:	69ba      	ldr	r2, [r7, #24]
70006062:	649a      	str	r2, [r3, #72]	@ 0x48
70006064:	e004      	b.n	70006070 <HAL_XSPI_Receive+0xae>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
70006066:	68fb      	ldr	r3, [r7, #12]
70006068:	681b      	ldr	r3, [r3, #0]
7000606a:	697a      	ldr	r2, [r7, #20]
7000606c:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
      }

      do
      {
        /* Wait till fifo threshold or transfer complete flags are set to read received data */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, (HAL_XSPI_FLAG_FT | HAL_XSPI_FLAG_TC), SET, tickstart, Timeout);
70006070:	687b      	ldr	r3, [r7, #4]
70006072:	9300      	str	r3, [sp, #0]
70006074:	6a3b      	ldr	r3, [r7, #32]
70006076:	2201      	movs	r2, #1
70006078:	2106      	movs	r1, #6
7000607a:	68f8      	ldr	r0, [r7, #12]
7000607c:	f000 fa54 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
70006080:	4603      	mov	r3, r0
70006082:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status != HAL_OK)
70006086:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
7000608a:	2b00      	cmp	r3, #0
7000608c:	d114      	bne.n	700060b8 <HAL_XSPI_Receive+0xf6>
        {
          break;
        }

        *hxspi->pBuffPtr = *((__IO uint8_t *)data_reg);
7000608e:	68fb      	ldr	r3, [r7, #12]
70006090:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
70006092:	69fa      	ldr	r2, [r7, #28]
70006094:	7812      	ldrb	r2, [r2, #0]
70006096:	b2d2      	uxtb	r2, r2
70006098:	701a      	strb	r2, [r3, #0]
        hxspi->pBuffPtr++;
7000609a:	68fb      	ldr	r3, [r7, #12]
7000609c:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
7000609e:	1c5a      	adds	r2, r3, #1
700060a0:	68fb      	ldr	r3, [r7, #12]
700060a2:	641a      	str	r2, [r3, #64]	@ 0x40
        hxspi->XferCount--;
700060a4:	68fb      	ldr	r3, [r7, #12]
700060a6:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
700060a8:	1e5a      	subs	r2, r3, #1
700060aa:	68fb      	ldr	r3, [r7, #12]
700060ac:	649a      	str	r2, [r3, #72]	@ 0x48
      } while (hxspi->XferCount > 0U);
700060ae:	68fb      	ldr	r3, [r7, #12]
700060b0:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
700060b2:	2b00      	cmp	r3, #0
700060b4:	d1dc      	bne.n	70006070 <HAL_XSPI_Receive+0xae>
700060b6:	e000      	b.n	700060ba <HAL_XSPI_Receive+0xf8>
          break;
700060b8:	bf00      	nop

      if (status == HAL_OK)
700060ba:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
700060be:	2b00      	cmp	r3, #0
700060c0:	d11c      	bne.n	700060fc <HAL_XSPI_Receive+0x13a>
      {
        /* Wait till transfer complete flag is set to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, Timeout);
700060c2:	687b      	ldr	r3, [r7, #4]
700060c4:	9300      	str	r3, [sp, #0]
700060c6:	6a3b      	ldr	r3, [r7, #32]
700060c8:	2201      	movs	r2, #1
700060ca:	2102      	movs	r1, #2
700060cc:	68f8      	ldr	r0, [r7, #12]
700060ce:	f000 fa2b 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
700060d2:	4603      	mov	r3, r0
700060d4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27

        if (status == HAL_OK)
700060d8:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
700060dc:	2b00      	cmp	r3, #0
700060de:	d10d      	bne.n	700060fc <HAL_XSPI_Receive+0x13a>
        {
          /* Clear transfer complete flag */
          HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
700060e0:	68fb      	ldr	r3, [r7, #12]
700060e2:	681b      	ldr	r3, [r3, #0]
700060e4:	2202      	movs	r2, #2
700060e6:	625a      	str	r2, [r3, #36]	@ 0x24

          hxspi->State = HAL_XSPI_STATE_READY;
700060e8:	68fb      	ldr	r3, [r7, #12]
700060ea:	2202      	movs	r2, #2
700060ec:	655a      	str	r2, [r3, #84]	@ 0x54
700060ee:	e005      	b.n	700060fc <HAL_XSPI_Receive+0x13a>
        }
      }
    }
    else
    {
      status = HAL_ERROR;
700060f0:	2301      	movs	r3, #1
700060f2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
700060f6:	68fb      	ldr	r3, [r7, #12]
700060f8:	2210      	movs	r2, #16
700060fa:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  return status;
700060fc:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
70006100:	4618      	mov	r0, r3
70006102:	3728      	adds	r7, #40	@ 0x28
70006104:	46bd      	mov	sp, r7
70006106:	bd80      	pop	{r7, pc}

70006108 <HAL_XSPI_AutoPolling>:
  * @note   This function is used only in Automatic Polling Mode
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_AutoPolling(XSPI_HandleTypeDef *hxspi, const XSPI_AutoPollingTypeDef *pCfg,
                                       uint32_t Timeout)
{
70006108:	b580      	push	{r7, lr}
7000610a:	b08a      	sub	sp, #40	@ 0x28
7000610c:	af02      	add	r7, sp, #8
7000610e:	60f8      	str	r0, [r7, #12]
70006110:	60b9      	str	r1, [r7, #8]
70006112:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status;
  uint32_t tickstart = HAL_GetTick();
70006114:	f7fb fb16 	bl	70001744 <HAL_GetTick>
70006118:	61b8      	str	r0, [r7, #24]
  uint32_t addr_reg = hxspi->Instance->AR;
7000611a:	68fb      	ldr	r3, [r7, #12]
7000611c:	681b      	ldr	r3, [r3, #0]
7000611e:	6c9b      	ldr	r3, [r3, #72]	@ 0x48
70006120:	617b      	str	r3, [r7, #20]
  uint32_t ir_reg = hxspi->Instance->IR;
70006122:	68fb      	ldr	r3, [r7, #12]
70006124:	681b      	ldr	r3, [r3, #0]
70006126:	f8d3 3110 	ldr.w	r3, [r3, #272]	@ 0x110
7000612a:	613b      	str	r3, [r7, #16]
  assert_param(IS_XSPI_AUTOMATIC_STOP(pCfg->AutomaticStop));
  assert_param(IS_XSPI_INTERVAL(pCfg->IntervalTime));
  assert_param(IS_XSPI_STATUS_BYTES_SIZE(dlr_reg + 1U));

  /* Check the state */
  if ((hxspi->State == HAL_XSPI_STATE_CMD_CFG) && (pCfg->AutomaticStop == HAL_XSPI_AUTOMATIC_STOP_ENABLE))
7000612c:	68fb      	ldr	r3, [r7, #12]
7000612e:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70006130:	2b04      	cmp	r3, #4
70006132:	d167      	bne.n	70006204 <HAL_XSPI_AutoPolling+0xfc>
70006134:	68bb      	ldr	r3, [r7, #8]
70006136:	68db      	ldr	r3, [r3, #12]
70006138:	f5b3 0f80 	cmp.w	r3, #4194304	@ 0x400000
7000613c:	d162      	bne.n	70006204 <HAL_XSPI_AutoPolling+0xfc>
  {
    /* Wait till busy flag is reset */
    status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, Timeout);
7000613e:	687b      	ldr	r3, [r7, #4]
70006140:	9300      	str	r3, [sp, #0]
70006142:	69bb      	ldr	r3, [r7, #24]
70006144:	2200      	movs	r2, #0
70006146:	2120      	movs	r1, #32
70006148:	68f8      	ldr	r0, [r7, #12]
7000614a:	f000 f9ed 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
7000614e:	4603      	mov	r3, r0
70006150:	77fb      	strb	r3, [r7, #31]

    if (status == HAL_OK)
70006152:	7ffb      	ldrb	r3, [r7, #31]
70006154:	2b00      	cmp	r3, #0
70006156:	d152      	bne.n	700061fe <HAL_XSPI_AutoPolling+0xf6>
    {
      /* Configure registers */
      WRITE_REG(hxspi->Instance->PSMAR, pCfg->MatchValue);
70006158:	68fb      	ldr	r3, [r7, #12]
7000615a:	681b      	ldr	r3, [r3, #0]
7000615c:	68ba      	ldr	r2, [r7, #8]
7000615e:	6812      	ldr	r2, [r2, #0]
70006160:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
      WRITE_REG(hxspi->Instance->PSMKR, pCfg->MatchMask);
70006164:	68fb      	ldr	r3, [r7, #12]
70006166:	681b      	ldr	r3, [r3, #0]
70006168:	68ba      	ldr	r2, [r7, #8]
7000616a:	6852      	ldr	r2, [r2, #4]
7000616c:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
      WRITE_REG(hxspi->Instance->PIR,   pCfg->IntervalTime);
70006170:	68fb      	ldr	r3, [r7, #12]
70006172:	681b      	ldr	r3, [r3, #0]
70006174:	68ba      	ldr	r2, [r7, #8]
70006176:	6912      	ldr	r2, [r2, #16]
70006178:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
      MODIFY_REG(hxspi->Instance->CR, (XSPI_CR_PMM | XSPI_CR_APMS | XSPI_CR_FMODE),
7000617c:	68fb      	ldr	r3, [r7, #12]
7000617e:	681b      	ldr	r3, [r3, #0]
70006180:	681b      	ldr	r3, [r3, #0]
70006182:	f023 5243 	bic.w	r2, r3, #817889280	@ 0x30c00000
70006186:	68bb      	ldr	r3, [r7, #8]
70006188:	6899      	ldr	r1, [r3, #8]
7000618a:	68bb      	ldr	r3, [r7, #8]
7000618c:	68db      	ldr	r3, [r3, #12]
7000618e:	430b      	orrs	r3, r1
70006190:	431a      	orrs	r2, r3
70006192:	68fb      	ldr	r3, [r7, #12]
70006194:	681b      	ldr	r3, [r3, #0]
70006196:	f042 5200 	orr.w	r2, r2, #536870912	@ 0x20000000
7000619a:	601a      	str	r2, [r3, #0]
                 (pCfg->MatchMode | pCfg->AutomaticStop | XSPI_FUNCTIONAL_MODE_AUTO_POLLING));

      /* Trig the transfer by re-writing address or instruction register */
      if (hxspi->Init.MemoryType == HAL_XSPI_MEMTYPE_HYPERBUS)
7000619c:	68fb      	ldr	r3, [r7, #12]
7000619e:	68db      	ldr	r3, [r3, #12]
700061a0:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
700061a4:	d104      	bne.n	700061b0 <HAL_XSPI_AutoPolling+0xa8>
      {
        WRITE_REG(hxspi->Instance->AR, addr_reg);
700061a6:	68fb      	ldr	r3, [r7, #12]
700061a8:	681b      	ldr	r3, [r3, #0]
700061aa:	697a      	ldr	r2, [r7, #20]
700061ac:	649a      	str	r2, [r3, #72]	@ 0x48
700061ae:	e011      	b.n	700061d4 <HAL_XSPI_AutoPolling+0xcc>
      }
      else
      {
        if (READ_BIT(hxspi->Instance->CCR, XSPI_CCR_ADMODE) != HAL_XSPI_ADDRESS_NONE)
700061b0:	68fb      	ldr	r3, [r7, #12]
700061b2:	681b      	ldr	r3, [r3, #0]
700061b4:	f8d3 3100 	ldr.w	r3, [r3, #256]	@ 0x100
700061b8:	f403 63e0 	and.w	r3, r3, #1792	@ 0x700
700061bc:	2b00      	cmp	r3, #0
700061be:	d004      	beq.n	700061ca <HAL_XSPI_AutoPolling+0xc2>
        {
          WRITE_REG(hxspi->Instance->AR, addr_reg);
700061c0:	68fb      	ldr	r3, [r7, #12]
700061c2:	681b      	ldr	r3, [r3, #0]
700061c4:	697a      	ldr	r2, [r7, #20]
700061c6:	649a      	str	r2, [r3, #72]	@ 0x48
700061c8:	e004      	b.n	700061d4 <HAL_XSPI_AutoPolling+0xcc>
        }
        else
        {
          WRITE_REG(hxspi->Instance->IR, ir_reg);
700061ca:	68fb      	ldr	r3, [r7, #12]
700061cc:	681b      	ldr	r3, [r3, #0]
700061ce:	693a      	ldr	r2, [r7, #16]
700061d0:	f8c3 2110 	str.w	r2, [r3, #272]	@ 0x110
        }
      }

      /* Wait till status match flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_SM, SET, tickstart, Timeout);
700061d4:	687b      	ldr	r3, [r7, #4]
700061d6:	9300      	str	r3, [sp, #0]
700061d8:	69bb      	ldr	r3, [r7, #24]
700061da:	2201      	movs	r2, #1
700061dc:	2108      	movs	r1, #8
700061de:	68f8      	ldr	r0, [r7, #12]
700061e0:	f000 f9a2 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
700061e4:	4603      	mov	r3, r0
700061e6:	77fb      	strb	r3, [r7, #31]

      if (status == HAL_OK)
700061e8:	7ffb      	ldrb	r3, [r7, #31]
700061ea:	2b00      	cmp	r3, #0
700061ec:	d110      	bne.n	70006210 <HAL_XSPI_AutoPolling+0x108>
      {
        /* Clear status match flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_SM);
700061ee:	68fb      	ldr	r3, [r7, #12]
700061f0:	681b      	ldr	r3, [r3, #0]
700061f2:	2208      	movs	r2, #8
700061f4:	625a      	str	r2, [r3, #36]	@ 0x24

        hxspi->State = HAL_XSPI_STATE_READY;
700061f6:	68fb      	ldr	r3, [r7, #12]
700061f8:	2202      	movs	r2, #2
700061fa:	655a      	str	r2, [r3, #84]	@ 0x54
    if (status == HAL_OK)
700061fc:	e008      	b.n	70006210 <HAL_XSPI_AutoPolling+0x108>
      }
    }
    else
    {
      status = HAL_BUSY;
700061fe:	2302      	movs	r3, #2
70006200:	77fb      	strb	r3, [r7, #31]
    if (status == HAL_OK)
70006202:	e005      	b.n	70006210 <HAL_XSPI_AutoPolling+0x108>
    }
  }
  else
  {
    status = HAL_ERROR;
70006204:	2301      	movs	r3, #1
70006206:	77fb      	strb	r3, [r7, #31]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
70006208:	68fb      	ldr	r3, [r7, #12]
7000620a:	2210      	movs	r2, #16
7000620c:	659a      	str	r2, [r3, #88]	@ 0x58
7000620e:	e000      	b.n	70006212 <HAL_XSPI_AutoPolling+0x10a>
    if (status == HAL_OK)
70006210:	bf00      	nop
  }

  return status;
70006212:	7ffb      	ldrb	r3, [r7, #31]
}
70006214:	4618      	mov	r0, r3
70006216:	3720      	adds	r7, #32
70006218:	46bd      	mov	sp, r7
7000621a:	bd80      	pop	{r7, pc}

7000621c <HAL_XSPI_Abort>:
  * @brief  Abort the current operation, return to the indirect mode.
  * @param  hxspi : XSPI handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPI_Abort(XSPI_HandleTypeDef *hxspi)
{
7000621c:	b580      	push	{r7, lr}
7000621e:	b086      	sub	sp, #24
70006220:	af02      	add	r7, sp, #8
70006222:	6078      	str	r0, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
70006224:	2300      	movs	r3, #0
70006226:	73fb      	strb	r3, [r7, #15]
  uint32_t tickstart = HAL_GetTick();
70006228:	f7fb fa8c 	bl	70001744 <HAL_GetTick>
7000622c:	60b8      	str	r0, [r7, #8]

  /* Check if the state is not in reset state */
  if (hxspi->State != HAL_XSPI_STATE_RESET)
7000622e:	687b      	ldr	r3, [r7, #4]
70006230:	6d5b      	ldr	r3, [r3, #84]	@ 0x54
70006232:	2b00      	cmp	r3, #0
70006234:	d06f      	beq.n	70006316 <HAL_XSPI_Abort+0xfa>
  {
    /* Check if the DMA is enabled */
    if ((hxspi->Instance->CR & XSPI_CR_DMAEN) != 0U)
70006236:	687b      	ldr	r3, [r7, #4]
70006238:	681b      	ldr	r3, [r3, #0]
7000623a:	681b      	ldr	r3, [r3, #0]
7000623c:	f003 0304 	and.w	r3, r3, #4
70006240:	2b00      	cmp	r3, #0
70006242:	d021      	beq.n	70006288 <HAL_XSPI_Abort+0x6c>
    {
      /* Disable the DMA transfer on the XSPI side */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_DMAEN);
70006244:	687b      	ldr	r3, [r7, #4]
70006246:	681b      	ldr	r3, [r3, #0]
70006248:	681a      	ldr	r2, [r3, #0]
7000624a:	687b      	ldr	r3, [r7, #4]
7000624c:	681b      	ldr	r3, [r3, #0]
7000624e:	f022 0204 	bic.w	r2, r2, #4
70006252:	601a      	str	r2, [r3, #0]

      /* Disable the DMA transmit on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmatx);
70006254:	687b      	ldr	r3, [r7, #4]
70006256:	6cdb      	ldr	r3, [r3, #76]	@ 0x4c
70006258:	4618      	mov	r0, r3
7000625a:	f7fb fbb2 	bl	700019c2 <HAL_DMA_Abort>
7000625e:	4603      	mov	r3, r0
70006260:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
70006262:	7bfb      	ldrb	r3, [r7, #15]
70006264:	2b00      	cmp	r3, #0
70006266:	d002      	beq.n	7000626e <HAL_XSPI_Abort+0x52>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
70006268:	687b      	ldr	r3, [r7, #4]
7000626a:	2204      	movs	r2, #4
7000626c:	659a      	str	r2, [r3, #88]	@ 0x58
      }

      /* Disable the DMA receive on the DMA side */
      status = HAL_DMA_Abort(hxspi->hdmarx);
7000626e:	687b      	ldr	r3, [r7, #4]
70006270:	6d1b      	ldr	r3, [r3, #80]	@ 0x50
70006272:	4618      	mov	r0, r3
70006274:	f7fb fba5 	bl	700019c2 <HAL_DMA_Abort>
70006278:	4603      	mov	r3, r0
7000627a:	73fb      	strb	r3, [r7, #15]
      if (status != HAL_OK)
7000627c:	7bfb      	ldrb	r3, [r7, #15]
7000627e:	2b00      	cmp	r3, #0
70006280:	d002      	beq.n	70006288 <HAL_XSPI_Abort+0x6c>
      {
        hxspi->ErrorCode = HAL_XSPI_ERROR_DMA;
70006282:	687b      	ldr	r3, [r7, #4]
70006284:	2204      	movs	r2, #4
70006286:	659a      	str	r2, [r3, #88]	@ 0x58
      }
    }

    if (HAL_XSPI_GET_FLAG(hxspi, HAL_XSPI_FLAG_BUSY) != RESET)
70006288:	687b      	ldr	r3, [r7, #4]
7000628a:	681b      	ldr	r3, [r3, #0]
7000628c:	6a1b      	ldr	r3, [r3, #32]
7000628e:	f003 0320 	and.w	r3, r3, #32
70006292:	2b00      	cmp	r3, #0
70006294:	d033      	beq.n	700062fe <HAL_XSPI_Abort+0xe2>
    {
      /* Perform an abort of the XSPI */
      SET_BIT(hxspi->Instance->CR, XSPI_CR_ABORT);
70006296:	687b      	ldr	r3, [r7, #4]
70006298:	681b      	ldr	r3, [r3, #0]
7000629a:	681a      	ldr	r2, [r3, #0]
7000629c:	687b      	ldr	r3, [r7, #4]
7000629e:	681b      	ldr	r3, [r3, #0]
700062a0:	f042 0202 	orr.w	r2, r2, #2
700062a4:	601a      	str	r2, [r3, #0]

      /* Wait until the transfer complete flag is set to go back in idle state */
      status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_TC, SET, tickstart, hxspi->Timeout);
700062a6:	687b      	ldr	r3, [r7, #4]
700062a8:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
700062aa:	9300      	str	r3, [sp, #0]
700062ac:	68bb      	ldr	r3, [r7, #8]
700062ae:	2201      	movs	r2, #1
700062b0:	2102      	movs	r1, #2
700062b2:	6878      	ldr	r0, [r7, #4]
700062b4:	f000 f938 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
700062b8:	4603      	mov	r3, r0
700062ba:	73fb      	strb	r3, [r7, #15]

      if (status == HAL_OK)
700062bc:	7bfb      	ldrb	r3, [r7, #15]
700062be:	2b00      	cmp	r3, #0
700062c0:	d12e      	bne.n	70006320 <HAL_XSPI_Abort+0x104>
      {
        /* Clear transfer complete flag */
        HAL_XSPI_CLEAR_FLAG(hxspi, HAL_XSPI_FLAG_TC);
700062c2:	687b      	ldr	r3, [r7, #4]
700062c4:	681b      	ldr	r3, [r3, #0]
700062c6:	2202      	movs	r2, #2
700062c8:	625a      	str	r2, [r3, #36]	@ 0x24

        /* Wait until the busy flag is reset to go back in idle state */
        status = XSPI_WaitFlagStateUntilTimeout(hxspi, HAL_XSPI_FLAG_BUSY, RESET, tickstart, hxspi->Timeout);
700062ca:	687b      	ldr	r3, [r7, #4]
700062cc:	6ddb      	ldr	r3, [r3, #92]	@ 0x5c
700062ce:	9300      	str	r3, [sp, #0]
700062d0:	68bb      	ldr	r3, [r7, #8]
700062d2:	2200      	movs	r2, #0
700062d4:	2120      	movs	r1, #32
700062d6:	6878      	ldr	r0, [r7, #4]
700062d8:	f000 f926 	bl	70006528 <XSPI_WaitFlagStateUntilTimeout>
700062dc:	4603      	mov	r3, r0
700062de:	73fb      	strb	r3, [r7, #15]

        if (status == HAL_OK)
700062e0:	7bfb      	ldrb	r3, [r7, #15]
700062e2:	2b00      	cmp	r3, #0
700062e4:	d11c      	bne.n	70006320 <HAL_XSPI_Abort+0x104>
        {
          /* Return to indirect mode */
          CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
700062e6:	687b      	ldr	r3, [r7, #4]
700062e8:	681b      	ldr	r3, [r3, #0]
700062ea:	681a      	ldr	r2, [r3, #0]
700062ec:	687b      	ldr	r3, [r7, #4]
700062ee:	681b      	ldr	r3, [r3, #0]
700062f0:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
700062f4:	601a      	str	r2, [r3, #0]

          hxspi->State = HAL_XSPI_STATE_READY;
700062f6:	687b      	ldr	r3, [r7, #4]
700062f8:	2202      	movs	r2, #2
700062fa:	655a      	str	r2, [r3, #84]	@ 0x54
700062fc:	e010      	b.n	70006320 <HAL_XSPI_Abort+0x104>
      }
    }
    else
    {
      /* Return to indirect mode */
      CLEAR_BIT(hxspi->Instance->CR, XSPI_CR_FMODE);
700062fe:	687b      	ldr	r3, [r7, #4]
70006300:	681b      	ldr	r3, [r3, #0]
70006302:	681a      	ldr	r2, [r3, #0]
70006304:	687b      	ldr	r3, [r7, #4]
70006306:	681b      	ldr	r3, [r3, #0]
70006308:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
7000630c:	601a      	str	r2, [r3, #0]

      hxspi->State = HAL_XSPI_STATE_READY;
7000630e:	687b      	ldr	r3, [r7, #4]
70006310:	2202      	movs	r2, #2
70006312:	655a      	str	r2, [r3, #84]	@ 0x54
70006314:	e004      	b.n	70006320 <HAL_XSPI_Abort+0x104>
    }
  }
  else
  {
    status = HAL_ERROR;
70006316:	2301      	movs	r3, #1
70006318:	73fb      	strb	r3, [r7, #15]
    hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_SEQUENCE;
7000631a:	687b      	ldr	r3, [r7, #4]
7000631c:	2210      	movs	r2, #16
7000631e:	659a      	str	r2, [r3, #88]	@ 0x58
  }

  return status;
70006320:	7bfb      	ldrb	r3, [r7, #15]
}
70006322:	4618      	mov	r0, r3
70006324:	3710      	adds	r7, #16
70006326:	46bd      	mov	sp, r7
70006328:	bd80      	pop	{r7, pc}

7000632a <HAL_XSPI_SetTimeout>:
  * @param  hxspi   : XSPI handle.
  * @param  Timeout : Timeout for the memory access.
  * @retval HAL state
  */
HAL_StatusTypeDef HAL_XSPI_SetTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Timeout)
{
7000632a:	b480      	push	{r7}
7000632c:	b083      	sub	sp, #12
7000632e:	af00      	add	r7, sp, #0
70006330:	6078      	str	r0, [r7, #4]
70006332:	6039      	str	r1, [r7, #0]
  hxspi->Timeout = Timeout;
70006334:	687b      	ldr	r3, [r7, #4]
70006336:	683a      	ldr	r2, [r7, #0]
70006338:	65da      	str	r2, [r3, #92]	@ 0x5c
  return HAL_OK;
7000633a:	2300      	movs	r3, #0
}
7000633c:	4618      	mov	r0, r3
7000633e:	370c      	adds	r7, #12
70006340:	46bd      	mov	sp, r7
70006342:	f85d 7b04 	ldr.w	r7, [sp], #4
70006346:	4770      	bx	lr

70006348 <HAL_XSPIM_Config>:
  * @param  pCfg     : Pointer to Configuration of the IO Manager for the instance
  * @param  Timeout : Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_XSPIM_Config(XSPI_HandleTypeDef *hxspi, const XSPIM_CfgTypeDef *pCfg, uint32_t Timeout)
{
70006348:	b580      	push	{r7, lr}
7000634a:	b08c      	sub	sp, #48	@ 0x30
7000634c:	af00      	add	r7, sp, #0
7000634e:	60f8      	str	r0, [r7, #12]
70006350:	60b9      	str	r1, [r7, #8]
70006352:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef status = HAL_OK;
70006354:	2300      	movs	r3, #0
70006356:	f887 302d 	strb.w	r3, [r7, #45]	@ 0x2d
  uint8_t index;
  uint8_t xspi_enabled = 0U;
7000635a:	2300      	movs	r3, #0
7000635c:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e

  XSPIM_CfgTypeDef IOM_cfg[XSPI_NB_INSTANCE] = {0};
70006360:	f107 0314 	add.w	r3, r7, #20
70006364:	2200      	movs	r2, #0
70006366:	601a      	str	r2, [r3, #0]
70006368:	605a      	str	r2, [r3, #4]
7000636a:	609a      	str	r2, [r3, #8]
7000636c:	60da      	str	r2, [r3, #12]
7000636e:	611a      	str	r2, [r3, #16]
70006370:	615a      	str	r2, [r3, #20]
  assert_param(IS_XSPIM_NCS_OVR(pCfg->nCSOverride));
  assert_param(IS_XSPIM_IO_PORT(pCfg->IOPort));
  assert_param(IS_XSPIM_REQ2ACKTIME(pCfg->Req2AckTime));

  /**************** Get current configuration of the instances ****************/
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
70006372:	2300      	movs	r3, #0
70006374:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
70006378:	e014      	b.n	700063a4 <HAL_XSPIM_Config+0x5c>
  {
    XSPIM_GetConfig(index + 1U, &(IOM_cfg[index]));
7000637a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
7000637e:	3301      	adds	r3, #1
70006380:	b2d8      	uxtb	r0, r3
70006382:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
70006386:	f107 0114 	add.w	r1, r7, #20
7000638a:	4613      	mov	r3, r2
7000638c:	005b      	lsls	r3, r3, #1
7000638e:	4413      	add	r3, r2
70006390:	009b      	lsls	r3, r3, #2
70006392:	440b      	add	r3, r1
70006394:	4619      	mov	r1, r3
70006396:	f000 fa87 	bl	700068a8 <XSPIM_GetConfig>
  for (index = 0U; index < XSPI_NB_INSTANCE; index++)
7000639a:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
7000639e:	3301      	adds	r3, #1
700063a0:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
700063a4:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
700063a8:	2b01      	cmp	r3, #1
700063aa:	d9e6      	bls.n	7000637a <HAL_XSPIM_Config+0x32>
  }

  /********** Disable both XSPI to configure XSPI IO Manager **********/
  if ((XSPI1->CR & XSPI_CR_EN) != 0U)
700063ac:	4b5b      	ldr	r3, [pc, #364]	@ (7000651c <HAL_XSPIM_Config+0x1d4>)
700063ae:	681b      	ldr	r3, [r3, #0]
700063b0:	f003 0301 	and.w	r3, r3, #1
700063b4:	2b00      	cmp	r3, #0
700063b6:	d00b      	beq.n	700063d0 <HAL_XSPIM_Config+0x88>
  {
    CLEAR_BIT(XSPI1->CR, XSPI_CR_EN);
700063b8:	4b58      	ldr	r3, [pc, #352]	@ (7000651c <HAL_XSPIM_Config+0x1d4>)
700063ba:	681b      	ldr	r3, [r3, #0]
700063bc:	4a57      	ldr	r2, [pc, #348]	@ (7000651c <HAL_XSPIM_Config+0x1d4>)
700063be:	f023 0301 	bic.w	r3, r3, #1
700063c2:	6013      	str	r3, [r2, #0]
    xspi_enabled |= 0x1U;
700063c4:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
700063c8:	f043 0301 	orr.w	r3, r3, #1
700063cc:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
  }
  if ((XSPI2->CR & XSPI_CR_EN) != 0U)
700063d0:	4b53      	ldr	r3, [pc, #332]	@ (70006520 <HAL_XSPIM_Config+0x1d8>)
700063d2:	681b      	ldr	r3, [r3, #0]
700063d4:	f003 0301 	and.w	r3, r3, #1
700063d8:	2b00      	cmp	r3, #0
700063da:	d00b      	beq.n	700063f4 <HAL_XSPIM_Config+0xac>
  {
    CLEAR_BIT(XSPI2->CR, XSPI_CR_EN);
700063dc:	4b50      	ldr	r3, [pc, #320]	@ (70006520 <HAL_XSPIM_Config+0x1d8>)
700063de:	681b      	ldr	r3, [r3, #0]
700063e0:	4a4f      	ldr	r2, [pc, #316]	@ (70006520 <HAL_XSPIM_Config+0x1d8>)
700063e2:	f023 0301 	bic.w	r3, r3, #1
700063e6:	6013      	str	r3, [r2, #0]
    xspi_enabled |= 0x2U;
700063e8:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
700063ec:	f043 0302 	orr.w	r3, r3, #2
700063f0:	f887 302e 	strb.w	r3, [r7, #46]	@ 0x2e
  }

  /***************** Deactivation of previous configuration *****************/
  CLEAR_REG(XSPIM->CR);
700063f4:	4b4b      	ldr	r3, [pc, #300]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
700063f6:	2200      	movs	r2, #0
700063f8:	601a      	str	r2, [r3, #0]

  /******************** Activation of new configuration *********************/
  MODIFY_REG(XSPIM->CR, XSPIM_CR_REQ2ACK_TIME, ((pCfg->Req2AckTime - 1U) << XSPIM_CR_REQ2ACK_TIME_Pos));
700063fa:	4b4a      	ldr	r3, [pc, #296]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
700063fc:	681b      	ldr	r3, [r3, #0]
700063fe:	f423 027f 	bic.w	r2, r3, #16711680	@ 0xff0000
70006402:	68bb      	ldr	r3, [r7, #8]
70006404:	689b      	ldr	r3, [r3, #8]
70006406:	3b01      	subs	r3, #1
70006408:	041b      	lsls	r3, r3, #16
7000640a:	4946      	ldr	r1, [pc, #280]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
7000640c:	4313      	orrs	r3, r2
7000640e:	600b      	str	r3, [r1, #0]

  if (hxspi->Instance == XSPI1)
70006410:	68fb      	ldr	r3, [r7, #12]
70006412:	681b      	ldr	r3, [r3, #0]
70006414:	4a41      	ldr	r2, [pc, #260]	@ (7000651c <HAL_XSPIM_Config+0x1d4>)
70006416:	4293      	cmp	r3, r2
70006418:	d110      	bne.n	7000643c <HAL_XSPIM_Config+0xf4>
  {
    IOM_cfg[0].IOPort = pCfg->IOPort ;
7000641a:	68bb      	ldr	r3, [r7, #8]
7000641c:	685b      	ldr	r3, [r3, #4]
7000641e:	61bb      	str	r3, [r7, #24]
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
70006420:	68bb      	ldr	r3, [r7, #8]
70006422:	681b      	ldr	r3, [r3, #0]
70006424:	2b00      	cmp	r3, #0
70006426:	d027      	beq.n	70006478 <HAL_XSPIM_Config+0x130>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O1 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
70006428:	4b3e      	ldr	r3, [pc, #248]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
7000642a:	681b      	ldr	r3, [r3, #0]
7000642c:	f023 0230 	bic.w	r2, r3, #48	@ 0x30
70006430:	68bb      	ldr	r3, [r7, #8]
70006432:	681b      	ldr	r3, [r3, #0]
70006434:	493b      	ldr	r1, [pc, #236]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
70006436:	4313      	orrs	r3, r2
70006438:	600b      	str	r3, [r1, #0]
7000643a:	e01d      	b.n	70006478 <HAL_XSPIM_Config+0x130>
    else
    {
      /* Nothing to do */
    }
  }
  else if (hxspi->Instance == XSPI2)
7000643c:	68fb      	ldr	r3, [r7, #12]
7000643e:	681b      	ldr	r3, [r3, #0]
70006440:	4a37      	ldr	r2, [pc, #220]	@ (70006520 <HAL_XSPIM_Config+0x1d8>)
70006442:	4293      	cmp	r3, r2
70006444:	d110      	bne.n	70006468 <HAL_XSPIM_Config+0x120>
  {
    IOM_cfg[1].IOPort = pCfg->IOPort ;
70006446:	68bb      	ldr	r3, [r7, #8]
70006448:	685b      	ldr	r3, [r3, #4]
7000644a:	627b      	str	r3, [r7, #36]	@ 0x24
    if (pCfg->nCSOverride != HAL_XSPI_CSSEL_OVR_DISABLED)
7000644c:	68bb      	ldr	r3, [r7, #8]
7000644e:	681b      	ldr	r3, [r3, #0]
70006450:	2b00      	cmp	r3, #0
70006452:	d011      	beq.n	70006478 <HAL_XSPIM_Config+0x130>
    {
      MODIFY_REG(XSPIM->CR, (XSPIM_CR_CSSEL_OVR_O2 | XSPIM_CR_CSSEL_OVR_EN), (pCfg->nCSOverride));
70006454:	4b33      	ldr	r3, [pc, #204]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
70006456:	681b      	ldr	r3, [r3, #0]
70006458:	f023 0250 	bic.w	r2, r3, #80	@ 0x50
7000645c:	68bb      	ldr	r3, [r7, #8]
7000645e:	681b      	ldr	r3, [r3, #0]
70006460:	4930      	ldr	r1, [pc, #192]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
70006462:	4313      	orrs	r3, r2
70006464:	600b      	str	r3, [r1, #0]
70006466:	e007      	b.n	70006478 <HAL_XSPIM_Config+0x130>
      /* Nothing to do */
    }
  }
  else
  {
    hxspi->ErrorCode |= HAL_XSPI_ERROR_INVALID_PARAM;
70006468:	68fb      	ldr	r3, [r7, #12]
7000646a:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
7000646c:	f043 0208 	orr.w	r2, r3, #8
70006470:	68fb      	ldr	r3, [r7, #12]
70006472:	659a      	str	r2, [r3, #88]	@ 0x58
    return HAL_ERROR;
70006474:	2301      	movs	r3, #1
70006476:	e04c      	b.n	70006512 <HAL_XSPIM_Config+0x1ca>
  }

  for (index = 0U; index < (XSPI_NB_INSTANCE - 1U); index++)
70006478:	2300      	movs	r3, #0
7000647a:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
7000647e:	e02a      	b.n	700064d6 <HAL_XSPIM_Config+0x18e>
  {
    if (IOM_cfg[index].IOPort == IOM_cfg[index + 1U].IOPort)
70006480:	f897 202f 	ldrb.w	r2, [r7, #47]	@ 0x2f
70006484:	4613      	mov	r3, r2
70006486:	005b      	lsls	r3, r3, #1
70006488:	4413      	add	r3, r2
7000648a:	009b      	lsls	r3, r3, #2
7000648c:	3330      	adds	r3, #48	@ 0x30
7000648e:	443b      	add	r3, r7
70006490:	3b18      	subs	r3, #24
70006492:	6819      	ldr	r1, [r3, #0]
70006494:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
70006498:	1c5a      	adds	r2, r3, #1
7000649a:	4613      	mov	r3, r2
7000649c:	005b      	lsls	r3, r3, #1
7000649e:	4413      	add	r3, r2
700064a0:	009b      	lsls	r3, r3, #2
700064a2:	3330      	adds	r3, #48	@ 0x30
700064a4:	443b      	add	r3, r7
700064a6:	3b18      	subs	r3, #24
700064a8:	681b      	ldr	r3, [r3, #0]
700064aa:	4299      	cmp	r1, r3
700064ac:	d105      	bne.n	700064ba <HAL_XSPIM_Config+0x172>
    {
      /*Mux*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MUXEN);
700064ae:	4b1d      	ldr	r3, [pc, #116]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
700064b0:	681b      	ldr	r3, [r3, #0]
700064b2:	4a1c      	ldr	r2, [pc, #112]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
700064b4:	f043 0301 	orr.w	r3, r3, #1
700064b8:	6013      	str	r3, [r2, #0]
    }
    else
    {
      /* Nothing to do */
    }
    if (IOM_cfg[0].IOPort == HAL_XSPIM_IOPORT_2)
700064ba:	69bb      	ldr	r3, [r7, #24]
700064bc:	2b01      	cmp	r3, #1
700064be:	d105      	bne.n	700064cc <HAL_XSPIM_Config+0x184>
    {
      /*Mode*/
      SET_BIT(XSPIM->CR, XSPIM_CR_MODE);
700064c0:	4b18      	ldr	r3, [pc, #96]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
700064c2:	681b      	ldr	r3, [r3, #0]
700064c4:	4a17      	ldr	r2, [pc, #92]	@ (70006524 <HAL_XSPIM_Config+0x1dc>)
700064c6:	f043 0302 	orr.w	r3, r3, #2
700064ca:	6013      	str	r3, [r2, #0]
  for (index = 0U; index < (XSPI_NB_INSTANCE - 1U); index++)
700064cc:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
700064d0:	3301      	adds	r3, #1
700064d2:	f887 302f 	strb.w	r3, [r7, #47]	@ 0x2f
700064d6:	f897 302f 	ldrb.w	r3, [r7, #47]	@ 0x2f
700064da:	2b00      	cmp	r3, #0
700064dc:	d0d0      	beq.n	70006480 <HAL_XSPIM_Config+0x138>
      /* Nothing to do */
    }
  }

  /******* Re-enable both XSPI after configure XSPI IO Manager ********/
  if ((xspi_enabled & 0x1U) != 0U)
700064de:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
700064e2:	f003 0301 	and.w	r3, r3, #1
700064e6:	2b00      	cmp	r3, #0
700064e8:	d005      	beq.n	700064f6 <HAL_XSPIM_Config+0x1ae>
  {
    SET_BIT(XSPI1->CR, XSPI_CR_EN);
700064ea:	4b0c      	ldr	r3, [pc, #48]	@ (7000651c <HAL_XSPIM_Config+0x1d4>)
700064ec:	681b      	ldr	r3, [r3, #0]
700064ee:	4a0b      	ldr	r2, [pc, #44]	@ (7000651c <HAL_XSPIM_Config+0x1d4>)
700064f0:	f043 0301 	orr.w	r3, r3, #1
700064f4:	6013      	str	r3, [r2, #0]
  }
  if ((xspi_enabled & 0x2U) != 0U)
700064f6:	f897 302e 	ldrb.w	r3, [r7, #46]	@ 0x2e
700064fa:	f003 0302 	and.w	r3, r3, #2
700064fe:	2b00      	cmp	r3, #0
70006500:	d005      	beq.n	7000650e <HAL_XSPIM_Config+0x1c6>
  {
    SET_BIT(XSPI2->CR, XSPI_CR_EN);
70006502:	4b07      	ldr	r3, [pc, #28]	@ (70006520 <HAL_XSPIM_Config+0x1d8>)
70006504:	681b      	ldr	r3, [r3, #0]
70006506:	4a06      	ldr	r2, [pc, #24]	@ (70006520 <HAL_XSPIM_Config+0x1d8>)
70006508:	f043 0301 	orr.w	r3, r3, #1
7000650c:	6013      	str	r3, [r2, #0]
  }

  return status;
7000650e:	f897 302d 	ldrb.w	r3, [r7, #45]	@ 0x2d
}
70006512:	4618      	mov	r0, r3
70006514:	3730      	adds	r7, #48	@ 0x30
70006516:	46bd      	mov	sp, r7
70006518:	bd80      	pop	{r7, pc}
7000651a:	bf00      	nop
7000651c:	52005000 	.word	0x52005000
70006520:	5200a000 	.word	0x5200a000
70006524:	5200b400 	.word	0x5200b400

70006528 <XSPI_WaitFlagStateUntilTimeout>:
  * @param  Tickstart : Tick start value
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_WaitFlagStateUntilTimeout(XSPI_HandleTypeDef *hxspi, uint32_t Flag,
                                                        FlagStatus State, uint32_t Tickstart, uint32_t Timeout)
{
70006528:	b580      	push	{r7, lr}
7000652a:	b084      	sub	sp, #16
7000652c:	af00      	add	r7, sp, #0
7000652e:	60f8      	str	r0, [r7, #12]
70006530:	60b9      	str	r1, [r7, #8]
70006532:	603b      	str	r3, [r7, #0]
70006534:	4613      	mov	r3, r2
70006536:	71fb      	strb	r3, [r7, #7]
  /* Wait until flag is in expected state */
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
70006538:	e019      	b.n	7000656e <XSPI_WaitFlagStateUntilTimeout+0x46>
  {
    /* Check for the Timeout */
    if (Timeout != HAL_MAX_DELAY)
7000653a:	69bb      	ldr	r3, [r7, #24]
7000653c:	f1b3 3fff 	cmp.w	r3, #4294967295	@ 0xffffffff
70006540:	d015      	beq.n	7000656e <XSPI_WaitFlagStateUntilTimeout+0x46>
    {
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
70006542:	f7fb f8ff 	bl	70001744 <HAL_GetTick>
70006546:	4602      	mov	r2, r0
70006548:	683b      	ldr	r3, [r7, #0]
7000654a:	1ad3      	subs	r3, r2, r3
7000654c:	69ba      	ldr	r2, [r7, #24]
7000654e:	429a      	cmp	r2, r3
70006550:	d302      	bcc.n	70006558 <XSPI_WaitFlagStateUntilTimeout+0x30>
70006552:	69bb      	ldr	r3, [r7, #24]
70006554:	2b00      	cmp	r3, #0
70006556:	d10a      	bne.n	7000656e <XSPI_WaitFlagStateUntilTimeout+0x46>
      {
        hxspi->State     = HAL_XSPI_STATE_READY;
70006558:	68fb      	ldr	r3, [r7, #12]
7000655a:	2202      	movs	r2, #2
7000655c:	655a      	str	r2, [r3, #84]	@ 0x54
        hxspi->ErrorCode |= HAL_XSPI_ERROR_TIMEOUT;
7000655e:	68fb      	ldr	r3, [r7, #12]
70006560:	6d9b      	ldr	r3, [r3, #88]	@ 0x58
70006562:	f043 0201 	orr.w	r2, r3, #1
70006566:	68fb      	ldr	r3, [r7, #12]
70006568:	659a      	str	r2, [r3, #88]	@ 0x58

        return HAL_TIMEOUT;
7000656a:	2303      	movs	r3, #3
7000656c:	e00e      	b.n	7000658c <XSPI_WaitFlagStateUntilTimeout+0x64>
  while ((HAL_XSPI_GET_FLAG(hxspi, Flag)) != State)
7000656e:	68fb      	ldr	r3, [r7, #12]
70006570:	681b      	ldr	r3, [r3, #0]
70006572:	6a1a      	ldr	r2, [r3, #32]
70006574:	68bb      	ldr	r3, [r7, #8]
70006576:	4013      	ands	r3, r2
70006578:	2b00      	cmp	r3, #0
7000657a:	bf14      	ite	ne
7000657c:	2301      	movne	r3, #1
7000657e:	2300      	moveq	r3, #0
70006580:	b2db      	uxtb	r3, r3
70006582:	461a      	mov	r2, r3
70006584:	79fb      	ldrb	r3, [r7, #7]
70006586:	429a      	cmp	r2, r3
70006588:	d1d7      	bne.n	7000653a <XSPI_WaitFlagStateUntilTimeout+0x12>
      }
    }
  }
  return HAL_OK;
7000658a:	2300      	movs	r3, #0
}
7000658c:	4618      	mov	r0, r3
7000658e:	3710      	adds	r7, #16
70006590:	46bd      	mov	sp, r7
70006592:	bd80      	pop	{r7, pc}

70006594 <XSPI_ConfigCmd>:
  * @param  hxspi : XSPI handle
  * @param  pCmd   : structure that contains the command configuration information
  * @retval HAL status
  */
static HAL_StatusTypeDef XSPI_ConfigCmd(XSPI_HandleTypeDef *hxspi, const XSPI_RegularCmdTypeDef *pCmd)
{
70006594:	b480      	push	{r7}
70006596:	b089      	sub	sp, #36	@ 0x24
70006598:	af00      	add	r7, sp, #0
7000659a:	6078      	str	r0, [r7, #4]
7000659c:	6039      	str	r1, [r7, #0]
  HAL_StatusTypeDef status = HAL_OK;
7000659e:	2300      	movs	r3, #0
700065a0:	77fb      	strb	r3, [r7, #31]
  __IO uint32_t *tcr_reg;
  __IO uint32_t *ir_reg;
  __IO uint32_t *abr_reg;

  /* Re-initialize the value of the functional mode */
  MODIFY_REG(hxspi->Instance->CR, XSPI_CR_FMODE, 0U);
700065a2:	687b      	ldr	r3, [r7, #4]
700065a4:	681b      	ldr	r3, [r3, #0]
700065a6:	681a      	ldr	r2, [r3, #0]
700065a8:	687b      	ldr	r3, [r7, #4]
700065aa:	681b      	ldr	r3, [r3, #0]
700065ac:	f022 5240 	bic.w	r2, r2, #805306368	@ 0x30000000
700065b0:	601a      	str	r2, [r3, #0]

  if (hxspi->Init.MemoryMode == HAL_XSPI_SINGLE_MEM)
700065b2:	687b      	ldr	r3, [r7, #4]
700065b4:	689b      	ldr	r3, [r3, #8]
700065b6:	2b00      	cmp	r3, #0
700065b8:	d10a      	bne.n	700065d0 <XSPI_ConfigCmd+0x3c>
  {
    assert_param(IS_XSPI_IO_SELECT(pCmd->IOSelect));
    MODIFY_REG(hxspi->Instance->CR, XSPI_CR_MSEL, pCmd->IOSelect);
700065ba:	687b      	ldr	r3, [r7, #4]
700065bc:	681b      	ldr	r3, [r3, #0]
700065be:	681b      	ldr	r3, [r3, #0]
700065c0:	f023 4140 	bic.w	r1, r3, #3221225472	@ 0xc0000000
700065c4:	683b      	ldr	r3, [r7, #0]
700065c6:	685a      	ldr	r2, [r3, #4]
700065c8:	687b      	ldr	r3, [r7, #4]
700065ca:	681b      	ldr	r3, [r3, #0]
700065cc:	430a      	orrs	r2, r1
700065ce:	601a      	str	r2, [r3, #0]
  }

  if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRITE_CFG)
700065d0:	683b      	ldr	r3, [r7, #0]
700065d2:	681b      	ldr	r3, [r3, #0]
700065d4:	2b02      	cmp	r3, #2
700065d6:	d114      	bne.n	70006602 <XSPI_ConfigCmd+0x6e>
  {
    ccr_reg = &(hxspi->Instance->WCCR);
700065d8:	687b      	ldr	r3, [r7, #4]
700065da:	681b      	ldr	r3, [r3, #0]
700065dc:	f503 73c0 	add.w	r3, r3, #384	@ 0x180
700065e0:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WTCR);
700065e2:	687b      	ldr	r3, [r7, #4]
700065e4:	681b      	ldr	r3, [r3, #0]
700065e6:	f503 73c4 	add.w	r3, r3, #392	@ 0x188
700065ea:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WIR);
700065ec:	687b      	ldr	r3, [r7, #4]
700065ee:	681b      	ldr	r3, [r3, #0]
700065f0:	f503 73c8 	add.w	r3, r3, #400	@ 0x190
700065f4:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WABR);
700065f6:	687b      	ldr	r3, [r7, #4]
700065f8:	681b      	ldr	r3, [r3, #0]
700065fa:	f503 73d0 	add.w	r3, r3, #416	@ 0x1a0
700065fe:	60fb      	str	r3, [r7, #12]
70006600:	e02c      	b.n	7000665c <XSPI_ConfigCmd+0xc8>
  }
  else if (pCmd->OperationType == HAL_XSPI_OPTYPE_WRAP_CFG)
70006602:	683b      	ldr	r3, [r7, #0]
70006604:	681b      	ldr	r3, [r3, #0]
70006606:	2b03      	cmp	r3, #3
70006608:	d114      	bne.n	70006634 <XSPI_ConfigCmd+0xa0>
  {
    ccr_reg = &(hxspi->Instance->WPCCR);
7000660a:	687b      	ldr	r3, [r7, #4]
7000660c:	681b      	ldr	r3, [r3, #0]
7000660e:	f503 73a0 	add.w	r3, r3, #320	@ 0x140
70006612:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->WPTCR);
70006614:	687b      	ldr	r3, [r7, #4]
70006616:	681b      	ldr	r3, [r3, #0]
70006618:	f503 73a4 	add.w	r3, r3, #328	@ 0x148
7000661c:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->WPIR);
7000661e:	687b      	ldr	r3, [r7, #4]
70006620:	681b      	ldr	r3, [r3, #0]
70006622:	f503 73a8 	add.w	r3, r3, #336	@ 0x150
70006626:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->WPABR);
70006628:	687b      	ldr	r3, [r7, #4]
7000662a:	681b      	ldr	r3, [r3, #0]
7000662c:	f503 73b0 	add.w	r3, r3, #352	@ 0x160
70006630:	60fb      	str	r3, [r7, #12]
70006632:	e013      	b.n	7000665c <XSPI_ConfigCmd+0xc8>
  }
  else
  {
    ccr_reg = &(hxspi->Instance->CCR);
70006634:	687b      	ldr	r3, [r7, #4]
70006636:	681b      	ldr	r3, [r3, #0]
70006638:	f503 7380 	add.w	r3, r3, #256	@ 0x100
7000663c:	61bb      	str	r3, [r7, #24]
    tcr_reg = &(hxspi->Instance->TCR);
7000663e:	687b      	ldr	r3, [r7, #4]
70006640:	681b      	ldr	r3, [r3, #0]
70006642:	f503 7384 	add.w	r3, r3, #264	@ 0x108
70006646:	617b      	str	r3, [r7, #20]
    ir_reg  = &(hxspi->Instance->IR);
70006648:	687b      	ldr	r3, [r7, #4]
7000664a:	681b      	ldr	r3, [r3, #0]
7000664c:	f503 7388 	add.w	r3, r3, #272	@ 0x110
70006650:	613b      	str	r3, [r7, #16]
    abr_reg = &(hxspi->Instance->ABR);
70006652:	687b      	ldr	r3, [r7, #4]
70006654:	681b      	ldr	r3, [r3, #0]
70006656:	f503 7390 	add.w	r3, r3, #288	@ 0x120
7000665a:	60fb      	str	r3, [r7, #12]
  }

  /* Configure the CCR register with DQS mode */
  *ccr_reg = pCmd->DQSMode;
7000665c:	683b      	ldr	r3, [r7, #0]
7000665e:	6c9a      	ldr	r2, [r3, #72]	@ 0x48
70006660:	69bb      	ldr	r3, [r7, #24]
70006662:	601a      	str	r2, [r3, #0]

  if (pCmd->AlternateBytesMode != HAL_XSPI_ALT_BYTES_NONE)
70006664:	683b      	ldr	r3, [r7, #0]
70006666:	6adb      	ldr	r3, [r3, #44]	@ 0x2c
70006668:	2b00      	cmp	r3, #0
7000666a:	d012      	beq.n	70006692 <XSPI_ConfigCmd+0xfe>
  {
    /* Configure the ABR register with alternate bytes value */
    *abr_reg = pCmd->AlternateBytes;
7000666c:	683b      	ldr	r3, [r7, #0]
7000666e:	6a9a      	ldr	r2, [r3, #40]	@ 0x28
70006670:	68fb      	ldr	r3, [r7, #12]
70006672:	601a      	str	r2, [r3, #0]

    /* Configure the CCR register with alternate bytes communication parameters */
    MODIFY_REG((*ccr_reg), (XSPI_CCR_ABMODE | XSPI_CCR_ABDTR | XSPI_CCR_ABSIZE),
70006674:	69bb      	ldr	r3, [r7, #24]
70006676:	681b      	ldr	r3, [r3, #0]
70006678:	f423 127c 	bic.w	r2, r3, #4128768	@ 0x3f0000
7000667c:	683b      	ldr	r3, [r7, #0]
7000667e:	6ad9      	ldr	r1, [r3, #44]	@ 0x2c
70006680:	683b      	ldr	r3, [r7, #0]
70006682:	6b5b      	ldr	r3, [r3, #52]	@ 0x34
70006684:	4319      	orrs	r1, r3
70006686:	683b      	ldr	r3, [r7, #0]
70006688:	6b1b      	ldr	r3, [r3, #48]	@ 0x30
7000668a:	430b      	orrs	r3, r1
7000668c:	431a      	orrs	r2, r3
7000668e:	69bb      	ldr	r3, [r7, #24]
70006690:	601a      	str	r2, [r3, #0]
               (pCmd->AlternateBytesMode | pCmd->AlternateBytesDTRMode | pCmd->AlternateBytesWidth));
  }

  /* Configure the TCR register with the number of dummy cycles */
  MODIFY_REG((*tcr_reg), XSPI_TCR_DCYC, pCmd->DummyCycles);
70006692:	697b      	ldr	r3, [r7, #20]
70006694:	681b      	ldr	r3, [r3, #0]
70006696:	f023 021f 	bic.w	r2, r3, #31
7000669a:	683b      	ldr	r3, [r7, #0]
7000669c:	6c5b      	ldr	r3, [r3, #68]	@ 0x44
7000669e:	431a      	orrs	r2, r3
700066a0:	697b      	ldr	r3, [r7, #20]
700066a2:	601a      	str	r2, [r3, #0]

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
700066a4:	683b      	ldr	r3, [r7, #0]
700066a6:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
700066a8:	2b00      	cmp	r3, #0
700066aa:	d009      	beq.n	700066c0 <XSPI_ConfigCmd+0x12c>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
700066ac:	683b      	ldr	r3, [r7, #0]
700066ae:	681b      	ldr	r3, [r3, #0]
700066b0:	2b00      	cmp	r3, #0
700066b2:	d105      	bne.n	700066c0 <XSPI_ConfigCmd+0x12c>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
700066b4:	683b      	ldr	r3, [r7, #0]
700066b6:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
700066b8:	687b      	ldr	r3, [r7, #4]
700066ba:	681b      	ldr	r3, [r3, #0]
700066bc:	3a01      	subs	r2, #1
700066be:	641a      	str	r2, [r3, #64]	@ 0x40
    }
  }

  /* Configure SSHIFT register to handle SDR/DTR data transfer */
  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
700066c0:	683b      	ldr	r3, [r7, #0]
700066c2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
700066c4:	2b00      	cmp	r3, #0
700066c6:	d01e      	beq.n	70006706 <XSPI_ConfigCmd+0x172>
  {
    if (pCmd->DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
700066c8:	683b      	ldr	r3, [r7, #0]
700066ca:	6c1b      	ldr	r3, [r3, #64]	@ 0x40
700066cc:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
700066d0:	d10a      	bne.n	700066e8 <XSPI_ConfigCmd+0x154>
    {
      /* Deactivate sample shifting when receiving data in DTR mode (DDTR=1) */
      CLEAR_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
700066d2:	687b      	ldr	r3, [r7, #4]
700066d4:	681b      	ldr	r3, [r3, #0]
700066d6:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
700066da:	687b      	ldr	r3, [r7, #4]
700066dc:	681b      	ldr	r3, [r3, #0]
700066de:	f022 4280 	bic.w	r2, r2, #1073741824	@ 0x40000000
700066e2:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
700066e6:	e00e      	b.n	70006706 <XSPI_ConfigCmd+0x172>
    }
    else if (hxspi->Init.SampleShifting == HAL_XSPI_SAMPLE_SHIFT_HALFCYCLE)
700066e8:	687b      	ldr	r3, [r7, #4]
700066ea:	6a9b      	ldr	r3, [r3, #40]	@ 0x28
700066ec:	f1b3 4f80 	cmp.w	r3, #1073741824	@ 0x40000000
700066f0:	d109      	bne.n	70006706 <XSPI_ConfigCmd+0x172>
    {
      /* Configure sample shifting */
      SET_BIT(hxspi->Instance->TCR, XSPI_TCR_SSHIFT);
700066f2:	687b      	ldr	r3, [r7, #4]
700066f4:	681b      	ldr	r3, [r3, #0]
700066f6:	f8d3 2108 	ldr.w	r2, [r3, #264]	@ 0x108
700066fa:	687b      	ldr	r3, [r7, #4]
700066fc:	681b      	ldr	r3, [r3, #0]
700066fe:	f042 4280 	orr.w	r2, r2, #1073741824	@ 0x40000000
70006702:	f8c3 2108 	str.w	r2, [r3, #264]	@ 0x108
    {
      /* Do nothing */
    }
  }

  if (pCmd->InstructionMode != HAL_XSPI_INSTRUCTION_NONE)
70006706:	683b      	ldr	r3, [r7, #0]
70006708:	68db      	ldr	r3, [r3, #12]
7000670a:	2b00      	cmp	r3, #0
7000670c:	d076      	beq.n	700067fc <XSPI_ConfigCmd+0x268>
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
7000670e:	683b      	ldr	r3, [r7, #0]
70006710:	69db      	ldr	r3, [r3, #28]
70006712:	2b00      	cmp	r3, #0
70006714:	d044      	beq.n	700067a0 <XSPI_ConfigCmd+0x20c>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
70006716:	683b      	ldr	r3, [r7, #0]
70006718:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
7000671a:	2b00      	cmp	r3, #0
7000671c:	d01e      	beq.n	7000675c <XSPI_ConfigCmd+0x1c8>
      {
        /* ---- Command with instruction, address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
7000671e:	69bb      	ldr	r3, [r7, #24]
70006720:	681a      	ldr	r2, [r3, #0]
70006722:	4b5d      	ldr	r3, [pc, #372]	@ (70006898 <XSPI_ConfigCmd+0x304>)
70006724:	4013      	ands	r3, r2
70006726:	683a      	ldr	r2, [r7, #0]
70006728:	68d1      	ldr	r1, [r2, #12]
7000672a:	683a      	ldr	r2, [r7, #0]
7000672c:	6952      	ldr	r2, [r2, #20]
7000672e:	4311      	orrs	r1, r2
70006730:	683a      	ldr	r2, [r7, #0]
70006732:	6912      	ldr	r2, [r2, #16]
70006734:	4311      	orrs	r1, r2
70006736:	683a      	ldr	r2, [r7, #0]
70006738:	69d2      	ldr	r2, [r2, #28]
7000673a:	4311      	orrs	r1, r2
7000673c:	683a      	ldr	r2, [r7, #0]
7000673e:	6a52      	ldr	r2, [r2, #36]	@ 0x24
70006740:	4311      	orrs	r1, r2
70006742:	683a      	ldr	r2, [r7, #0]
70006744:	6a12      	ldr	r2, [r2, #32]
70006746:	4311      	orrs	r1, r2
70006748:	683a      	ldr	r2, [r7, #0]
7000674a:	6b92      	ldr	r2, [r2, #56]	@ 0x38
7000674c:	4311      	orrs	r1, r2
7000674e:	683a      	ldr	r2, [r7, #0]
70006750:	6c12      	ldr	r2, [r2, #64]	@ 0x40
70006752:	430a      	orrs	r2, r1
70006754:	431a      	orrs	r2, r3
70006756:	69bb      	ldr	r3, [r7, #24]
70006758:	601a      	str	r2, [r3, #0]
7000675a:	e017      	b.n	7000678c <XSPI_ConfigCmd+0x1f8>
      else
      {
        /* ---- Command with instruction and address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE  | XSPI_CCR_IDTR  | XSPI_CCR_ISIZE  |
7000675c:	69bb      	ldr	r3, [r7, #24]
7000675e:	681a      	ldr	r2, [r3, #0]
70006760:	4b4e      	ldr	r3, [pc, #312]	@ (7000689c <XSPI_ConfigCmd+0x308>)
70006762:	4013      	ands	r3, r2
70006764:	683a      	ldr	r2, [r7, #0]
70006766:	68d1      	ldr	r1, [r2, #12]
70006768:	683a      	ldr	r2, [r7, #0]
7000676a:	6952      	ldr	r2, [r2, #20]
7000676c:	4311      	orrs	r1, r2
7000676e:	683a      	ldr	r2, [r7, #0]
70006770:	6912      	ldr	r2, [r2, #16]
70006772:	4311      	orrs	r1, r2
70006774:	683a      	ldr	r2, [r7, #0]
70006776:	69d2      	ldr	r2, [r2, #28]
70006778:	4311      	orrs	r1, r2
7000677a:	683a      	ldr	r2, [r7, #0]
7000677c:	6a52      	ldr	r2, [r2, #36]	@ 0x24
7000677e:	4311      	orrs	r1, r2
70006780:	683a      	ldr	r2, [r7, #0]
70006782:	6a12      	ldr	r2, [r2, #32]
70006784:	430a      	orrs	r2, r1
70006786:	431a      	orrs	r2, r3
70006788:	69bb      	ldr	r3, [r7, #24]
7000678a:	601a      	str	r2, [r3, #0]
                                XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth |
                    pCmd->AddressMode     | pCmd->AddressDTRMode     | pCmd->AddressWidth));
      }
      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
7000678c:	683b      	ldr	r3, [r7, #0]
7000678e:	689a      	ldr	r2, [r3, #8]
70006790:	693b      	ldr	r3, [r7, #16]
70006792:	601a      	str	r2, [r3, #0]

      /* Configure the AR register with the address value */
      hxspi->Instance->AR = pCmd->Address;
70006794:	687b      	ldr	r3, [r7, #4]
70006796:	681b      	ldr	r3, [r3, #0]
70006798:	683a      	ldr	r2, [r7, #0]
7000679a:	6992      	ldr	r2, [r2, #24]
7000679c:	649a      	str	r2, [r3, #72]	@ 0x48
7000679e:	e065      	b.n	7000686c <XSPI_ConfigCmd+0x2d8>
        assert_param(IS_XSPI_PROG_ADDR(hxspi->Instance->AR, pCmd->Address));
      }
    }
    else
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
700067a0:	683b      	ldr	r3, [r7, #0]
700067a2:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
700067a4:	2b00      	cmp	r3, #0
700067a6:	d015      	beq.n	700067d4 <XSPI_ConfigCmd+0x240>
      {
        /* ---- Command with instruction and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE |
700067a8:	69bb      	ldr	r3, [r7, #24]
700067aa:	681a      	ldr	r2, [r3, #0]
700067ac:	4b3c      	ldr	r3, [pc, #240]	@ (700068a0 <XSPI_ConfigCmd+0x30c>)
700067ae:	4013      	ands	r3, r2
700067b0:	683a      	ldr	r2, [r7, #0]
700067b2:	68d1      	ldr	r1, [r2, #12]
700067b4:	683a      	ldr	r2, [r7, #0]
700067b6:	6952      	ldr	r2, [r2, #20]
700067b8:	4311      	orrs	r1, r2
700067ba:	683a      	ldr	r2, [r7, #0]
700067bc:	6912      	ldr	r2, [r2, #16]
700067be:	4311      	orrs	r1, r2
700067c0:	683a      	ldr	r2, [r7, #0]
700067c2:	6b92      	ldr	r2, [r2, #56]	@ 0x38
700067c4:	4311      	orrs	r1, r2
700067c6:	683a      	ldr	r2, [r7, #0]
700067c8:	6c12      	ldr	r2, [r2, #64]	@ 0x40
700067ca:	430a      	orrs	r2, r1
700067cc:	431a      	orrs	r2, r3
700067ce:	69bb      	ldr	r3, [r7, #24]
700067d0:	601a      	str	r2, [r3, #0]
700067d2:	e00e      	b.n	700067f2 <XSPI_ConfigCmd+0x25e>
      else
      {
        /* ---- Command with only instruction ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_IMODE | XSPI_CCR_IDTR | XSPI_CCR_ISIZE),
700067d4:	69bb      	ldr	r3, [r7, #24]
700067d6:	681b      	ldr	r3, [r3, #0]
700067d8:	f023 023f 	bic.w	r2, r3, #63	@ 0x3f
700067dc:	683b      	ldr	r3, [r7, #0]
700067de:	68d9      	ldr	r1, [r3, #12]
700067e0:	683b      	ldr	r3, [r7, #0]
700067e2:	695b      	ldr	r3, [r3, #20]
700067e4:	4319      	orrs	r1, r3
700067e6:	683b      	ldr	r3, [r7, #0]
700067e8:	691b      	ldr	r3, [r3, #16]
700067ea:	430b      	orrs	r3, r1
700067ec:	431a      	orrs	r2, r3
700067ee:	69bb      	ldr	r3, [r7, #24]
700067f0:	601a      	str	r2, [r3, #0]
                   (pCmd->InstructionMode | pCmd->InstructionDTRMode | pCmd->InstructionWidth));
      }

      /* Configure the IR register with the instruction value */
      *ir_reg = pCmd->Instruction;
700067f2:	683b      	ldr	r3, [r7, #0]
700067f4:	689a      	ldr	r2, [r3, #8]
700067f6:	693b      	ldr	r3, [r7, #16]
700067f8:	601a      	str	r2, [r3, #0]
700067fa:	e037      	b.n	7000686c <XSPI_ConfigCmd+0x2d8>

    }
  }
  else
  {
    if (pCmd->AddressMode != HAL_XSPI_ADDRESS_NONE)
700067fc:	683b      	ldr	r3, [r7, #0]
700067fe:	69db      	ldr	r3, [r3, #28]
70006800:	2b00      	cmp	r3, #0
70006802:	d02e      	beq.n	70006862 <XSPI_ConfigCmd+0x2ce>
    {
      if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
70006804:	683b      	ldr	r3, [r7, #0]
70006806:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70006808:	2b00      	cmp	r3, #0
7000680a:	d015      	beq.n	70006838 <XSPI_ConfigCmd+0x2a4>
      {
        /* ---- Command with address and data ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE |
7000680c:	69bb      	ldr	r3, [r7, #24]
7000680e:	681a      	ldr	r2, [r3, #0]
70006810:	4b24      	ldr	r3, [pc, #144]	@ (700068a4 <XSPI_ConfigCmd+0x310>)
70006812:	4013      	ands	r3, r2
70006814:	683a      	ldr	r2, [r7, #0]
70006816:	69d1      	ldr	r1, [r2, #28]
70006818:	683a      	ldr	r2, [r7, #0]
7000681a:	6a52      	ldr	r2, [r2, #36]	@ 0x24
7000681c:	4311      	orrs	r1, r2
7000681e:	683a      	ldr	r2, [r7, #0]
70006820:	6a12      	ldr	r2, [r2, #32]
70006822:	4311      	orrs	r1, r2
70006824:	683a      	ldr	r2, [r7, #0]
70006826:	6b92      	ldr	r2, [r2, #56]	@ 0x38
70006828:	4311      	orrs	r1, r2
7000682a:	683a      	ldr	r2, [r7, #0]
7000682c:	6c12      	ldr	r2, [r2, #64]	@ 0x40
7000682e:	430a      	orrs	r2, r1
70006830:	431a      	orrs	r2, r3
70006832:	69bb      	ldr	r3, [r7, #24]
70006834:	601a      	str	r2, [r3, #0]
70006836:	e00e      	b.n	70006856 <XSPI_ConfigCmd+0x2c2>
      else
      {
        /* ---- Command with only address ---- */

        /* Configure the CCR register with all communication parameters */
        MODIFY_REG((*ccr_reg), (XSPI_CCR_ADMODE | XSPI_CCR_ADDTR | XSPI_CCR_ADSIZE),
70006838:	69bb      	ldr	r3, [r7, #24]
7000683a:	681b      	ldr	r3, [r3, #0]
7000683c:	f423 527c 	bic.w	r2, r3, #16128	@ 0x3f00
70006840:	683b      	ldr	r3, [r7, #0]
70006842:	69d9      	ldr	r1, [r3, #28]
70006844:	683b      	ldr	r3, [r7, #0]
70006846:	6a5b      	ldr	r3, [r3, #36]	@ 0x24
70006848:	4319      	orrs	r1, r3
7000684a:	683b      	ldr	r3, [r7, #0]
7000684c:	6a1b      	ldr	r3, [r3, #32]
7000684e:	430b      	orrs	r3, r1
70006850:	431a      	orrs	r2, r3
70006852:	69bb      	ldr	r3, [r7, #24]
70006854:	601a      	str	r2, [r3, #0]
                   (pCmd->AddressMode | pCmd->AddressDTRMode | pCmd->AddressWidth));
      }

      /* Configure the AR register with the instruction value */
      hxspi->Instance->AR = pCmd->Address;
70006856:	687b      	ldr	r3, [r7, #4]
70006858:	681b      	ldr	r3, [r3, #0]
7000685a:	683a      	ldr	r2, [r7, #0]
7000685c:	6992      	ldr	r2, [r2, #24]
7000685e:	649a      	str	r2, [r3, #72]	@ 0x48
70006860:	e004      	b.n	7000686c <XSPI_ConfigCmd+0x2d8>
      }
    }
    else
    {
      /* ---- Invalid command configuration (no instruction, no address) ---- */
      status = HAL_ERROR;
70006862:	2301      	movs	r3, #1
70006864:	77fb      	strb	r3, [r7, #31]
      hxspi->ErrorCode = HAL_XSPI_ERROR_INVALID_PARAM;
70006866:	687b      	ldr	r3, [r7, #4]
70006868:	2208      	movs	r2, #8
7000686a:	659a      	str	r2, [r3, #88]	@ 0x58
    }
  }

  if (pCmd->DataMode != HAL_XSPI_DATA_NONE)
7000686c:	683b      	ldr	r3, [r7, #0]
7000686e:	6b9b      	ldr	r3, [r3, #56]	@ 0x38
70006870:	2b00      	cmp	r3, #0
70006872:	d009      	beq.n	70006888 <XSPI_ConfigCmd+0x2f4>
  {
    if (pCmd->OperationType == HAL_XSPI_OPTYPE_COMMON_CFG)
70006874:	683b      	ldr	r3, [r7, #0]
70006876:	681b      	ldr	r3, [r3, #0]
70006878:	2b00      	cmp	r3, #0
7000687a:	d105      	bne.n	70006888 <XSPI_ConfigCmd+0x2f4>
    {
      /* Configure the DLR register with the number of data */
      hxspi->Instance->DLR = (pCmd->DataLength - 1U);
7000687c:	683b      	ldr	r3, [r7, #0]
7000687e:	6bda      	ldr	r2, [r3, #60]	@ 0x3c
70006880:	687b      	ldr	r3, [r7, #4]
70006882:	681b      	ldr	r3, [r3, #0]
70006884:	3a01      	subs	r2, #1
70006886:	641a      	str	r2, [r3, #64]	@ 0x40
      /* Verify if programmed data fit with requirement of Reference Manual 28.5 chapter */
      assert_param(IS_XSPI_PROG_DATA(hxspi->Instance->DLR, (pCmd->DataLength - 1U)));
    }
  }

  return status;
70006888:	7ffb      	ldrb	r3, [r7, #31]
}
7000688a:	4618      	mov	r0, r3
7000688c:	3724      	adds	r7, #36	@ 0x24
7000688e:	46bd      	mov	sp, r7
70006890:	f85d 7b04 	ldr.w	r7, [sp], #4
70006894:	4770      	bx	lr
70006896:	bf00      	nop
70006898:	f0ffc0c0 	.word	0xf0ffc0c0
7000689c:	ffffc0c0 	.word	0xffffc0c0
700068a0:	f0ffffc0 	.word	0xf0ffffc0
700068a4:	f0ffc0ff 	.word	0xf0ffc0ff

700068a8 <XSPIM_GetConfig>:
  * @param  instance_nb : number of the instance
  * @param  pCfg         : configuration of the IO Manager for the instance
  * @retval HAL status
  */
static void XSPIM_GetConfig(uint8_t instance_nb, XSPIM_CfgTypeDef *pCfg)
{
700068a8:	b480      	push	{r7}
700068aa:	b085      	sub	sp, #20
700068ac:	af00      	add	r7, sp, #0
700068ae:	4603      	mov	r3, r0
700068b0:	6039      	str	r1, [r7, #0]
700068b2:	71fb      	strb	r3, [r7, #7]
  uint32_t mux;
  uint32_t mode;

  if (instance_nb == 1U)
700068b4:	79fb      	ldrb	r3, [r7, #7]
700068b6:	2b01      	cmp	r3, #1
700068b8:	d124      	bne.n	70006904 <XSPIM_GetConfig+0x5c>
  {
    if ((XSPIM->CR & XSPIM_CR_MODE) == 0U)
700068ba:	4b2c      	ldr	r3, [pc, #176]	@ (7000696c <XSPIM_GetConfig+0xc4>)
700068bc:	681b      	ldr	r3, [r3, #0]
700068be:	f003 0302 	and.w	r3, r3, #2
700068c2:	2b00      	cmp	r3, #0
700068c4:	d103      	bne.n	700068ce <XSPIM_GetConfig+0x26>
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
700068c6:	683b      	ldr	r3, [r7, #0]
700068c8:	2200      	movs	r2, #0
700068ca:	605a      	str	r2, [r3, #4]
700068cc:	e002      	b.n	700068d4 <XSPIM_GetConfig+0x2c>
    }
    else
    {
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
700068ce:	683b      	ldr	r3, [r7, #0]
700068d0:	2201      	movs	r2, #1
700068d2:	605a      	str	r2, [r3, #4]
    }

    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
700068d4:	4b25      	ldr	r3, [pc, #148]	@ (7000696c <XSPIM_GetConfig+0xc4>)
700068d6:	681b      	ldr	r3, [r3, #0]
700068d8:	f003 0310 	and.w	r3, r3, #16
700068dc:	2b10      	cmp	r3, #16
700068de:	d003      	beq.n	700068e8 <XSPIM_GetConfig+0x40>
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
700068e0:	683b      	ldr	r3, [r7, #0]
700068e2:	2200      	movs	r2, #0
700068e4:	601a      	str	r2, [r3, #0]
    else
    {
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
    }
  }
}
700068e6:	e03a      	b.n	7000695e <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O1) == XSPIM_CR_CSSEL_OVR_O1)
700068e8:	4b20      	ldr	r3, [pc, #128]	@ (7000696c <XSPIM_GetConfig+0xc4>)
700068ea:	681b      	ldr	r3, [r3, #0]
700068ec:	f003 0320 	and.w	r3, r3, #32
700068f0:	2b20      	cmp	r3, #32
700068f2:	d103      	bne.n	700068fc <XSPIM_GetConfig+0x54>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
700068f4:	683b      	ldr	r3, [r7, #0]
700068f6:	2270      	movs	r2, #112	@ 0x70
700068f8:	601a      	str	r2, [r3, #0]
}
700068fa:	e030      	b.n	7000695e <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
700068fc:	683b      	ldr	r3, [r7, #0]
700068fe:	2210      	movs	r2, #16
70006900:	601a      	str	r2, [r3, #0]
}
70006902:	e02c      	b.n	7000695e <XSPIM_GetConfig+0xb6>
    mux = (XSPIM->CR & XSPIM_CR_MUXEN);
70006904:	4b19      	ldr	r3, [pc, #100]	@ (7000696c <XSPIM_GetConfig+0xc4>)
70006906:	681b      	ldr	r3, [r3, #0]
70006908:	f003 0301 	and.w	r3, r3, #1
7000690c:	60fb      	str	r3, [r7, #12]
    mode = ((XSPIM->CR & XSPIM_CR_MODE) >> XSPIM_CR_MODE_Pos);
7000690e:	4b17      	ldr	r3, [pc, #92]	@ (7000696c <XSPIM_GetConfig+0xc4>)
70006910:	681b      	ldr	r3, [r3, #0]
70006912:	085b      	lsrs	r3, r3, #1
70006914:	f003 0301 	and.w	r3, r3, #1
70006918:	60bb      	str	r3, [r7, #8]
    if (mux != mode)
7000691a:	68fa      	ldr	r2, [r7, #12]
7000691c:	68bb      	ldr	r3, [r7, #8]
7000691e:	429a      	cmp	r2, r3
70006920:	d003      	beq.n	7000692a <XSPIM_GetConfig+0x82>
      pCfg->IOPort = HAL_XSPIM_IOPORT_1;
70006922:	683b      	ldr	r3, [r7, #0]
70006924:	2200      	movs	r2, #0
70006926:	605a      	str	r2, [r3, #4]
70006928:	e002      	b.n	70006930 <XSPIM_GetConfig+0x88>
      pCfg->IOPort = HAL_XSPIM_IOPORT_2;
7000692a:	683b      	ldr	r3, [r7, #0]
7000692c:	2201      	movs	r2, #1
7000692e:	605a      	str	r2, [r3, #4]
    if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_EN) != XSPIM_CR_CSSEL_OVR_EN)
70006930:	4b0e      	ldr	r3, [pc, #56]	@ (7000696c <XSPIM_GetConfig+0xc4>)
70006932:	681b      	ldr	r3, [r3, #0]
70006934:	f003 0310 	and.w	r3, r3, #16
70006938:	2b10      	cmp	r3, #16
7000693a:	d003      	beq.n	70006944 <XSPIM_GetConfig+0x9c>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_DISABLED;
7000693c:	683b      	ldr	r3, [r7, #0]
7000693e:	2200      	movs	r2, #0
70006940:	601a      	str	r2, [r3, #0]
}
70006942:	e00c      	b.n	7000695e <XSPIM_GetConfig+0xb6>
    else if ((XSPIM->CR & XSPIM_CR_CSSEL_OVR_O2) == XSPIM_CR_CSSEL_OVR_O2)
70006944:	4b09      	ldr	r3, [pc, #36]	@ (7000696c <XSPIM_GetConfig+0xc4>)
70006946:	681b      	ldr	r3, [r3, #0]
70006948:	f003 0340 	and.w	r3, r3, #64	@ 0x40
7000694c:	2b40      	cmp	r3, #64	@ 0x40
7000694e:	d103      	bne.n	70006958 <XSPIM_GetConfig+0xb0>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS2;
70006950:	683b      	ldr	r3, [r7, #0]
70006952:	2270      	movs	r2, #112	@ 0x70
70006954:	601a      	str	r2, [r3, #0]
}
70006956:	e002      	b.n	7000695e <XSPIM_GetConfig+0xb6>
      pCfg->nCSOverride = HAL_XSPI_CSSEL_OVR_NCS1;
70006958:	683b      	ldr	r3, [r7, #0]
7000695a:	2210      	movs	r2, #16
7000695c:	601a      	str	r2, [r3, #0]
}
7000695e:	bf00      	nop
70006960:	3714      	adds	r7, #20
70006962:	46bd      	mov	sp, r7
70006964:	f85d 7b04 	ldr.w	r7, [sp], #4
70006968:	4770      	bx	lr
7000696a:	bf00      	nop
7000696c:	5200b400 	.word	0x5200b400

70006970 <EXTMEM_Init>:
  * @param MemId Memory identifier.
  * @param ClockInput Clock input value for the memory.
  * @retval EXTMEM_StatusTypeDef Status of the operation.
  */
EXTMEM_StatusTypeDef EXTMEM_Init(uint32_t MemId, uint32_t ClockInput)
{
70006970:	b580      	push	{r7, lr}
70006972:	b084      	sub	sp, #16
70006974:	af00      	add	r7, sp, #0
70006976:	6078      	str	r0, [r7, #4]
70006978:	6039      	str	r1, [r7, #0]
  EXTMEM_StatusTypeDef retr = EXTMEM_ERROR_INVALID_ID;
7000697a:	23fb      	movs	r3, #251	@ 0xfb
7000697c:	73fb      	strb	r3, [r7, #15]
  EXTMEM_FUNC_CALL();

  /* Check the memory ID */
  if (MemId < (sizeof(extmem_list_config) / sizeof(EXTMEM_DefinitionTypeDef)))
7000697e:	687b      	ldr	r3, [r7, #4]
70006980:	2b00      	cmp	r3, #0
70006982:	d12f      	bne.n	700069e4 <EXTMEM_Init+0x74>
  {
    retr = EXTMEM_OK;
70006984:	2300      	movs	r3, #0
70006986:	73fb      	strb	r3, [r7, #15]

    /* Check type of EXTMEM driver used to access memory */
    switch (extmem_list_config[MemId].MemType)
70006988:	4a19      	ldr	r2, [pc, #100]	@ (700069f0 <EXTMEM_Init+0x80>)
7000698a:	687b      	ldr	r3, [r7, #4]
7000698c:	21ac      	movs	r1, #172	@ 0xac
7000698e:	fb01 f303 	mul.w	r3, r1, r3
70006992:	4413      	add	r3, r2
70006994:	781b      	ldrb	r3, [r3, #0]
70006996:	2b00      	cmp	r3, #0
70006998:	d120      	bne.n	700069dc <EXTMEM_Init+0x6c>
    {
#if EXTMEM_DRIVER_NOR_SFDP == 1
      case EXTMEM_NOR_SFDP:
      {
        /* Initialize the memory using NOR SFDP driver */
        if (EXTMEM_DRIVER_NOR_SFDP_OK != EXTMEM_DRIVER_NOR_SFDP_Init(extmem_list_config[MemId].Handle,
7000699a:	4a15      	ldr	r2, [pc, #84]	@ (700069f0 <EXTMEM_Init+0x80>)
7000699c:	687b      	ldr	r3, [r7, #4]
7000699e:	21ac      	movs	r1, #172	@ 0xac
700069a0:	fb01 f303 	mul.w	r3, r1, r3
700069a4:	4413      	add	r3, r2
700069a6:	3304      	adds	r3, #4
700069a8:	6818      	ldr	r0, [r3, #0]
700069aa:	4a11      	ldr	r2, [pc, #68]	@ (700069f0 <EXTMEM_Init+0x80>)
700069ac:	687b      	ldr	r3, [r7, #4]
700069ae:	21ac      	movs	r1, #172	@ 0xac
700069b0:	fb01 f303 	mul.w	r3, r1, r3
700069b4:	4413      	add	r3, r2
700069b6:	3308      	adds	r3, #8
700069b8:	7819      	ldrb	r1, [r3, #0]
700069ba:	687b      	ldr	r3, [r7, #4]
700069bc:	22ac      	movs	r2, #172	@ 0xac
700069be:	fb02 f303 	mul.w	r3, r2, r3
700069c2:	3308      	adds	r3, #8
700069c4:	4a0a      	ldr	r2, [pc, #40]	@ (700069f0 <EXTMEM_Init+0x80>)
700069c6:	4413      	add	r3, r2
700069c8:	3304      	adds	r3, #4
700069ca:	683a      	ldr	r2, [r7, #0]
700069cc:	f002 fa0c 	bl	70008de8 <EXTMEM_DRIVER_NOR_SFDP_Init>
700069d0:	4603      	mov	r3, r0
700069d2:	2b00      	cmp	r3, #0
700069d4:	d005      	beq.n	700069e2 <EXTMEM_Init+0x72>
                                                                     extmem_list_config[MemId].ConfigType,
                                                                     ClockInput,
                                                                     &extmem_list_config[MemId].NorSfdpObject))
        {
          retr = EXTMEM_ERROR_DRIVER;
700069d6:	23fd      	movs	r3, #253	@ 0xfd
700069d8:	73fb      	strb	r3, [r7, #15]
        }
        break;
700069da:	e002      	b.n	700069e2 <EXTMEM_Init+0x72>
#endif /* EXTMEM_DRIVER_USER == 1 */
      /* Unknown type of EXTMEM driver */
      default:
      {
        EXTMEM_DEBUG("\terror : unknown memory type\n");
        retr = EXTMEM_ERROR_UNKNOWNMEMORY;
700069dc:	23fe      	movs	r3, #254	@ 0xfe
700069de:	73fb      	strb	r3, [r7, #15]
        break;
700069e0:	e000      	b.n	700069e4 <EXTMEM_Init+0x74>
        break;
700069e2:	bf00      	nop
      }
    }
  }
  return retr;
700069e4:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
700069e8:	4618      	mov	r0, r3
700069ea:	3710      	adds	r7, #16
700069ec:	46bd      	mov	sp, r7
700069ee:	bd80      	pop	{r7, pc}
700069f0:	24000258 	.word	0x24000258

700069f4 <SAL_XSPI_SetClock>:
  * @param ClockReal Pointer on the value of the real clock used
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_SetClock(SAL_XSPI_ObjectTypeDef *SalXspi, uint32_t ClockIn, uint32_t ClockRequested,
                                    uint32_t *ClockReal)
{
700069f4:	b480      	push	{r7}
700069f6:	b087      	sub	sp, #28
700069f8:	af00      	add	r7, sp, #0
700069fa:	60f8      	str	r0, [r7, #12]
700069fc:	60b9      	str	r1, [r7, #8]
700069fe:	607a      	str	r2, [r7, #4]
70006a00:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef retr = HAL_OK;
70006a02:	2300      	movs	r3, #0
70006a04:	75fb      	strb	r3, [r7, #23]
  uint32_t divider;

  if (ClockRequested == 0u)
70006a06:	687b      	ldr	r3, [r7, #4]
70006a08:	2b00      	cmp	r3, #0
70006a0a:	d102      	bne.n	70006a12 <SAL_XSPI_SetClock+0x1e>
  {
    retr = HAL_ERROR;
70006a0c:	2301      	movs	r3, #1
70006a0e:	75fb      	strb	r3, [r7, #23]
70006a10:	e028      	b.n	70006a64 <SAL_XSPI_SetClock+0x70>
  }
  else
  {
    divider = (ClockIn / ClockRequested);
70006a12:	68ba      	ldr	r2, [r7, #8]
70006a14:	687b      	ldr	r3, [r7, #4]
70006a16:	fbb2 f3f3 	udiv	r3, r2, r3
70006a1a:	613b      	str	r3, [r7, #16]
    if (divider >= 1u)
70006a1c:	693b      	ldr	r3, [r7, #16]
70006a1e:	2b00      	cmp	r3, #0
70006a20:	d00d      	beq.n	70006a3e <SAL_XSPI_SetClock+0x4a>
    {
      *ClockReal = ClockIn / divider;
70006a22:	68ba      	ldr	r2, [r7, #8]
70006a24:	693b      	ldr	r3, [r7, #16]
70006a26:	fbb2 f2f3 	udiv	r2, r2, r3
70006a2a:	683b      	ldr	r3, [r7, #0]
70006a2c:	601a      	str	r2, [r3, #0]
      if (*ClockReal <= ClockRequested)
70006a2e:	683b      	ldr	r3, [r7, #0]
70006a30:	681b      	ldr	r3, [r3, #0]
70006a32:	687a      	ldr	r2, [r7, #4]
70006a34:	429a      	cmp	r2, r3
70006a36:	d302      	bcc.n	70006a3e <SAL_XSPI_SetClock+0x4a>
      {
        divider--;
70006a38:	693b      	ldr	r3, [r7, #16]
70006a3a:	3b01      	subs	r3, #1
70006a3c:	613b      	str	r3, [r7, #16]
      }
    }

    /* Real clock calculation */
    *ClockReal = ClockIn / (divider + 1u);
70006a3e:	693b      	ldr	r3, [r7, #16]
70006a40:	3301      	adds	r3, #1
70006a42:	68ba      	ldr	r2, [r7, #8]
70006a44:	fbb2 f2f3 	udiv	r2, r2, r3
70006a48:	683b      	ldr	r3, [r7, #0]
70006a4a:	601a      	str	r2, [r3, #0]
    DEBUG_PARAM_END();
    DEBUG_PARAM_BEGIN();
    DEBUG_PARAM_DATA("::CLKFREQ::");
    DEBUG_PARAM_INTD(*ClockReal);
    DEBUG_PARAM_END();
    MODIFY_REG(SalXspi->hxspi->Instance->DCR2, XSPI_DCR2_PRESCALER, (uint32_t)divider << XSPI_DCR2_PRESCALER_Pos);
70006a4c:	68fb      	ldr	r3, [r7, #12]
70006a4e:	681b      	ldr	r3, [r3, #0]
70006a50:	681b      	ldr	r3, [r3, #0]
70006a52:	68db      	ldr	r3, [r3, #12]
70006a54:	f023 01ff 	bic.w	r1, r3, #255	@ 0xff
70006a58:	68fb      	ldr	r3, [r7, #12]
70006a5a:	681b      	ldr	r3, [r3, #0]
70006a5c:	681b      	ldr	r3, [r3, #0]
70006a5e:	693a      	ldr	r2, [r7, #16]
70006a60:	430a      	orrs	r2, r1
70006a62:	60da      	str	r2, [r3, #12]
  }

  return retr;
70006a64:	7dfb      	ldrb	r3, [r7, #23]
}
70006a66:	4618      	mov	r0, r3
70006a68:	371c      	adds	r7, #28
70006a6a:	46bd      	mov	sp, r7
70006a6c:	f85d 7b04 	ldr.w	r7, [sp], #4
70006a70:	4770      	bx	lr

70006a72 <SAL_XSPI_Init>:
  * @param SalXspi SAL XSPI handle
  * @param HALHandle HAl XSPI handle used for memory access
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_Init(SAL_XSPI_ObjectTypeDef *SalXspi, void *HALHandle)
{
70006a72:	b580      	push	{r7, lr}
70006a74:	b096      	sub	sp, #88	@ 0x58
70006a76:	af00      	add	r7, sp, #0
70006a78:	6078      	str	r0, [r7, #4]
70006a7a:	6039      	str	r1, [r7, #0]
  XSPI_RegularCmdTypeDef s_commandbase =
70006a7c:	f107 030c 	add.w	r3, r7, #12
70006a80:	224c      	movs	r2, #76	@ 0x4c
70006a82:	2100      	movs	r1, #0
70006a84:	4618      	mov	r0, r3
70006a86:	f002 fb7a 	bl	7000917e <memset>
70006a8a:	235a      	movs	r3, #90	@ 0x5a
70006a8c:	617b      	str	r3, [r7, #20]
70006a8e:	2301      	movs	r3, #1
70006a90:	61bb      	str	r3, [r7, #24]
70006a92:	f44f 7380 	mov.w	r3, #256	@ 0x100
70006a96:	62bb      	str	r3, [r7, #40]	@ 0x28
70006a98:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
70006a9c:	62fb      	str	r3, [r7, #44]	@ 0x2c
70006a9e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
70006aa2:	647b      	str	r3, [r7, #68]	@ 0x44
70006aa4:	2308      	movs	r3, #8
70006aa6:	653b      	str	r3, [r7, #80]	@ 0x50
#if defined(XSPI_CCR_SIOO)
    .SIOOMode = HAL_XSPI_SIOO_INST_EVERY_CMD,
#endif /* XSPI_CCR_SIOO */
  };

  SalXspi->hxspi = (XSPI_HandleTypeDef *)HALHandle;
70006aa8:	687b      	ldr	r3, [r7, #4]
70006aaa:	683a      	ldr	r2, [r7, #0]
70006aac:	601a      	str	r2, [r3, #0]
  SalXspi->Commandbase = s_commandbase;
70006aae:	687b      	ldr	r3, [r7, #4]
70006ab0:	3304      	adds	r3, #4
70006ab2:	f107 010c 	add.w	r1, r7, #12
70006ab6:	224c      	movs	r2, #76	@ 0x4c
70006ab8:	4618      	mov	r0, r3
70006aba:	f002 fbdc 	bl	70009276 <memcpy>
  SalXspi->CommandExtension = 0;
70006abe:	687b      	ldr	r3, [r7, #4]
70006ac0:	2200      	movs	r2, #0
70006ac2:	f883 2050 	strb.w	r2, [r3, #80]	@ 0x50
  SalXspi->PhyLink = PHY_LINK_1S1S1S;
70006ac6:	687b      	ldr	r3, [r7, #4]
70006ac8:	2200      	movs	r2, #0
70006aca:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
  HAL_XSPI_RegisterCallback(SalXspi->hxspi, HAL_XSPI_TX_CPLT_CB_ID, SAL_XSPI_CompleteCallback);
  /* Set the error callback */
  HAL_XSPI_RegisterCallback(SalXspi->hxspi, HAL_XSPI_ERROR_CB_ID, SAL_XSPI_ErrorCallback);
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

  return HAL_OK;
70006ace:	2300      	movs	r3, #0
}
70006ad0:	4618      	mov	r0, r3
70006ad2:	3758      	adds	r7, #88	@ 0x58
70006ad4:	46bd      	mov	sp, r7
70006ad6:	bd80      	pop	{r7, pc}

70006ad8 <SAL_XSPI_MemoryConfig>:
  * @param ParamVal Pointer on the parameter value
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_MemoryConfig(SAL_XSPI_ObjectTypeDef *SalXspi, SAL_XSPI_MemParamTypeTypeDef ParametersType,
                                        void *ParamVal)
{
70006ad8:	b580      	push	{r7, lr}
70006ada:	b098      	sub	sp, #96	@ 0x60
70006adc:	af00      	add	r7, sp, #0
70006ade:	60f8      	str	r0, [r7, #12]
70006ae0:	460b      	mov	r3, r1
70006ae2:	607a      	str	r2, [r7, #4]
70006ae4:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr = HAL_OK;
70006ae6:	2300      	movs	r3, #0
70006ae8:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  XSPI_RegularCmdTypeDef s_commandbase = SalXspi->Commandbase;
70006aec:	68fb      	ldr	r3, [r7, #12]
70006aee:	f107 0010 	add.w	r0, r7, #16
70006af2:	3304      	adds	r3, #4
70006af4:	224c      	movs	r2, #76	@ 0x4c
70006af6:	4619      	mov	r1, r3
70006af8:	f002 fbbd 	bl	70009276 <memcpy>

  switch (ParametersType)
70006afc:	7afb      	ldrb	r3, [r7, #11]
70006afe:	2b04      	cmp	r3, #4
70006b00:	f200 812a 	bhi.w	70006d58 <SAL_XSPI_MemoryConfig+0x280>
70006b04:	a201      	add	r2, pc, #4	@ (adr r2, 70006b0c <SAL_XSPI_MemoryConfig+0x34>)
70006b06:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70006b0a:	bf00      	nop
70006b0c:	70006b21 	.word	0x70006b21
70006b10:	70006d49 	.word	0x70006d49
70006b14:	70006d1b 	.word	0x70006d1b
70006b18:	70006d59 	.word	0x70006d59
70006b1c:	70006d23 	.word	0x70006d23
  {
    case PARAM_PHY_LINK:
    {
      SalXspi->PhyLink = *((SAL_XSPI_PhysicalLinkTypeDef *)ParamVal);
70006b20:	687b      	ldr	r3, [r7, #4]
70006b22:	781a      	ldrb	r2, [r3, #0]
70006b24:	68fb      	ldr	r3, [r7, #12]
70006b26:	f883 2052 	strb.w	r2, [r3, #82]	@ 0x52
      DEBUG_PARAM_BEGIN();
      DEBUG_PARAM_DATA("::PARAM_PHY_LINK::");
      DEBUG_PARAM_DATA(STR_PHY_LINK(SalXspi->PhyLink));
      switch (SalXspi->PhyLink)
70006b2a:	68fb      	ldr	r3, [r7, #12]
70006b2c:	f893 3052 	ldrb.w	r3, [r3, #82]	@ 0x52
70006b30:	2b0b      	cmp	r3, #11
70006b32:	f200 80ed 	bhi.w	70006d10 <SAL_XSPI_MemoryConfig+0x238>
70006b36:	a201      	add	r2, pc, #4	@ (adr r2, 70006b3c <SAL_XSPI_MemoryConfig+0x64>)
70006b38:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70006b3c:	70006b6d 	.word	0x70006b6d
70006b40:	70006b6d 	.word	0x70006b6d
70006b44:	70006b6d 	.word	0x70006b6d
70006b48:	70006b6d 	.word	0x70006b6d
70006b4c:	70006b9d 	.word	0x70006b9d
70006b50:	70006b9d 	.word	0x70006b9d
70006b54:	70006bcd 	.word	0x70006bcd
70006b58:	70006c01 	.word	0x70006c01
70006b5c:	70006c31 	.word	0x70006c31
70006b60:	70006c67 	.word	0x70006c67
70006b64:	70006c9d 	.word	0x70006c9d
70006b68:	70006cd7 	.word	0x70006cd7
        case PHY_LINK_1S1D1D:
        case PHY_LINK_1S2S2S:
        case PHY_LINK_1S1S2S:
        case PHY_LINK_1S1S1S:
        {
          s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
70006b6c:	2301      	movs	r3, #1
70006b6e:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
70006b70:	2300      	movs	r3, #0
70006b72:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
70006b74:	2300      	movs	r3, #0
70006b76:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode = HAL_XSPI_ADDRESS_1_LINE;
70006b78:	f44f 7380 	mov.w	r3, #256	@ 0x100
70006b7c:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
70006b7e:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
70006b82:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
70006b84:	2300      	movs	r3, #0
70006b86:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.DataMode = HAL_XSPI_DATA_1_LINE;
70006b88:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
70006b8c:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
70006b8e:	2300      	movs	r3, #0
70006b90:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles = 8;
70006b92:	2308      	movs	r3, #8
70006b94:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
70006b96:	2300      	movs	r3, #0
70006b98:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006b9a:	e0bd      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }

        case PHY_LINK_4S4D4D:
        case PHY_LINK_4S4S4S:
        {
          s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_4_LINES;
70006b9c:	2303      	movs	r3, #3
70006b9e:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
70006ba0:	2300      	movs	r3, #0
70006ba2:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
70006ba4:	2300      	movs	r3, #0
70006ba6:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
70006ba8:	f44f 7340 	mov.w	r3, #768	@ 0x300
70006bac:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
70006bae:	2300      	movs	r3, #0
70006bb0:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
70006bb2:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
70006bb6:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.DataMode = HAL_XSPI_DATA_4_LINES;
70006bb8:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
70006bbc:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
70006bbe:	2300      	movs	r3, #0
70006bc0:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles = 6;
70006bc2:	2306      	movs	r3, #6
70006bc4:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
70006bc6:	2300      	movs	r3, #0
70006bc8:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006bca:	e0a5      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }
        case PHY_LINK_4D4D4D:
        {
          s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_4_LINES;
70006bcc:	2303      	movs	r3, #3
70006bce:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
70006bd0:	2300      	movs	r3, #0
70006bd2:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
70006bd4:	2308      	movs	r3, #8
70006bd6:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode = HAL_XSPI_ADDRESS_4_LINES;
70006bd8:	f44f 7340 	mov.w	r3, #768	@ 0x300
70006bdc:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
70006bde:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
70006be2:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
70006be4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
70006be8:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.DataMode = HAL_XSPI_DATA_4_LINES;
70006bea:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
70006bee:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
70006bf0:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
70006bf4:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles = 6;
70006bf6:	2306      	movs	r3, #6
70006bf8:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
70006bfa:	2300      	movs	r3, #0
70006bfc:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006bfe:	e08b      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }
        case PHY_LINK_1S8S8S:
        {
          s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_1_LINE;
70006c00:	2301      	movs	r3, #1
70006c02:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
70006c04:	2300      	movs	r3, #0
70006c06:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
70006c08:	2300      	movs	r3, #0
70006c0a:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
70006c0c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
70006c10:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
70006c12:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
70006c16:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_DISABLE;
70006c18:	2300      	movs	r3, #0
70006c1a:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
70006c1c:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
70006c20:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_DISABLE;
70006c22:	2300      	movs	r3, #0
70006c24:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles = 8;
70006c26:	2308      	movs	r3, #8
70006c28:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode = HAL_XSPI_DQS_DISABLE;
70006c2a:	2300      	movs	r3, #0
70006c2c:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006c2e:	e073      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }
        case PHY_LINK_8S8D8D:
        {
          s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
70006c30:	2304      	movs	r3, #4
70006c32:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_8_BITS;
70006c34:	2300      	movs	r3, #0
70006c36:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
70006c38:	2300      	movs	r3, #0
70006c3a:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
70006c3c:	f44f 6380 	mov.w	r3, #1024	@ 0x400
70006c40:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
70006c42:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
70006c46:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
70006c48:	f44f 6300 	mov.w	r3, #2048	@ 0x800
70006c4c:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
70006c4e:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
70006c52:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
70006c54:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
70006c58:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles = 8;
70006c5a:	2308      	movs	r3, #8
70006c5c:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode = HAL_XSPI_DQS_ENABLE;
70006c5e:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
70006c62:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006c64:	e058      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }

        case PHY_LINK_8D8D8D:
        {
          s_commandbase.InstructionMode = HAL_XSPI_INSTRUCTION_8_LINES;
70006c66:	2304      	movs	r3, #4
70006c68:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth = HAL_XSPI_INSTRUCTION_16_BITS;
70006c6a:	2310      	movs	r3, #16
70006c6c:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_ENABLE;
70006c6e:	2308      	movs	r3, #8
70006c70:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode = HAL_XSPI_ADDRESS_8_LINES;
70006c72:	f44f 6380 	mov.w	r3, #1024	@ 0x400
70006c76:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
70006c78:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
70006c7c:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.AddressDTRMode = HAL_XSPI_ADDRESS_DTR_ENABLE;
70006c7e:	f44f 6300 	mov.w	r3, #2048	@ 0x800
70006c82:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.DataMode = HAL_XSPI_DATA_8_LINES;
70006c84:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
70006c88:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode = HAL_XSPI_DATA_DTR_ENABLE;
70006c8a:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
70006c8e:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles = 20;
70006c90:	2314      	movs	r3, #20
70006c92:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode = HAL_XSPI_DQS_ENABLE;
70006c94:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
70006c98:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006c9a:	e03d      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }
        case PHY_LINK_RAM8:
        {
          s_commandbase.InstructionMode    = HAL_XSPI_INSTRUCTION_8_LINES;
70006c9c:	2304      	movs	r3, #4
70006c9e:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth   = HAL_XSPI_INSTRUCTION_8_BITS;
70006ca0:	2300      	movs	r3, #0
70006ca2:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
70006ca4:	2300      	movs	r3, #0
70006ca6:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode        = HAL_XSPI_ADDRESS_8_LINES;
70006ca8:	f44f 6380 	mov.w	r3, #1024	@ 0x400
70006cac:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
70006cae:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
70006cb2:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_ENABLE;
70006cb4:	f44f 6300 	mov.w	r3, #2048	@ 0x800
70006cb8:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
70006cba:	2300      	movs	r3, #0
70006cbc:	63fb      	str	r3, [r7, #60]	@ 0x3c
          s_commandbase.DataMode           = HAL_XSPI_DATA_8_LINES;
70006cbe:	f04f 6380 	mov.w	r3, #67108864	@ 0x4000000
70006cc2:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode        = HAL_XSPI_DATA_DTR_ENABLE;
70006cc4:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
70006cc8:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles        = 10;
70006cca:	230a      	movs	r3, #10
70006ccc:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode            = HAL_XSPI_DQS_ENABLE;
70006cce:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
70006cd2:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006cd4:	e020      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }
#if defined(HAL_XSPI_DATA_16_LINES)
        case PHY_LINK_RAM16 :
        {
          s_commandbase.InstructionMode    = HAL_XSPI_INSTRUCTION_8_LINES;
70006cd6:	2304      	movs	r3, #4
70006cd8:	61fb      	str	r3, [r7, #28]
          s_commandbase.InstructionWidth   = HAL_XSPI_INSTRUCTION_8_BITS;
70006cda:	2300      	movs	r3, #0
70006cdc:	623b      	str	r3, [r7, #32]
          s_commandbase.InstructionDTRMode = HAL_XSPI_INSTRUCTION_DTR_DISABLE;
70006cde:	2300      	movs	r3, #0
70006ce0:	627b      	str	r3, [r7, #36]	@ 0x24
          s_commandbase.AddressMode        = HAL_XSPI_ADDRESS_8_LINES;
70006ce2:	f44f 6380 	mov.w	r3, #1024	@ 0x400
70006ce6:	62fb      	str	r3, [r7, #44]	@ 0x2c
          s_commandbase.AddressWidth       = HAL_XSPI_ADDRESS_32_BITS;
70006ce8:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
70006cec:	633b      	str	r3, [r7, #48]	@ 0x30
          s_commandbase.AddressDTRMode     = HAL_XSPI_ADDRESS_DTR_ENABLE;
70006cee:	f44f 6300 	mov.w	r3, #2048	@ 0x800
70006cf2:	637b      	str	r3, [r7, #52]	@ 0x34
          s_commandbase.AlternateBytesMode = HAL_XSPI_ALT_BYTES_NONE;
70006cf4:	2300      	movs	r3, #0
70006cf6:	63fb      	str	r3, [r7, #60]	@ 0x3c
          s_commandbase.DataMode           = HAL_XSPI_DATA_16_LINES;
70006cf8:	f04f 63a0 	mov.w	r3, #83886080	@ 0x5000000
70006cfc:	64bb      	str	r3, [r7, #72]	@ 0x48
          s_commandbase.DataDTRMode        = HAL_XSPI_DATA_DTR_ENABLE;
70006cfe:	f04f 6300 	mov.w	r3, #134217728	@ 0x8000000
70006d02:	653b      	str	r3, [r7, #80]	@ 0x50
          s_commandbase.DummyCycles        = 10;
70006d04:	230a      	movs	r3, #10
70006d06:	657b      	str	r3, [r7, #84]	@ 0x54
          s_commandbase.DQSMode            = HAL_XSPI_DQS_ENABLE;
70006d08:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
70006d0c:	65bb      	str	r3, [r7, #88]	@ 0x58
          break;
70006d0e:	e003      	b.n	70006d18 <SAL_XSPI_MemoryConfig+0x240>
        }
#endif /* HAL_XSPI_DATA_16_LINES */
        default:
          retr = HAL_ERROR;
70006d10:	2301      	movs	r3, #1
70006d12:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
          break;
70006d16:	bf00      	nop
      }
      DEBUG_PARAM_END();
      break;
70006d18:	e022      	b.n	70006d60 <SAL_XSPI_MemoryConfig+0x288>
    case PARAM_ADDRESS_4BYTES:
    {
      DEBUG_PARAM_BEGIN();
      DEBUG_PARAM_DATA("::PARAM_ADDRESS_4BYTES");
      DEBUG_PARAM_END();
      s_commandbase.AddressWidth = HAL_XSPI_ADDRESS_32_BITS;
70006d1a:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
70006d1e:	633b      	str	r3, [r7, #48]	@ 0x30
      break;
70006d20:	e01e      	b.n	70006d60 <SAL_XSPI_MemoryConfig+0x288>
    }
    case PARAM_FLASHSIZE:
    {
      uint8_t valParam = *((uint8_t *)ParamVal);
70006d22:	687b      	ldr	r3, [r7, #4]
70006d24:	781b      	ldrb	r3, [r3, #0]
70006d26:	f887 305e 	strb.w	r3, [r7, #94]	@ 0x5e
      DEBUG_PARAM_BEGIN();
      DEBUG_PARAM_DATA("::PARAM_FLASHSIZE::");
      DEBUG_PARAM_INT(valParam);
      DEBUG_PARAM_END();
      MODIFY_REG(SalXspi->hxspi->Instance->DCR1, XSPI_DCR1_DEVSIZE, ((uint32_t)valParam) << XSPI_DCR1_DEVSIZE_Pos);
70006d2a:	68fb      	ldr	r3, [r7, #12]
70006d2c:	681b      	ldr	r3, [r3, #0]
70006d2e:	681b      	ldr	r3, [r3, #0]
70006d30:	689b      	ldr	r3, [r3, #8]
70006d32:	f423 11f8 	bic.w	r1, r3, #2031616	@ 0x1f0000
70006d36:	f897 305e 	ldrb.w	r3, [r7, #94]	@ 0x5e
70006d3a:	041a      	lsls	r2, r3, #16
70006d3c:	68fb      	ldr	r3, [r7, #12]
70006d3e:	681b      	ldr	r3, [r3, #0]
70006d40:	681b      	ldr	r3, [r3, #0]
70006d42:	430a      	orrs	r2, r1
70006d44:	609a      	str	r2, [r3, #8]
      break;
70006d46:	e00b      	b.n	70006d60 <SAL_XSPI_MemoryConfig+0x288>
    }
    case PARAM_DUMMY_CYCLES:
    {
      uint8_t valParam = *((uint8_t *)ParamVal);
70006d48:	687b      	ldr	r3, [r7, #4]
70006d4a:	781b      	ldrb	r3, [r3, #0]
70006d4c:	f887 305d 	strb.w	r3, [r7, #93]	@ 0x5d
      DEBUG_PARAM_BEGIN();
      DEBUG_PARAM_DATA("::PARAM_DUMMY_CYCLES::");
      DEBUG_PARAM_INT(valParam);
      DEBUG_PARAM_END();
      s_commandbase.DummyCycles = valParam;
70006d50:	f897 305d 	ldrb.w	r3, [r7, #93]	@ 0x5d
70006d54:	657b      	str	r3, [r7, #84]	@ 0x54
      break;
70006d56:	e003      	b.n	70006d60 <SAL_XSPI_MemoryConfig+0x288>
    }
    default:
      DEBUG_PARAM_BEGIN();
      DEBUG_PARAM_DATA("::SAL_XSPI_MemoryConfig::ERROR");
      DEBUG_PARAM_END();
      retr = HAL_ERROR;
70006d58:	2301      	movs	r3, #1
70006d5a:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
      break;
70006d5e:	bf00      	nop
  }
  SalXspi->Commandbase = s_commandbase;
70006d60:	68fb      	ldr	r3, [r7, #12]
70006d62:	3304      	adds	r3, #4
70006d64:	f107 0110 	add.w	r1, r7, #16
70006d68:	224c      	movs	r2, #76	@ 0x4c
70006d6a:	4618      	mov	r0, r3
70006d6c:	f002 fa83 	bl	70009276 <memcpy>
  return retr;
70006d70:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
70006d74:	4618      	mov	r0, r3
70006d76:	3760      	adds	r7, #96	@ 0x60
70006d78:	46bd      	mov	sp, r7
70006d7a:	bd80      	pop	{r7, pc}

70006d7c <SAL_XSPI_GetSFDP>:
  * @param Data Data pointer
  * @param DataSize Size of the data to read
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_GetSFDP(SAL_XSPI_ObjectTypeDef *SalXspi, uint32_t Address, uint8_t *Data, uint32_t DataSize)
{
70006d7c:	b580      	push	{r7, lr}
70006d7e:	b098      	sub	sp, #96	@ 0x60
70006d80:	af00      	add	r7, sp, #0
70006d82:	60f8      	str	r0, [r7, #12]
70006d84:	60b9      	str	r1, [r7, #8]
70006d86:	607a      	str	r2, [r7, #4]
70006d88:	603b      	str	r3, [r7, #0]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
70006d8a:	68fb      	ldr	r3, [r7, #12]
70006d8c:	f107 0010 	add.w	r0, r7, #16
70006d90:	3304      	adds	r3, #4
70006d92:	224c      	movs	r2, #76	@ 0x4c
70006d94:	4619      	mov	r1, r3
70006d96:	f002 fa6e 	bl	70009276 <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth,
70006d9a:	68fb      	ldr	r3, [r7, #12]
70006d9c:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
70006da0:	6a39      	ldr	r1, [r7, #32]
70006da2:	225a      	movs	r2, #90	@ 0x5a
70006da4:	4618      	mov	r0, r3
70006da6:	f000 faef 	bl	70007388 <XSPI_FormatCommand>
70006daa:	4603      	mov	r3, r0
70006dac:	61bb      	str	r3, [r7, #24]
                                             EXTMEM_READ_SFDP_COMMAND);

  s_command.Address     = Address;
70006dae:	68bb      	ldr	r3, [r7, #8]
70006db0:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength  = DataSize;
70006db2:	683b      	ldr	r3, [r7, #0]
70006db4:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DummyCycles = SalXspi->SFDPDummyCycle;
70006db6:	68fb      	ldr	r3, [r7, #12]
70006db8:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
70006dbc:	657b      	str	r3, [r7, #84]	@ 0x54

  if ((s_command.AddressMode == HAL_XSPI_ADDRESS_1_LINE) || (s_command.AddressMode == HAL_XSPI_ADDRESS_4_LINES))
70006dbe:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
70006dc0:	f5b3 7f80 	cmp.w	r3, #256	@ 0x100
70006dc4:	d003      	beq.n	70006dce <SAL_XSPI_GetSFDP+0x52>
70006dc6:	6afb      	ldr	r3, [r7, #44]	@ 0x2c
70006dc8:	f5b3 7f40 	cmp.w	r3, #768	@ 0x300
70006dcc:	d102      	bne.n	70006dd4 <SAL_XSPI_GetSFDP+0x58>
  {
    s_command.AddressWidth = HAL_XSPI_ADDRESS_24_BITS;
70006dce:	f44f 5300 	mov.w	r3, #8192	@ 0x2000
70006dd2:	633b      	str	r3, [r7, #48]	@ 0x30
  }

  if (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE)
70006dd4:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
70006dd6:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
70006dda:	d103      	bne.n	70006de4 <SAL_XSPI_GetSFDP+0x68>
  {
    s_command.DQSMode = HAL_XSPI_DQS_ENABLE;
70006ddc:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
70006de0:	65bb      	str	r3, [r7, #88]	@ 0x58
70006de2:	e001      	b.n	70006de8 <SAL_XSPI_GetSFDP+0x6c>
  }
  else
  {
    s_command.DQSMode = HAL_XSPI_DQS_DISABLE;
70006de4:	2300      	movs	r3, #0
70006de6:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70006de8:	68fb      	ldr	r3, [r7, #12]
70006dea:	681b      	ldr	r3, [r3, #0]
70006dec:	f107 0110 	add.w	r1, r7, #16
70006df0:	2264      	movs	r2, #100	@ 0x64
70006df2:	4618      	mov	r0, r3
70006df4:	f7fe ffe2 	bl	70005dbc <HAL_XSPI_Command>
70006df8:	4603      	mov	r3, r0
70006dfa:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if (retr  != HAL_OK)
70006dfe:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
70006e02:	2b00      	cmp	r3, #0
70006e04:	d10a      	bne.n	70006e1c <SAL_XSPI_GetSFDP+0xa0>
  {
    goto error;
  }

  /* Reception of the data */
  retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70006e06:	68fb      	ldr	r3, [r7, #12]
70006e08:	681b      	ldr	r3, [r3, #0]
70006e0a:	2264      	movs	r2, #100	@ 0x64
70006e0c:	6879      	ldr	r1, [r7, #4]
70006e0e:	4618      	mov	r0, r3
70006e10:	f7ff f8d7 	bl	70005fc2 <HAL_XSPI_Receive>
70006e14:	4603      	mov	r3, r0
70006e16:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
70006e1a:	e000      	b.n	70006e1e <SAL_XSPI_GetSFDP+0xa2>
    goto error;
70006e1c:	bf00      	nop

error:
  if (retr != HAL_OK)
70006e1e:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
70006e22:	2b00      	cmp	r3, #0
70006e24:	d004      	beq.n	70006e30 <SAL_XSPI_GetSFDP+0xb4>
  {
    /* Abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
70006e26:	68fb      	ldr	r3, [r7, #12]
70006e28:	681b      	ldr	r3, [r3, #0]
70006e2a:	4618      	mov	r0, r3
70006e2c:	f7ff f9f6 	bl	7000621c <HAL_XSPI_Abort>
  }
  return retr;
70006e30:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
70006e34:	4618      	mov	r0, r3
70006e36:	3760      	adds	r7, #96	@ 0x60
70006e38:	46bd      	mov	sp, r7
70006e3a:	bd80      	pop	{r7, pc}

70006e3c <SAL_XSPI_GetId>:
  * @param Data Data pointer where read ID should be stored
  * @param DataSize Number of data to read
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_GetId(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t *Data, uint32_t DataSize)
{
70006e3c:	b580      	push	{r7, lr}
70006e3e:	b098      	sub	sp, #96	@ 0x60
70006e40:	af00      	add	r7, sp, #0
70006e42:	60f8      	str	r0, [r7, #12]
70006e44:	60b9      	str	r1, [r7, #8]
70006e46:	607a      	str	r2, [r7, #4]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
70006e48:	68fb      	ldr	r3, [r7, #12]
70006e4a:	f107 0010 	add.w	r0, r7, #16
70006e4e:	3304      	adds	r3, #4
70006e50:	224c      	movs	r2, #76	@ 0x4c
70006e52:	4619      	mov	r1, r3
70006e54:	f002 fa0f 	bl	70009276 <memcpy>

  /* Initialize the Read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth,
70006e58:	68fb      	ldr	r3, [r7, #12]
70006e5a:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
70006e5e:	6a39      	ldr	r1, [r7, #32]
70006e60:	229f      	movs	r2, #159	@ 0x9f
70006e62:	4618      	mov	r0, r3
70006e64:	f000 fa90 	bl	70007388 <XSPI_FormatCommand>
70006e68:	4603      	mov	r3, r0
70006e6a:	61bb      	str	r3, [r7, #24]
                                             EXTMEM_READ_JEDEC_ID_SPI_COMMAND);

  s_command.DataLength  = DataSize;
70006e6c:	687b      	ldr	r3, [r7, #4]
70006e6e:	64fb      	str	r3, [r7, #76]	@ 0x4c

  if (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_1_LINE)
70006e70:	69fb      	ldr	r3, [r7, #28]
70006e72:	2b01      	cmp	r3, #1
70006e74:	d107      	bne.n	70006e86 <SAL_XSPI_GetId+0x4a>
  {
    s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
70006e76:	2300      	movs	r3, #0
70006e78:	62fb      	str	r3, [r7, #44]	@ 0x2c
    s_command.DummyCycles       = 0;
70006e7a:	2300      	movs	r3, #0
70006e7c:	657b      	str	r3, [r7, #84]	@ 0x54
    /* This behavior is linked with micron memory to read ID in 1S8S8S */
    s_command.DataMode = HAL_XSPI_DATA_1_LINE;
70006e7e:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
70006e82:	64bb      	str	r3, [r7, #72]	@ 0x48
70006e84:	e030      	b.n	70006ee8 <SAL_XSPI_GetId+0xac>
  }
  else if (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_4_LINES)
70006e86:	69fb      	ldr	r3, [r7, #28]
70006e88:	2b03      	cmp	r3, #3
70006e8a:	d107      	bne.n	70006e9c <SAL_XSPI_GetId+0x60>
  {
    s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
70006e8c:	2300      	movs	r3, #0
70006e8e:	62fb      	str	r3, [r7, #44]	@ 0x2c
    s_command.DummyCycles       = 0;
70006e90:	2300      	movs	r3, #0
70006e92:	657b      	str	r3, [r7, #84]	@ 0x54
    /* This behavior is linked with ISSI memory to read ID in 4S4S4S */
    s_command.DataMode          = HAL_XSPI_DATA_4_LINES;
70006e94:	f04f 7340 	mov.w	r3, #50331648	@ 0x3000000
70006e98:	64bb      	str	r3, [r7, #72]	@ 0x48
70006e9a:	e025      	b.n	70006ee8 <SAL_XSPI_GetId+0xac>
  }
  else if (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_8_LINES)
70006e9c:	69fb      	ldr	r3, [r7, #28]
70006e9e:	2b04      	cmp	r3, #4
70006ea0:	d11e      	bne.n	70006ee0 <SAL_XSPI_GetId+0xa4>
  {
    s_command.Address = 0;
70006ea2:	2300      	movs	r3, #0
70006ea4:	62bb      	str	r3, [r7, #40]	@ 0x28

    /* Specific case for Macronix memories : RDID is not Data DTR  */
    if ((Data[0] == 0xC2) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
70006ea6:	68bb      	ldr	r3, [r7, #8]
70006ea8:	781b      	ldrb	r3, [r3, #0]
70006eaa:	2bc2      	cmp	r3, #194	@ 0xc2
70006eac:	d108      	bne.n	70006ec0 <SAL_XSPI_GetId+0x84>
70006eae:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
70006eb0:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
70006eb4:	d104      	bne.n	70006ec0 <SAL_XSPI_GetId+0x84>
    {
      s_command.DummyCycles       = 4;
70006eb6:	2304      	movs	r3, #4
70006eb8:	657b      	str	r3, [r7, #84]	@ 0x54
      s_command.DataDTRMode       = HAL_XSPI_DATA_DTR_DISABLE;
70006eba:	2300      	movs	r3, #0
70006ebc:	653b      	str	r3, [r7, #80]	@ 0x50
70006ebe:	e013      	b.n	70006ee8 <SAL_XSPI_GetId+0xac>
    }
    /* Specific case for GigaDevice memories : RDID has no address even in Octal mode  */
    else if ((Data[0] == 0xC8) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
70006ec0:	68bb      	ldr	r3, [r7, #8]
70006ec2:	781b      	ldrb	r3, [r3, #0]
70006ec4:	2bc8      	cmp	r3, #200	@ 0xc8
70006ec6:	d108      	bne.n	70006eda <SAL_XSPI_GetId+0x9e>
70006ec8:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
70006eca:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
70006ece:	d104      	bne.n	70006eda <SAL_XSPI_GetId+0x9e>
    {
      s_command.DummyCycles       = 8;
70006ed0:	2308      	movs	r3, #8
70006ed2:	657b      	str	r3, [r7, #84]	@ 0x54
      s_command.AddressMode       = HAL_XSPI_ADDRESS_NONE;
70006ed4:	2300      	movs	r3, #0
70006ed6:	62fb      	str	r3, [r7, #44]	@ 0x2c
70006ed8:	e006      	b.n	70006ee8 <SAL_XSPI_GetId+0xac>
    }
    else
    {
      s_command.DummyCycles = 8;
70006eda:	2308      	movs	r3, #8
70006edc:	657b      	str	r3, [r7, #84]	@ 0x54
70006ede:	e003      	b.n	70006ee8 <SAL_XSPI_GetId+0xac>
    }
    /* Required behavior to be confirmed on the other memories */
  }
  else
  {
    s_command.Address = 0;
70006ee0:	2300      	movs	r3, #0
70006ee2:	62bb      	str	r3, [r7, #40]	@ 0x28
    s_command.DummyCycles = 8;
70006ee4:	2308      	movs	r3, #8
70006ee6:	657b      	str	r3, [r7, #84]	@ 0x54
  }

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70006ee8:	68fb      	ldr	r3, [r7, #12]
70006eea:	681b      	ldr	r3, [r3, #0]
70006eec:	f107 0110 	add.w	r1, r7, #16
70006ef0:	2264      	movs	r2, #100	@ 0x64
70006ef2:	4618      	mov	r0, r3
70006ef4:	f7fe ff62 	bl	70005dbc <HAL_XSPI_Command>
70006ef8:	4603      	mov	r3, r0
70006efa:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if (retr  != HAL_OK)
70006efe:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
70006f02:	2b00      	cmp	r3, #0
70006f04:	d10a      	bne.n	70006f1c <SAL_XSPI_GetId+0xe0>
  {
    goto error;
  }

  /* Reception of the data */
  retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70006f06:	68fb      	ldr	r3, [r7, #12]
70006f08:	681b      	ldr	r3, [r3, #0]
70006f0a:	2264      	movs	r2, #100	@ 0x64
70006f0c:	68b9      	ldr	r1, [r7, #8]
70006f0e:	4618      	mov	r0, r3
70006f10:	f7ff f857 	bl	70005fc2 <HAL_XSPI_Receive>
70006f14:	4603      	mov	r3, r0
70006f16:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
70006f1a:	e000      	b.n	70006f1e <SAL_XSPI_GetId+0xe2>
    goto error;
70006f1c:	bf00      	nop

error:
  if (retr != HAL_OK)
70006f1e:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
70006f22:	2b00      	cmp	r3, #0
70006f24:	d004      	beq.n	70006f30 <SAL_XSPI_GetId+0xf4>
  {
    /* Abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
70006f26:	68fb      	ldr	r3, [r7, #12]
70006f28:	681b      	ldr	r3, [r3, #0]
70006f2a:	4618      	mov	r0, r3
70006f2c:	f7ff f976 	bl	7000621c <HAL_XSPI_Abort>
  }
  return retr;
70006f30:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
70006f34:	4618      	mov	r0, r3
70006f36:	3760      	adds	r7, #96	@ 0x60
70006f38:	46bd      	mov	sp, r7
70006f3a:	bd80      	pop	{r7, pc}

70006f3c <SAL_XSPI_Write>:
  * @param DataSize Size of the data to write
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_Write(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address,
                                 const uint8_t *Data, uint32_t DataSize)
{
70006f3c:	b580      	push	{r7, lr}
70006f3e:	b098      	sub	sp, #96	@ 0x60
70006f40:	af00      	add	r7, sp, #0
70006f42:	60f8      	str	r0, [r7, #12]
70006f44:	607a      	str	r2, [r7, #4]
70006f46:	603b      	str	r3, [r7, #0]
70006f48:	460b      	mov	r3, r1
70006f4a:	72fb      	strb	r3, [r7, #11]
  HAL_StatusTypeDef retr;
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
70006f4c:	68fb      	ldr	r3, [r7, #12]
70006f4e:	f107 0010 	add.w	r0, r7, #16
70006f52:	3304      	adds	r3, #4
70006f54:	224c      	movs	r2, #76	@ 0x4c
70006f56:	4619      	mov	r1, r3
70006f58:	f002 f98d 	bl	70009276 <memcpy>

  /* Initialize the read ID command */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
70006f5c:	68fb      	ldr	r3, [r7, #12]
70006f5e:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
70006f62:	6a39      	ldr	r1, [r7, #32]
70006f64:	7afa      	ldrb	r2, [r7, #11]
70006f66:	4618      	mov	r0, r3
70006f68:	f000 fa0e 	bl	70007388 <XSPI_FormatCommand>
70006f6c:	4603      	mov	r3, r0
70006f6e:	61bb      	str	r3, [r7, #24]

  s_command.Address           = Address;
70006f70:	687b      	ldr	r3, [r7, #4]
70006f72:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DataLength        = DataSize;
70006f74:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
70006f76:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DummyCycles       = 0u;
70006f78:	2300      	movs	r3, #0
70006f7a:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DQSMode           = HAL_XSPI_DQS_DISABLE;
70006f7c:	2300      	movs	r3, #0
70006f7e:	65bb      	str	r3, [r7, #88]	@ 0x58

  /* Configure the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70006f80:	68fb      	ldr	r3, [r7, #12]
70006f82:	681b      	ldr	r3, [r3, #0]
70006f84:	f107 0110 	add.w	r1, r7, #16
70006f88:	2264      	movs	r2, #100	@ 0x64
70006f8a:	4618      	mov	r0, r3
70006f8c:	f7fe ff16 	bl	70005dbc <HAL_XSPI_Command>
70006f90:	4603      	mov	r3, r0
70006f92:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  if (HAL_OK != retr)
70006f96:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
70006f9a:	2b00      	cmp	r3, #0
70006f9c:	d107      	bne.n	70006fae <SAL_XSPI_Write+0x72>
  {
    goto error;
  }

  /* Transmit data */
  retr = XSPI_Transmit(SalXspi, Data);
70006f9e:	6839      	ldr	r1, [r7, #0]
70006fa0:	68f8      	ldr	r0, [r7, #12]
70006fa2:	f000 fa1a 	bl	700073da <XSPI_Transmit>
70006fa6:	4603      	mov	r3, r0
70006fa8:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
70006fac:	e000      	b.n	70006fb0 <SAL_XSPI_Write+0x74>
    goto error;
70006fae:	bf00      	nop

error:
  if (retr != HAL_OK)
70006fb0:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
70006fb4:	2b00      	cmp	r3, #0
70006fb6:	d004      	beq.n	70006fc2 <SAL_XSPI_Write+0x86>
  {
    /* Abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
70006fb8:	68fb      	ldr	r3, [r7, #12]
70006fba:	681b      	ldr	r3, [r3, #0]
70006fbc:	4618      	mov	r0, r3
70006fbe:	f7ff f92d 	bl	7000621c <HAL_XSPI_Abort>
  }
  return retr;
70006fc2:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
70006fc6:	4618      	mov	r0, r3
70006fc8:	3760      	adds	r7, #96	@ 0x60
70006fca:	46bd      	mov	sp, r7
70006fcc:	bd80      	pop	{r7, pc}

70006fce <SAL_XSPI_CommandSendData>:
  * @param DataSize Size of the data to write
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_CommandSendData(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                           uint8_t *Data, uint16_t DataSize)
{
70006fce:	b580      	push	{r7, lr}
70006fd0:	b098      	sub	sp, #96	@ 0x60
70006fd2:	af00      	add	r7, sp, #0
70006fd4:	60f8      	str	r0, [r7, #12]
70006fd6:	607a      	str	r2, [r7, #4]
70006fd8:	461a      	mov	r2, r3
70006fda:	460b      	mov	r3, r1
70006fdc:	72fb      	strb	r3, [r7, #11]
70006fde:	4613      	mov	r3, r2
70006fe0:	813b      	strh	r3, [r7, #8]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
70006fe2:	68fb      	ldr	r3, [r7, #12]
70006fe4:	f107 0010 	add.w	r0, r7, #16
70006fe8:	3304      	adds	r3, #4
70006fea:	224c      	movs	r2, #76	@ 0x4c
70006fec:	4619      	mov	r1, r3
70006fee:	f002 f942 	bl	70009276 <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the writing of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
70006ff2:	68fb      	ldr	r3, [r7, #12]
70006ff4:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
70006ff8:	6a39      	ldr	r1, [r7, #32]
70006ffa:	7afa      	ldrb	r2, [r7, #11]
70006ffc:	4618      	mov	r0, r3
70006ffe:	f000 f9c3 	bl	70007388 <XSPI_FormatCommand>
70007002:	4603      	mov	r3, r0
70007004:	61bb      	str	r3, [r7, #24]

  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
70007006:	2300      	movs	r3, #0
70007008:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.DummyCycles        = 0U;
7000700a:	2300      	movs	r3, #0
7000700c:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
7000700e:	893b      	ldrh	r3, [r7, #8]
70007010:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
70007012:	2300      	movs	r3, #0
70007014:	65bb      	str	r3, [r7, #88]	@ 0x58

  if (DataSize == 0u)
70007016:	893b      	ldrh	r3, [r7, #8]
70007018:	2b00      	cmp	r3, #0
7000701a:	d101      	bne.n	70007020 <SAL_XSPI_CommandSendData+0x52>
  {
    s_command.DataMode         = HAL_XSPI_DATA_NONE;
7000701c:	2300      	movs	r3, #0
7000701e:	64bb      	str	r3, [r7, #72]	@ 0x48
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70007020:	68fb      	ldr	r3, [r7, #12]
70007022:	681b      	ldr	r3, [r3, #0]
70007024:	f107 0110 	add.w	r1, r7, #16
70007028:	2264      	movs	r2, #100	@ 0x64
7000702a:	4618      	mov	r0, r3
7000702c:	f7fe fec6 	bl	70005dbc <HAL_XSPI_Command>
70007030:	4603      	mov	r3, r0
70007032:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if ((retr == HAL_OK) && (DataSize != 0u))
70007036:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
7000703a:	2b00      	cmp	r3, #0
7000703c:	d10c      	bne.n	70007058 <SAL_XSPI_CommandSendData+0x8a>
7000703e:	893b      	ldrh	r3, [r7, #8]
70007040:	2b00      	cmp	r3, #0
70007042:	d009      	beq.n	70007058 <SAL_XSPI_CommandSendData+0x8a>
  {
    retr = HAL_XSPI_Transmit(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70007044:	68fb      	ldr	r3, [r7, #12]
70007046:	681b      	ldr	r3, [r3, #0]
70007048:	2264      	movs	r2, #100	@ 0x64
7000704a:	6879      	ldr	r1, [r7, #4]
7000704c:	4618      	mov	r0, r3
7000704e:	f7fe ff45 	bl	70005edc <HAL_XSPI_Transmit>
70007052:	4603      	mov	r3, r0
70007054:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK)
70007058:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
7000705c:	2b00      	cmp	r3, #0
7000705e:	d004      	beq.n	7000706a <SAL_XSPI_CommandSendData+0x9c>
  {
    /* Abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
70007060:	68fb      	ldr	r3, [r7, #12]
70007062:	681b      	ldr	r3, [r3, #0]
70007064:	4618      	mov	r0, r3
70007066:	f7ff f8d9 	bl	7000621c <HAL_XSPI_Abort>
  }
  return retr;
7000706a:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
7000706e:	4618      	mov	r0, r3
70007070:	3760      	adds	r7, #96	@ 0x60
70007072:	46bd      	mov	sp, r7
70007074:	bd80      	pop	{r7, pc}

70007076 <SAL_XSPI_SendReadCommand>:
  * @param DataSize Size of the data to receive
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_SendReadCommand(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                           uint8_t *Data, uint16_t DataSize)
{
70007076:	b580      	push	{r7, lr}
70007078:	b098      	sub	sp, #96	@ 0x60
7000707a:	af00      	add	r7, sp, #0
7000707c:	60f8      	str	r0, [r7, #12]
7000707e:	607a      	str	r2, [r7, #4]
70007080:	461a      	mov	r2, r3
70007082:	460b      	mov	r3, r1
70007084:	72fb      	strb	r3, [r7, #11]
70007086:	4613      	mov	r3, r2
70007088:	813b      	strh	r3, [r7, #8]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
7000708a:	68fb      	ldr	r3, [r7, #12]
7000708c:	f107 0010 	add.w	r0, r7, #16
70007090:	3304      	adds	r3, #4
70007092:	224c      	movs	r2, #76	@ 0x4c
70007094:	4619      	mov	r1, r3
70007096:	f002 f8ee 	bl	70009276 <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
7000709a:	68fb      	ldr	r3, [r7, #12]
7000709c:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
700070a0:	6a39      	ldr	r1, [r7, #32]
700070a2:	7afa      	ldrb	r2, [r7, #11]
700070a4:	4618      	mov	r0, r3
700070a6:	f000 f96f 	bl	70007388 <XSPI_FormatCommand>
700070aa:	4603      	mov	r3, r0
700070ac:	61bb      	str	r3, [r7, #24]

  s_command.AddressMode        = HAL_XSPI_ADDRESS_NONE;
700070ae:	2300      	movs	r3, #0
700070b0:	62fb      	str	r3, [r7, #44]	@ 0x2c
  s_command.DummyCycles        = 0u;
700070b2:	2300      	movs	r3, #0
700070b4:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
700070b6:	893b      	ldrh	r3, [r7, #8]
700070b8:	64fb      	str	r3, [r7, #76]	@ 0x4c
  s_command.DQSMode            = HAL_XSPI_DQS_DISABLE;
700070ba:	2300      	movs	r3, #0
700070bc:	65bb      	str	r3, [r7, #88]	@ 0x58

  if (DataSize == 0u)
700070be:	893b      	ldrh	r3, [r7, #8]
700070c0:	2b00      	cmp	r3, #0
700070c2:	d101      	bne.n	700070c8 <SAL_XSPI_SendReadCommand+0x52>
  {
    s_command.DataMode         = HAL_XSPI_DATA_NONE;
700070c4:	2300      	movs	r3, #0
700070c6:	64bb      	str	r3, [r7, #72]	@ 0x48
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
700070c8:	68fb      	ldr	r3, [r7, #12]
700070ca:	681b      	ldr	r3, [r3, #0]
700070cc:	f107 0110 	add.w	r1, r7, #16
700070d0:	2264      	movs	r2, #100	@ 0x64
700070d2:	4618      	mov	r0, r3
700070d4:	f7fe fe72 	bl	70005dbc <HAL_XSPI_Command>
700070d8:	4603      	mov	r3, r0
700070da:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if ((retr == HAL_OK) && (DataSize != 0u))
700070de:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
700070e2:	2b00      	cmp	r3, #0
700070e4:	d10c      	bne.n	70007100 <SAL_XSPI_SendReadCommand+0x8a>
700070e6:	893b      	ldrh	r3, [r7, #8]
700070e8:	2b00      	cmp	r3, #0
700070ea:	d009      	beq.n	70007100 <SAL_XSPI_SendReadCommand+0x8a>
  {
    /* Receive data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
700070ec:	68fb      	ldr	r3, [r7, #12]
700070ee:	681b      	ldr	r3, [r3, #0]
700070f0:	2264      	movs	r2, #100	@ 0x64
700070f2:	6879      	ldr	r1, [r7, #4]
700070f4:	4618      	mov	r0, r3
700070f6:	f7fe ff64 	bl	70005fc2 <HAL_XSPI_Receive>
700070fa:	4603      	mov	r3, r0
700070fc:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK)
70007100:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
70007104:	2b00      	cmp	r3, #0
70007106:	d004      	beq.n	70007112 <SAL_XSPI_SendReadCommand+0x9c>
  {
    /* Abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
70007108:	68fb      	ldr	r3, [r7, #12]
7000710a:	681b      	ldr	r3, [r3, #0]
7000710c:	4618      	mov	r0, r3
7000710e:	f7ff f885 	bl	7000621c <HAL_XSPI_Abort>
  }
  return retr;
70007112:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
70007116:	4618      	mov	r0, r3
70007118:	3760      	adds	r7, #96	@ 0x60
7000711a:	46bd      	mov	sp, r7
7000711c:	bd80      	pop	{r7, pc}

7000711e <SAL_XSPI_CommandSendReadAddress>:
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_CommandSendReadAddress(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command,
                                                  uint32_t Address, uint8_t *Data, uint16_t DataSize,
                                                  uint8_t ManuId)
{
7000711e:	b580      	push	{r7, lr}
70007120:	b098      	sub	sp, #96	@ 0x60
70007122:	af00      	add	r7, sp, #0
70007124:	60f8      	str	r0, [r7, #12]
70007126:	607a      	str	r2, [r7, #4]
70007128:	603b      	str	r3, [r7, #0]
7000712a:	460b      	mov	r3, r1
7000712c:	72fb      	strb	r3, [r7, #11]
  XSPI_RegularCmdTypeDef   s_command = SalXspi->Commandbase;
7000712e:	68fb      	ldr	r3, [r7, #12]
70007130:	f107 0010 	add.w	r0, r7, #16
70007134:	3304      	adds	r3, #4
70007136:	224c      	movs	r2, #76	@ 0x4c
70007138:	4619      	mov	r1, r3
7000713a:	f002 f89c 	bl	70009276 <memcpy>
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
7000713e:	68fb      	ldr	r3, [r7, #12]
70007140:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
70007144:	6a39      	ldr	r1, [r7, #32]
70007146:	7afa      	ldrb	r2, [r7, #11]
70007148:	4618      	mov	r0, r3
7000714a:	f000 f91d 	bl	70007388 <XSPI_FormatCommand>
7000714e:	4603      	mov	r3, r0
70007150:	61bb      	str	r3, [r7, #24]

  s_command.Address            = Address;
70007152:	687b      	ldr	r3, [r7, #4]
70007154:	62bb      	str	r3, [r7, #40]	@ 0x28
  s_command.DummyCycles        = SalXspi->SFDPDummyCycle;
70007156:	68fb      	ldr	r3, [r7, #12]
70007158:	f893 3051 	ldrb.w	r3, [r3, #81]	@ 0x51
7000715c:	657b      	str	r3, [r7, #84]	@ 0x54
  s_command.DataLength         = DataSize;
7000715e:	f8b7 3068 	ldrh.w	r3, [r7, #104]	@ 0x68
70007162:	64fb      	str	r3, [r7, #76]	@ 0x4c
  /* Specific case for Macronix memories : RDID and RDCR are not Data DTR  */
  if ((ManuId == EXTMEM_MANUFACTURER_MACRONIX) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
70007164:	f897 306c 	ldrb.w	r3, [r7, #108]	@ 0x6c
70007168:	2bc2      	cmp	r3, #194	@ 0xc2
7000716a:	d106      	bne.n	7000717a <SAL_XSPI_CommandSendReadAddress+0x5c>
7000716c:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
7000716e:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
70007172:	d102      	bne.n	7000717a <SAL_XSPI_CommandSendReadAddress+0x5c>
  {
    s_command.DataDTRMode      = HAL_XSPI_DATA_DTR_DISABLE;
70007174:	2300      	movs	r3, #0
70007176:	653b      	str	r3, [r7, #80]	@ 0x50
70007178:	e00e      	b.n	70007198 <SAL_XSPI_CommandSendReadAddress+0x7a>
  }
  /* Specific case for GigaDevice memories : Read Configuration Register are not Data DTR  */
  else if ((ManuId == 0xC8) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
7000717a:	f897 306c 	ldrb.w	r3, [r7, #108]	@ 0x6c
7000717e:	2bc8      	cmp	r3, #200	@ 0xc8
70007180:	d108      	bne.n	70007194 <SAL_XSPI_CommandSendReadAddress+0x76>
70007182:	6d3b      	ldr	r3, [r7, #80]	@ 0x50
70007184:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
70007188:	d104      	bne.n	70007194 <SAL_XSPI_CommandSendReadAddress+0x76>
  {
    s_command.DataDTRMode      = HAL_XSPI_DATA_DTR_DISABLE;
7000718a:	2300      	movs	r3, #0
7000718c:	653b      	str	r3, [r7, #80]	@ 0x50
    s_command.DQSMode          = HAL_XSPI_DQS_DISABLE;
7000718e:	2300      	movs	r3, #0
70007190:	65bb      	str	r3, [r7, #88]	@ 0x58
70007192:	e001      	b.n	70007198 <SAL_XSPI_CommandSendReadAddress+0x7a>
  }
  else
  {
    s_command.DQSMode          = HAL_XSPI_DQS_DISABLE;
70007194:	2300      	movs	r3, #0
70007196:	65bb      	str	r3, [r7, #88]	@ 0x58
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70007198:	68fb      	ldr	r3, [r7, #12]
7000719a:	681b      	ldr	r3, [r3, #0]
7000719c:	f107 0110 	add.w	r1, r7, #16
700071a0:	2264      	movs	r2, #100	@ 0x64
700071a2:	4618      	mov	r0, r3
700071a4:	f7fe fe0a 	bl	70005dbc <HAL_XSPI_Command>
700071a8:	4603      	mov	r3, r0
700071aa:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f

  if (retr == HAL_OK)
700071ae:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
700071b2:	2b00      	cmp	r3, #0
700071b4:	d109      	bne.n	700071ca <SAL_XSPI_CommandSendReadAddress+0xac>
  {
    /* Retrieve data */
    retr = HAL_XSPI_Receive(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
700071b6:	68fb      	ldr	r3, [r7, #12]
700071b8:	681b      	ldr	r3, [r3, #0]
700071ba:	2264      	movs	r2, #100	@ 0x64
700071bc:	6839      	ldr	r1, [r7, #0]
700071be:	4618      	mov	r0, r3
700071c0:	f7fe feff 	bl	70005fc2 <HAL_XSPI_Receive>
700071c4:	4603      	mov	r3, r0
700071c6:	f887 305f 	strb.w	r3, [r7, #95]	@ 0x5f
  }

  if (retr != HAL_OK)
700071ca:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
700071ce:	2b00      	cmp	r3, #0
700071d0:	d004      	beq.n	700071dc <SAL_XSPI_CommandSendReadAddress+0xbe>
  {
    /* Abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
700071d2:	68fb      	ldr	r3, [r7, #12]
700071d4:	681b      	ldr	r3, [r3, #0]
700071d6:	4618      	mov	r0, r3
700071d8:	f7ff f820 	bl	7000621c <HAL_XSPI_Abort>
  }
  return retr;
700071dc:	f897 305f 	ldrb.w	r3, [r7, #95]	@ 0x5f
}
700071e0:	4618      	mov	r0, r3
700071e2:	3760      	adds	r7, #96	@ 0x60
700071e4:	46bd      	mov	sp, r7
700071e6:	bd80      	pop	{r7, pc}

700071e8 <SAL_XSPI_CheckStatusRegister>:
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_CheckStatusRegister(SAL_XSPI_ObjectTypeDef *SalXspi, uint8_t Command, uint32_t Address,
                                               uint8_t MatchValue, uint8_t MatchMask, uint8_t ManuId,
                                               uint32_t Timeout)
{
700071e8:	b580      	push	{r7, lr}
700071ea:	b09e      	sub	sp, #120	@ 0x78
700071ec:	af00      	add	r7, sp, #0
700071ee:	60f8      	str	r0, [r7, #12]
700071f0:	607a      	str	r2, [r7, #4]
700071f2:	461a      	mov	r2, r3
700071f4:	460b      	mov	r3, r1
700071f6:	72fb      	strb	r3, [r7, #11]
700071f8:	4613      	mov	r3, r2
700071fa:	72bb      	strb	r3, [r7, #10]
  XSPI_RegularCmdTypeDef s_command = SalXspi->Commandbase;
700071fc:	68fb      	ldr	r3, [r7, #12]
700071fe:	f107 0028 	add.w	r0, r7, #40	@ 0x28
70007202:	3304      	adds	r3, #4
70007204:	224c      	movs	r2, #76	@ 0x4c
70007206:	4619      	mov	r1, r3
70007208:	f002 f835 	bl	70009276 <memcpy>
  XSPI_AutoPollingTypeDef  s_config =
7000720c:	7abb      	ldrb	r3, [r7, #10]
7000720e:	617b      	str	r3, [r7, #20]
70007210:	f897 3080 	ldrb.w	r3, [r7, #128]	@ 0x80
70007214:	61bb      	str	r3, [r7, #24]
70007216:	2300      	movs	r3, #0
70007218:	61fb      	str	r3, [r7, #28]
7000721a:	f44f 0380 	mov.w	r3, #4194304	@ 0x400000
7000721e:	623b      	str	r3, [r7, #32]
70007220:	2310      	movs	r3, #16
70007222:	627b      	str	r3, [r7, #36]	@ 0x24
    .IntervalTime  = 0x10
  };
  HAL_StatusTypeDef retr;

  /* Initialize the reading of status register */
  s_command.Instruction = XSPI_FormatCommand(SalXspi->CommandExtension, s_command.InstructionWidth, Command);
70007224:	68fb      	ldr	r3, [r7, #12]
70007226:	f893 3050 	ldrb.w	r3, [r3, #80]	@ 0x50
7000722a:	6bb9      	ldr	r1, [r7, #56]	@ 0x38
7000722c:	7afa      	ldrb	r2, [r7, #11]
7000722e:	4618      	mov	r0, r3
70007230:	f000 f8aa 	bl	70007388 <XSPI_FormatCommand>
70007234:	4603      	mov	r3, r0
70007236:	633b      	str	r3, [r7, #48]	@ 0x30

  s_command.DataLength     = 1u;
70007238:	2301      	movs	r3, #1
7000723a:	667b      	str	r3, [r7, #100]	@ 0x64
  s_command.DQSMode        = HAL_XSPI_DQS_DISABLE;
7000723c:	2300      	movs	r3, #0
7000723e:	673b      	str	r3, [r7, #112]	@ 0x70

  if (s_command.InstructionMode == HAL_XSPI_INSTRUCTION_1_LINE)
70007240:	6b7b      	ldr	r3, [r7, #52]	@ 0x34
70007242:	2b01      	cmp	r3, #1
70007244:	d106      	bne.n	70007254 <SAL_XSPI_CheckStatusRegister+0x6c>
  {
    /* Specific behavior for Cypress to force 1 line on status read */
    s_command.DataMode    = HAL_XSPI_DATA_1_LINE;
70007246:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
7000724a:	663b      	str	r3, [r7, #96]	@ 0x60
    s_command.AddressMode = HAL_XSPI_DATA_NONE;
7000724c:	2300      	movs	r3, #0
7000724e:	647b      	str	r3, [r7, #68]	@ 0x44
    s_command.DummyCycles = 0u;
70007250:	2300      	movs	r3, #0
70007252:	66fb      	str	r3, [r7, #108]	@ 0x6c
  }

  /* Address is used only in 8 LINES format */
  if (s_command.DataMode == HAL_XSPI_DATA_8_LINES)
70007254:	6e3b      	ldr	r3, [r7, #96]	@ 0x60
70007256:	f1b3 6f80 	cmp.w	r3, #67108864	@ 0x4000000
7000725a:	d114      	bne.n	70007286 <SAL_XSPI_CheckStatusRegister+0x9e>
  {
    /* Specific case for Macronix memories : RDID and RDCR are not Data DTR  */
    if ((ManuId == EXTMEM_MANUFACTURER_MACRONIX) && (s_command.DataDTRMode == HAL_XSPI_DATA_DTR_ENABLE))
7000725c:	f897 3084 	ldrb.w	r3, [r7, #132]	@ 0x84
70007260:	2bc2      	cmp	r3, #194	@ 0xc2
70007262:	d108      	bne.n	70007276 <SAL_XSPI_CheckStatusRegister+0x8e>
70007264:	6ebb      	ldr	r3, [r7, #104]	@ 0x68
70007266:	f1b3 6f00 	cmp.w	r3, #134217728	@ 0x8000000
7000726a:	d104      	bne.n	70007276 <SAL_XSPI_CheckStatusRegister+0x8e>
    {
      s_command.DQSMode        = HAL_XSPI_DQS_ENABLE;
7000726c:	f04f 5300 	mov.w	r3, #536870912	@ 0x20000000
70007270:	673b      	str	r3, [r7, #112]	@ 0x70
      s_command.DataDTRMode    = HAL_XSPI_DATA_DTR_DISABLE;
70007272:	2300      	movs	r3, #0
70007274:	66bb      	str	r3, [r7, #104]	@ 0x68
    }
    s_command.AddressMode    = HAL_XSPI_ADDRESS_8_LINES;
70007276:	f44f 6380 	mov.w	r3, #1024	@ 0x400
7000727a:	647b      	str	r3, [r7, #68]	@ 0x44
    s_command.AddressWidth   = HAL_XSPI_ADDRESS_32_BITS;
7000727c:	f44f 5340 	mov.w	r3, #12288	@ 0x3000
70007280:	64bb      	str	r3, [r7, #72]	@ 0x48
    s_command.Address        = Address;
70007282:	687b      	ldr	r3, [r7, #4]
70007284:	643b      	str	r3, [r7, #64]	@ 0x40
  }

  /* Send the command */
  retr = HAL_XSPI_Command(SalXspi->hxspi, &s_command, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
70007286:	68fb      	ldr	r3, [r7, #12]
70007288:	681b      	ldr	r3, [r3, #0]
7000728a:	f107 0128 	add.w	r1, r7, #40	@ 0x28
7000728e:	2264      	movs	r2, #100	@ 0x64
70007290:	4618      	mov	r0, r3
70007292:	f7fe fd93 	bl	70005dbc <HAL_XSPI_Command>
70007296:	4603      	mov	r3, r0
70007298:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
  if (retr == HAL_OK)
7000729c:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
700072a0:	2b00      	cmp	r3, #0
700072a2:	d10b      	bne.n	700072bc <SAL_XSPI_CheckStatusRegister+0xd4>
  {
    retr = HAL_XSPI_AutoPolling(SalXspi->hxspi, &s_config, Timeout);
700072a4:	68fb      	ldr	r3, [r7, #12]
700072a6:	681b      	ldr	r3, [r3, #0]
700072a8:	f107 0114 	add.w	r1, r7, #20
700072ac:	f8d7 2088 	ldr.w	r2, [r7, #136]	@ 0x88
700072b0:	4618      	mov	r0, r3
700072b2:	f7fe ff29 	bl	70006108 <HAL_XSPI_AutoPolling>
700072b6:	4603      	mov	r3, r0
700072b8:	f887 3077 	strb.w	r3, [r7, #119]	@ 0x77
    DEBUG_AUTOPOLLING(SalXspi->hxspi->Instance->DR, s_config.MatchValue, s_config.MatchMask)
  }

  if (retr != HAL_OK)
700072bc:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
700072c0:	2b00      	cmp	r3, #0
700072c2:	d004      	beq.n	700072ce <SAL_XSPI_CheckStatusRegister+0xe6>
  {
    /* Abort any ongoing transaction for the next action */
    (void)HAL_XSPI_Abort(SalXspi->hxspi);
700072c4:	68fb      	ldr	r3, [r7, #12]
700072c6:	681b      	ldr	r3, [r3, #0]
700072c8:	4618      	mov	r0, r3
700072ca:	f7fe ffa7 	bl	7000621c <HAL_XSPI_Abort>
  }
  return retr;
700072ce:	f897 3077 	ldrb.w	r3, [r7, #119]	@ 0x77
}
700072d2:	4618      	mov	r0, r3
700072d4:	3778      	adds	r7, #120	@ 0x78
700072d6:	46bd      	mov	sp, r7
700072d8:	bd80      	pop	{r7, pc}

700072da <SAL_XSPI_DisableMapMode>:
  * @brief This function disables the memory mapped mode
  * @param SalXspi SAL XSPI handle
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_DisableMapMode(SAL_XSPI_ObjectTypeDef *SalXspi)
{
700072da:	b580      	push	{r7, lr}
700072dc:	b082      	sub	sp, #8
700072de:	af00      	add	r7, sp, #0
700072e0:	6078      	str	r0, [r7, #4]
  __ASM volatile ("dsb 0xF":::"memory");
700072e2:	f3bf 8f4f 	dsb	sy
}
700072e6:	bf00      	nop
  __DSB();
  return HAL_XSPI_Abort(SalXspi->hxspi);
700072e8:	687b      	ldr	r3, [r7, #4]
700072ea:	681b      	ldr	r3, [r3, #0]
700072ec:	4618      	mov	r0, r3
700072ee:	f7fe ff95 	bl	7000621c <HAL_XSPI_Abort>
700072f2:	4603      	mov	r3, r0
}
700072f4:	4618      	mov	r0, r3
700072f6:	3708      	adds	r7, #8
700072f8:	46bd      	mov	sp, r7
700072fa:	bd80      	pop	{r7, pc}

700072fc <SAL_XSPI_UpdateMemoryType>:
  * @param SalXspi SAL XSPI handle
  * @param DataOrder Selected data order
  * @return @ref HAL_StatusTypeDef
  **/
HAL_StatusTypeDef SAL_XSPI_UpdateMemoryType(SAL_XSPI_ObjectTypeDef *SalXspi, SAL_XSPI_DataOrderTypeDef DataOrder)
{
700072fc:	b480      	push	{r7}
700072fe:	b085      	sub	sp, #20
70007300:	af00      	add	r7, sp, #0
70007302:	6078      	str	r0, [r7, #4]
70007304:	460b      	mov	r3, r1
70007306:	70fb      	strb	r3, [r7, #3]
  HAL_StatusTypeDef retr = HAL_OK;
70007308:	2300      	movs	r3, #0
7000730a:	73fb      	strb	r3, [r7, #15]

  /* Read the memory type value */
  uint32_t memorytype = READ_REG(SalXspi->hxspi->Instance->DCR1) & XSPI_DCR1_MTYP;
7000730c:	687b      	ldr	r3, [r7, #4]
7000730e:	681b      	ldr	r3, [r3, #0]
70007310:	681b      	ldr	r3, [r3, #0]
70007312:	689b      	ldr	r3, [r3, #8]
70007314:	f003 63e0 	and.w	r3, r3, #117440512	@ 0x7000000
70007318:	60bb      	str	r3, [r7, #8]

  switch (DataOrder)
7000731a:	78fb      	ldrb	r3, [r7, #3]
7000731c:	2b00      	cmp	r3, #0
7000731e:	d11e      	bne.n	7000735e <SAL_XSPI_UpdateMemoryType+0x62>
  {
    case SAL_XSPI_ORDERINVERTED :
      if (memorytype == HAL_XSPI_MEMTYPE_MICRON)
70007320:	68bb      	ldr	r3, [r7, #8]
70007322:	2b00      	cmp	r3, #0
70007324:	d103      	bne.n	7000732e <SAL_XSPI_UpdateMemoryType+0x32>
      {
        memorytype = HAL_XSPI_MEMTYPE_MACRONIX;
70007326:	f04f 7380 	mov.w	r3, #16777216	@ 0x1000000
7000732a:	60bb      	str	r3, [r7, #8]
7000732c:	e008      	b.n	70007340 <SAL_XSPI_UpdateMemoryType+0x44>
      }
      else if (memorytype == HAL_XSPI_MEMTYPE_MACRONIX)
7000732e:	68bb      	ldr	r3, [r7, #8]
70007330:	f1b3 7f80 	cmp.w	r3, #16777216	@ 0x1000000
70007334:	d102      	bne.n	7000733c <SAL_XSPI_UpdateMemoryType+0x40>
      {
        memorytype = HAL_XSPI_MEMTYPE_MICRON;
70007336:	2300      	movs	r3, #0
70007338:	60bb      	str	r3, [r7, #8]
7000733a:	e001      	b.n	70007340 <SAL_XSPI_UpdateMemoryType+0x44>
      }
      else
      {
        retr = HAL_ERROR;
7000733c:	2301      	movs	r3, #1
7000733e:	73fb      	strb	r3, [r7, #15]
      }
      MODIFY_REG(SalXspi->hxspi->Instance->DCR1, XSPI_DCR1_MTYP, memorytype);
70007340:	687b      	ldr	r3, [r7, #4]
70007342:	681b      	ldr	r3, [r3, #0]
70007344:	681b      	ldr	r3, [r3, #0]
70007346:	689b      	ldr	r3, [r3, #8]
70007348:	f023 61e0 	bic.w	r1, r3, #117440512	@ 0x7000000
7000734c:	687b      	ldr	r3, [r7, #4]
7000734e:	681b      	ldr	r3, [r3, #0]
70007350:	681b      	ldr	r3, [r3, #0]
70007352:	68ba      	ldr	r2, [r7, #8]
70007354:	430a      	orrs	r2, r1
70007356:	609a      	str	r2, [r3, #8]
      break;
70007358:	bf00      	nop

  DEBUG_PARAM_BEGIN();
  DEBUG_PARAM_DATA("::SAL_XSPI_UpdateMemoryType::");
  DEBUG_PARAM_INT(memorytype);
  DEBUG_PARAM_END();
  return retr;
7000735a:	7bfb      	ldrb	r3, [r7, #15]
7000735c:	e000      	b.n	70007360 <SAL_XSPI_UpdateMemoryType+0x64>
      return HAL_ERROR;
7000735e:	2301      	movs	r3, #1
}
70007360:	4618      	mov	r0, r3
70007362:	3714      	adds	r7, #20
70007364:	46bd      	mov	sp, r7
70007366:	f85d 7b04 	ldr.w	r7, [sp], #4
7000736a:	4770      	bx	lr

7000736c <SAL_XSPI_Abort>:

HAL_StatusTypeDef SAL_XSPI_Abort(SAL_XSPI_ObjectTypeDef *SalXspi)
{
7000736c:	b580      	push	{r7, lr}
7000736e:	b082      	sub	sp, #8
70007370:	af00      	add	r7, sp, #0
70007372:	6078      	str	r0, [r7, #4]
  return HAL_XSPI_Abort(SalXspi->hxspi);
70007374:	687b      	ldr	r3, [r7, #4]
70007376:	681b      	ldr	r3, [r3, #0]
70007378:	4618      	mov	r0, r3
7000737a:	f7fe ff4f 	bl	7000621c <HAL_XSPI_Abort>
7000737e:	4603      	mov	r3, r0
}
70007380:	4618      	mov	r0, r3
70007382:	3708      	adds	r7, #8
70007384:	46bd      	mov	sp, r7
70007386:	bd80      	pop	{r7, pc}

70007388 <XSPI_FormatCommand>:
  * @param InstructionWidth Instruction width
  * @param Command Command
  * @return Formatted command
  */
uint16_t XSPI_FormatCommand(uint8_t CommandExtension, uint32_t InstructionWidth, uint8_t Command)
{
70007388:	b480      	push	{r7}
7000738a:	b085      	sub	sp, #20
7000738c:	af00      	add	r7, sp, #0
7000738e:	4603      	mov	r3, r0
70007390:	6039      	str	r1, [r7, #0]
70007392:	71fb      	strb	r3, [r7, #7]
70007394:	4613      	mov	r3, r2
70007396:	71bb      	strb	r3, [r7, #6]
  uint16_t retr;
  if (InstructionWidth == HAL_XSPI_INSTRUCTION_16_BITS)
70007398:	683b      	ldr	r3, [r7, #0]
7000739a:	2b10      	cmp	r3, #16
7000739c:	d114      	bne.n	700073c8 <XSPI_FormatCommand+0x40>
    /* 0b00 Command Extension is the same as the Command.
            (Command / Command Extension has the same value for the whole clock period. */
    /* 0b01 Command Extension is the inverse of the Command.
            Command Extension acts as a confirmation of the Command */
    /* 0b11 Command and Command Extension forms a 16 bit command word :: Not yet handled */
    retr = ((uint16_t)Command << 8u);
7000739e:	79bb      	ldrb	r3, [r7, #6]
700073a0:	b29b      	uxth	r3, r3
700073a2:	021b      	lsls	r3, r3, #8
700073a4:	81fb      	strh	r3, [r7, #14]
    if (CommandExtension == 1u)
700073a6:	79fb      	ldrb	r3, [r7, #7]
700073a8:	2b01      	cmp	r3, #1
700073aa:	d107      	bne.n	700073bc <XSPI_FormatCommand+0x34>
    {
      retr |= (uint8_t)(~Command & 0xFFu);
700073ac:	79bb      	ldrb	r3, [r7, #6]
700073ae:	43db      	mvns	r3, r3
700073b0:	b2db      	uxtb	r3, r3
700073b2:	461a      	mov	r2, r3
700073b4:	89fb      	ldrh	r3, [r7, #14]
700073b6:	4313      	orrs	r3, r2
700073b8:	81fb      	strh	r3, [r7, #14]
700073ba:	e007      	b.n	700073cc <XSPI_FormatCommand+0x44>
    }
    else
    {
      retr |= (uint8_t)(Command & 0xFFu);
700073bc:	79bb      	ldrb	r3, [r7, #6]
700073be:	b29a      	uxth	r2, r3
700073c0:	89fb      	ldrh	r3, [r7, #14]
700073c2:	4313      	orrs	r3, r2
700073c4:	81fb      	strh	r3, [r7, #14]
700073c6:	e001      	b.n	700073cc <XSPI_FormatCommand+0x44>
    }
  }
  else
  {
    retr = Command;
700073c8:	79bb      	ldrb	r3, [r7, #6]
700073ca:	81fb      	strh	r3, [r7, #14]
  }

  return retr;
700073cc:	89fb      	ldrh	r3, [r7, #14]
}
700073ce:	4618      	mov	r0, r3
700073d0:	3714      	adds	r7, #20
700073d2:	46bd      	mov	sp, r7
700073d4:	f85d 7b04 	ldr.w	r7, [sp], #4
700073d8:	4770      	bx	lr

700073da <XSPI_Transmit>:
  * @param SalXspi SAL XSPI Handle
  * @param Data Data pointer
  * @return Status of the command execution
  */
HAL_StatusTypeDef XSPI_Transmit(SAL_XSPI_ObjectTypeDef *SalXspi, const uint8_t *Data)
{
700073da:	b580      	push	{r7, lr}
700073dc:	b084      	sub	sp, #16
700073de:	af00      	add	r7, sp, #0
700073e0:	6078      	str	r0, [r7, #4]
700073e2:	6039      	str	r1, [r7, #0]
#if defined (USE_HAL_XSPI_REGISTER_CALLBACKS) && (USE_HAL_XSPI_REGISTER_CALLBACKS == 1U)
  if (SalXspi->hxspi->hdmatx == NULL)
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */
  {
    /* Transmit data */
    retr = HAL_XSPI_Transmit(SalXspi->hxspi, Data, SAL_XSPI_TIMEOUT_DEFAULT_VALUE);
700073e4:	687b      	ldr	r3, [r7, #4]
700073e6:	681b      	ldr	r3, [r3, #0]
700073e8:	2264      	movs	r2, #100	@ 0x64
700073ea:	6839      	ldr	r1, [r7, #0]
700073ec:	4618      	mov	r0, r3
700073ee:	f7fe fd75 	bl	70005edc <HAL_XSPI_Transmit>
700073f2:	4603      	mov	r3, r0
700073f4:	73fb      	strb	r3, [r7, #15]
      }
    }
  }
#endif /* USE_HAL_XSPI_REGISTER_CALLBACKS */

  return retr;
700073f6:	7bfb      	ldrb	r3, [r7, #15]
}
700073f8:	4618      	mov	r0, r3
700073fa:	3710      	adds	r7, #16
700073fc:	46bd      	mov	sp, r7
700073fe:	bd80      	pop	{r7, pc}

70007400 <SFDP_ReadHeader>:
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @param sfdp_header Pointer to the SFDP header structure to be filled.
  * @retval SFDP_StatusTypeDef Status of the operation: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef SFDP_ReadHeader(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, SFDP_HeaderTypeDef *sfdp_header)
{
70007400:	b580      	push	{r7, lr}
70007402:	b084      	sub	sp, #16
70007404:	af00      	add	r7, sp, #0
70007406:	6078      	str	r0, [r7, #4]
70007408:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr;
  uint8_t retry_counter = 0;
7000740a:	2300      	movs	r3, #0
7000740c:	73bb      	strb	r3, [r7, #14]
  SFDP_DEBUG_STR(__func__);

  do
  {
    /* Reset the signature value */
    sfdp_header->Signature = 0;
7000740e:	683b      	ldr	r3, [r7, #0]
70007410:	2200      	movs	r2, #0
70007412:	601a      	str	r2, [r3, #0]

    /* send the SFDP command to read the header */
    if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject, 0, (uint8_t *)sfdp_header, SFDP_HEADER_SIZE))
70007414:	687b      	ldr	r3, [r7, #4]
70007416:	f103 0008 	add.w	r0, r3, #8
7000741a:	2308      	movs	r3, #8
7000741c:	683a      	ldr	r2, [r7, #0]
7000741e:	2100      	movs	r1, #0
70007420:	f7ff fcac 	bl	70006d7c <SAL_XSPI_GetSFDP>
70007424:	4603      	mov	r3, r0
70007426:	2b00      	cmp	r3, #0
70007428:	d002      	beq.n	70007430 <SFDP_ReadHeader+0x30>
    {
      retr = EXTMEM_SFDP_ERROR_SFDPREAD;
7000742a:	2303      	movs	r3, #3
7000742c:	73fb      	strb	r3, [r7, #15]
      goto error;
7000742e:	e01f      	b.n	70007470 <SFDP_ReadHeader+0x70>
    }

    /* view the header signature value  */
    SFDP_DEBUG_INT("SFDP signature::", sfdp_header->Signature);

    switch (CheckSFDP_Signature(Object, sfdp_header->Signature))
70007430:	683b      	ldr	r3, [r7, #0]
70007432:	681b      	ldr	r3, [r3, #0]
70007434:	4619      	mov	r1, r3
70007436:	6878      	ldr	r0, [r7, #4]
70007438:	f001 fcac 	bl	70008d94 <CheckSFDP_Signature>
7000743c:	4603      	mov	r3, r0
7000743e:	2b00      	cmp	r3, #0
70007440:	d002      	beq.n	70007448 <SFDP_ReadHeader+0x48>
70007442:	2b05      	cmp	r3, #5
70007444:	d005      	beq.n	70007452 <SFDP_ReadHeader+0x52>
70007446:	e00a      	b.n	7000745e <SFDP_ReadHeader+0x5e>
    {
      case EXTMEM_SFDP_OK:
        SFDP_DEBUG_INT("param_number=", sfdp_header->param_number);
        SFDP_DEBUG_INT("AccessProtocol=", sfdp_header->AccessProtocol);
        retr = EXTMEM_SFDP_OK;
70007448:	2300      	movs	r3, #0
7000744a:	73fb      	strb	r3, [r7, #15]
        retry_counter = 2u;
7000744c:	2302      	movs	r3, #2
7000744e:	73bb      	strb	r3, [r7, #14]
        break;
70007450:	e00a      	b.n	70007468 <SFDP_ReadHeader+0x68>
      case EXTMEM_SFDP_ERROR_SIGNATUREMTYPE:
        retr = EXTMEM_SFDP_ERROR_SIGNATURE;
70007452:	2304      	movs	r3, #4
70007454:	73fb      	strb	r3, [r7, #15]
        retry_counter++;
70007456:	7bbb      	ldrb	r3, [r7, #14]
70007458:	3301      	adds	r3, #1
7000745a:	73bb      	strb	r3, [r7, #14]
        break;
7000745c:	e004      	b.n	70007468 <SFDP_ReadHeader+0x68>
      /* case EXTMEM_SFDP_ERROR_SIGNATURE :*/
      default :
        retr = EXTMEM_SFDP_ERROR_SIGNATURE;
7000745e:	2304      	movs	r3, #4
70007460:	73fb      	strb	r3, [r7, #15]
        retry_counter = 2u;
70007462:	2302      	movs	r3, #2
70007464:	73bb      	strb	r3, [r7, #14]
        break;
70007466:	bf00      	nop
    }
  } while (retry_counter < 2u);
70007468:	7bbb      	ldrb	r3, [r7, #14]
7000746a:	2b01      	cmp	r3, #1
7000746c:	d9cf      	bls.n	7000740e <SFDP_ReadHeader+0xe>

error:
7000746e:	bf00      	nop
  return retr;
70007470:	7bfb      	ldrb	r3, [r7, #15]
}
70007472:	4618      	mov	r0, r3
70007474:	3710      	adds	r7, #16
70007476:	46bd      	mov	sp, r7
70007478:	bd80      	pop	{r7, pc}
	...

7000747c <SFDP_GetHeader>:
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @param sfdp_header Pointer to the SFDP header structure to be filled.
  * @retval SFDP_StatusTypeDef Status of the operation: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef SFDP_GetHeader(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, SFDP_HeaderTypeDef *sfdp_header)
{
7000747c:	b590      	push	{r4, r7, lr}
7000747e:	b089      	sub	sp, #36	@ 0x24
70007480:	af00      	add	r7, sp, #0
70007482:	6078      	str	r0, [r7, #4]
70007484:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_SIGNATURE;
70007486:	2304      	movs	r3, #4
70007488:	77fb      	strb	r3, [r7, #31]
  SFDP_DEBUG_STR(__func__);
  const TableConfig_t table_config[] =
7000748a:	4b2a      	ldr	r3, [pc, #168]	@ (70007534 <SFDP_GetHeader+0xb8>)
7000748c:	f107 040c 	add.w	r4, r7, #12
70007490:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
70007492:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
    {PHY_LINK_8D8D8D, 10u},
    {PHY_LINK_8D8D8D, 16u}
  };

  /* Loop to find the link configuration of the memory */
  for (uint8_t index = 0u;
70007496:	2300      	movs	r3, #0
70007498:	77bb      	strb	r3, [r7, #30]
7000749a:	e040      	b.n	7000751e <SFDP_GetHeader+0xa2>
  {
    /* Set the command mode */
    SFDP_DEBUG_STR("try a command configuration");

    /* Configure the link */
    Object->sfdp_private.DriverInfo.SpiPhyLink  = table_config[index].PhyLink;
7000749c:	7fbb      	ldrb	r3, [r7, #30]
7000749e:	005b      	lsls	r3, r3, #1
700074a0:	3320      	adds	r3, #32
700074a2:	443b      	add	r3, r7
700074a4:	f813 2c14 	ldrb.w	r2, [r3, #-20]
700074a8:	687b      	ldr	r3, [r7, #4]
700074aa:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
    (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
700074ae:	687b      	ldr	r3, [r7, #4]
700074b0:	f103 0008 	add.w	r0, r3, #8
                                &Object->sfdp_private.DriverInfo.SpiPhyLink);
700074b4:	687b      	ldr	r3, [r7, #4]
700074b6:	3364      	adds	r3, #100	@ 0x64
    (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
700074b8:	461a      	mov	r2, r3
700074ba:	2100      	movs	r1, #0
700074bc:	f7ff fb0c 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
    SAL_XSPI_SET_SFDPDUMMYCYLE(Object->sfdp_private.SALObject, table_config[index].DummyCycle);
700074c0:	7fbb      	ldrb	r3, [r7, #30]
700074c2:	005b      	lsls	r3, r3, #1
700074c4:	3320      	adds	r3, #32
700074c6:	443b      	add	r3, r7
700074c8:	f813 2c13 	ldrb.w	r2, [r3, #-19]
700074cc:	687b      	ldr	r3, [r7, #4]
700074ce:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59

    /* Loop on the instruction extension */
    for (uint8_t IExt = 0u;
700074d2:	2300      	movs	r3, #0
700074d4:	777b      	strb	r3, [r7, #29]
700074d6:	e017      	b.n	70007508 <SFDP_GetHeader+0x8c>
         (IExt < 2u) && (retr == EXTMEM_SFDP_ERROR_SIGNATURE); IExt++)
    {
      SAL_XSPI_SET_COMMANDEXTENSION(Object->sfdp_private.SALObject, IExt);
700074d8:	687b      	ldr	r3, [r7, #4]
700074da:	7f7a      	ldrb	r2, [r7, #29]
700074dc:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
      /* Read the sfdp header */
      if (EXTMEM_SFDP_OK == SFDP_ReadHeader(Object, sfdp_header))
700074e0:	6839      	ldr	r1, [r7, #0]
700074e2:	6878      	ldr	r0, [r7, #4]
700074e4:	f7ff ff8c 	bl	70007400 <SFDP_ReadHeader>
700074e8:	4603      	mov	r3, r0
700074ea:	2b00      	cmp	r3, #0
700074ec:	d101      	bne.n	700074f2 <SFDP_GetHeader+0x76>
      {
        retr = EXTMEM_SFDP_OK;
700074ee:	2300      	movs	r3, #0
700074f0:	77fb      	strb	r3, [r7, #31]
      }

      if (table_config[index].PhyLink < PHY_LINK_4S4S4S)
700074f2:	7fbb      	ldrb	r3, [r7, #30]
700074f4:	005b      	lsls	r3, r3, #1
700074f6:	3320      	adds	r3, #32
700074f8:	443b      	add	r3, r7
700074fa:	f813 3c14 	ldrb.w	r3, [r3, #-20]
700074fe:	2b03      	cmp	r3, #3
70007500:	d909      	bls.n	70007516 <SFDP_GetHeader+0x9a>
         (IExt < 2u) && (retr == EXTMEM_SFDP_ERROR_SIGNATURE); IExt++)
70007502:	7f7b      	ldrb	r3, [r7, #29]
70007504:	3301      	adds	r3, #1
70007506:	777b      	strb	r3, [r7, #29]
70007508:	7f7b      	ldrb	r3, [r7, #29]
7000750a:	2b01      	cmp	r3, #1
7000750c:	d804      	bhi.n	70007518 <SFDP_GetHeader+0x9c>
7000750e:	7ffb      	ldrb	r3, [r7, #31]
70007510:	2b04      	cmp	r3, #4
70007512:	d0e1      	beq.n	700074d8 <SFDP_GetHeader+0x5c>
70007514:	e000      	b.n	70007518 <SFDP_GetHeader+0x9c>
      {
        /* Config 1 is invalid so exit the loop */
        break;
70007516:	bf00      	nop
       ; index++)
70007518:	7fbb      	ldrb	r3, [r7, #30]
7000751a:	3301      	adds	r3, #1
7000751c:	77bb      	strb	r3, [r7, #30]
       (index < (sizeof(table_config) / sizeof(TableConfig_t))) &&
7000751e:	7fbb      	ldrb	r3, [r7, #30]
70007520:	2b07      	cmp	r3, #7
70007522:	d802      	bhi.n	7000752a <SFDP_GetHeader+0xae>
70007524:	7ffb      	ldrb	r3, [r7, #31]
70007526:	2b04      	cmp	r3, #4
70007528:	d0b8      	beq.n	7000749c <SFDP_GetHeader+0x20>
      }
    }
  }
  return retr;
7000752a:	7ffb      	ldrb	r3, [r7, #31]
}
7000752c:	4618      	mov	r0, r3
7000752e:	3724      	adds	r7, #36	@ 0x24
70007530:	46bd      	mov	sp, r7
70007532:	bd90      	pop	{r4, r7, pc}
70007534:	70009e28 	.word	0x70009e28

70007538 <SFDP_CollectData>:
  * @brief Collects all SFDP parameter table information and builds driver data.
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @retval SFDP_StatusTypeDef Status of the operation: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef SFDP_CollectData(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
70007538:	b580      	push	{r7, lr}
7000753a:	b088      	sub	sp, #32
7000753c:	af00      	add	r7, sp, #0
7000753e:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
70007540:	2300      	movs	r3, #0
70007542:	77fb      	strb	r3, [r7, #31]
  uint32_t sfdp_address = SFDP_HEADER_SIZE;
70007544:	2308      	movs	r3, #8
70007546:	61bb      	str	r3, [r7, #24]
  SFDP_DEBUG_STR(__func__);

  /* Reset the table mask */
  Object->sfdp_private.Sfdp_table_mask = 0;
70007548:	687b      	ldr	r3, [r7, #4]
7000754a:	2200      	movs	r2, #0
7000754c:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94

  /* Reset the param info */
  (void)memset(sfdp_param_info, 0x0, sizeof(sfdp_param_info));
70007550:	2278      	movs	r2, #120	@ 0x78
70007552:	2100      	movs	r1, #0
70007554:	485f      	ldr	r0, [pc, #380]	@ (700076d4 <SFDP_CollectData+0x19c>)
70007556:	f001 fe12 	bl	7000917e <memset>

  /* Get the table param info */
  for (uint8_t index = 0u; index < (Object->sfdp_private.Sfdp_param_number + 1u); index++)
7000755a:	2300      	movs	r3, #0
7000755c:	75fb      	strb	r3, [r7, #23]
7000755e:	e027      	b.n	700075b0 <SFDP_CollectData+0x78>
  {
    CHECK_FUNCTION_CALL(sfdp_get_paraminfo(Object, sfdp_address, &sfdp_param_info[index]))
70007560:	7dfa      	ldrb	r2, [r7, #23]
70007562:	4613      	mov	r3, r2
70007564:	005b      	lsls	r3, r3, #1
70007566:	4413      	add	r3, r2
70007568:	009b      	lsls	r3, r3, #2
7000756a:	4a5a      	ldr	r2, [pc, #360]	@ (700076d4 <SFDP_CollectData+0x19c>)
7000756c:	4413      	add	r3, r2
7000756e:	461a      	mov	r2, r3
70007570:	69b9      	ldr	r1, [r7, #24]
70007572:	6878      	ldr	r0, [r7, #4]
70007574:	f001 f84e 	bl	70008614 <sfdp_get_paraminfo>
70007578:	4603      	mov	r3, r0
7000757a:	77fb      	strb	r3, [r7, #31]
7000757c:	7ffb      	ldrb	r3, [r7, #31]
7000757e:	2b00      	cmp	r3, #0
70007580:	f040 80a2 	bne.w	700076c8 <SFDP_CollectData+0x190>
    Object->sfdp_private.Sfdp_table_mask |= (uint32_t)sfdp_param_info[index].type;
70007584:	687b      	ldr	r3, [r7, #4]
70007586:	f8d3 1094 	ldr.w	r1, [r3, #148]	@ 0x94
7000758a:	7dfa      	ldrb	r2, [r7, #23]
7000758c:	4851      	ldr	r0, [pc, #324]	@ (700076d4 <SFDP_CollectData+0x19c>)
7000758e:	4613      	mov	r3, r2
70007590:	005b      	lsls	r3, r3, #1
70007592:	4413      	add	r3, r2
70007594:	009b      	lsls	r3, r3, #2
70007596:	4403      	add	r3, r0
70007598:	681b      	ldr	r3, [r3, #0]
7000759a:	ea41 0203 	orr.w	r2, r1, r3
7000759e:	687b      	ldr	r3, [r7, #4]
700075a0:	f8c3 2094 	str.w	r2, [r3, #148]	@ 0x94
    sfdp_address += SFDP_PARAM_HEADER_SIZE;
700075a4:	69bb      	ldr	r3, [r7, #24]
700075a6:	3308      	adds	r3, #8
700075a8:	61bb      	str	r3, [r7, #24]
  for (uint8_t index = 0u; index < (Object->sfdp_private.Sfdp_param_number + 1u); index++)
700075aa:	7dfb      	ldrb	r3, [r7, #23]
700075ac:	3301      	adds	r3, #1
700075ae:	75fb      	strb	r3, [r7, #23]
700075b0:	7dfa      	ldrb	r2, [r7, #23]
700075b2:	687b      	ldr	r3, [r7, #4]
700075b4:	f893 309c 	ldrb.w	r3, [r3, #156]	@ 0x9c
700075b8:	3301      	adds	r3, #1
700075ba:	429a      	cmp	r2, r3
700075bc:	d3d0      	bcc.n	70007560 <SFDP_CollectData+0x28>
  }

  /* Read each table param to extract the information to build the driver */
  for (uint8_t index = 0u; sfdp_param_info[index].type != SFDP_PARAMID_UNKNOWN; index++)
700075be:	2300      	movs	r3, #0
700075c0:	75bb      	strb	r3, [r7, #22]
700075c2:	e075      	b.n	700076b0 <SFDP_CollectData+0x178>
  {
    uint8_t *ptr = NULL;
700075c4:	2300      	movs	r3, #0
700075c6:	613b      	str	r3, [r7, #16]
    uint32_t size = sfdp_param_info[index].size;
700075c8:	7dba      	ldrb	r2, [r7, #22]
700075ca:	4942      	ldr	r1, [pc, #264]	@ (700076d4 <SFDP_CollectData+0x19c>)
700075cc:	4613      	mov	r3, r2
700075ce:	005b      	lsls	r3, r3, #1
700075d0:	4413      	add	r3, r2
700075d2:	009b      	lsls	r3, r3, #2
700075d4:	440b      	add	r3, r1
700075d6:	3308      	adds	r3, #8
700075d8:	781b      	ldrb	r3, [r3, #0]
700075da:	60fb      	str	r3, [r7, #12]
    switch (sfdp_param_info[index].type)
700075dc:	7dba      	ldrb	r2, [r7, #22]
700075de:	493d      	ldr	r1, [pc, #244]	@ (700076d4 <SFDP_CollectData+0x19c>)
700075e0:	4613      	mov	r3, r2
700075e2:	005b      	lsls	r3, r3, #1
700075e4:	4413      	add	r3, r2
700075e6:	009b      	lsls	r3, r3, #2
700075e8:	440b      	add	r3, r1
700075ea:	681b      	ldr	r3, [r3, #0]
700075ec:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
700075f0:	d029      	beq.n	70007646 <SFDP_CollectData+0x10e>
700075f2:	f5b3 5f80 	cmp.w	r3, #4096	@ 0x1000
700075f6:	d829      	bhi.n	7000764c <SFDP_CollectData+0x114>
700075f8:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
700075fc:	d01d      	beq.n	7000763a <SFDP_CollectData+0x102>
700075fe:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70007602:	d823      	bhi.n	7000764c <SFDP_CollectData+0x114>
70007604:	2b80      	cmp	r3, #128	@ 0x80
70007606:	d01b      	beq.n	70007640 <SFDP_CollectData+0x108>
70007608:	2b80      	cmp	r3, #128	@ 0x80
7000760a:	d81f      	bhi.n	7000764c <SFDP_CollectData+0x114>
7000760c:	2b08      	cmp	r3, #8
7000760e:	d002      	beq.n	70007616 <SFDP_CollectData+0xde>
70007610:	2b40      	cmp	r3, #64	@ 0x40
70007612:	d00f      	beq.n	70007634 <SFDP_CollectData+0xfc>
      case SFDP_PARAMID_OCTAL_DDR:
        ptr = JEDEC_OctalDdr.data_BYTE;
        break;
      default :
        SFDP_DEBUG_STR("the table is not yet handled by the SW");
        break;
70007614:	e01a      	b.n	7000764c <SFDP_CollectData+0x114>
        JEDEC_Basic.size = sfdp_param_info[index].size;
70007616:	7dba      	ldrb	r2, [r7, #22]
70007618:	492e      	ldr	r1, [pc, #184]	@ (700076d4 <SFDP_CollectData+0x19c>)
7000761a:	4613      	mov	r3, r2
7000761c:	005b      	lsls	r3, r3, #1
7000761e:	4413      	add	r3, r2
70007620:	009b      	lsls	r3, r3, #2
70007622:	440b      	add	r3, r1
70007624:	3308      	adds	r3, #8
70007626:	781b      	ldrb	r3, [r3, #0]
70007628:	461a      	mov	r2, r3
7000762a:	4b2b      	ldr	r3, [pc, #172]	@ (700076d8 <SFDP_CollectData+0x1a0>)
7000762c:	601a      	str	r2, [r3, #0]
        ptr = JEDEC_Basic.Params.data_BYTE;
7000762e:	4b2b      	ldr	r3, [pc, #172]	@ (700076dc <SFDP_CollectData+0x1a4>)
70007630:	613b      	str	r3, [r7, #16]
        break;
70007632:	e00c      	b.n	7000764e <SFDP_CollectData+0x116>
        ptr = JEDEC_Address4Bytes.data_BYTE;
70007634:	4b2a      	ldr	r3, [pc, #168]	@ (700076e0 <SFDP_CollectData+0x1a8>)
70007636:	613b      	str	r3, [r7, #16]
        break;
70007638:	e009      	b.n	7000764e <SFDP_CollectData+0x116>
        ptr = JEDEC_SCCR_Map.data_b;
7000763a:	4b2a      	ldr	r3, [pc, #168]	@ (700076e4 <SFDP_CollectData+0x1ac>)
7000763c:	613b      	str	r3, [r7, #16]
        break;
7000763e:	e006      	b.n	7000764e <SFDP_CollectData+0x116>
        ptr = JEDEC_XSPI10.data_BYTE;
70007640:	4b29      	ldr	r3, [pc, #164]	@ (700076e8 <SFDP_CollectData+0x1b0>)
70007642:	613b      	str	r3, [r7, #16]
        break;
70007644:	e003      	b.n	7000764e <SFDP_CollectData+0x116>
        ptr = JEDEC_OctalDdr.data_BYTE;
70007646:	4b29      	ldr	r3, [pc, #164]	@ (700076ec <SFDP_CollectData+0x1b4>)
70007648:	613b      	str	r3, [r7, #16]
        break;
7000764a:	e000      	b.n	7000764e <SFDP_CollectData+0x116>
        break;
7000764c:	bf00      	nop
    }
    if (ptr != NULL)
7000764e:	693b      	ldr	r3, [r7, #16]
70007650:	2b00      	cmp	r3, #0
70007652:	d016      	beq.n	70007682 <SFDP_CollectData+0x14a>
    {
      if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
70007654:	687b      	ldr	r3, [r7, #4]
70007656:	f103 0008 	add.w	r0, r3, #8
7000765a:	7dba      	ldrb	r2, [r7, #22]
7000765c:	491d      	ldr	r1, [pc, #116]	@ (700076d4 <SFDP_CollectData+0x19c>)
7000765e:	4613      	mov	r3, r2
70007660:	005b      	lsls	r3, r3, #1
70007662:	4413      	add	r3, r2
70007664:	009b      	lsls	r3, r3, #2
70007666:	440b      	add	r3, r1
70007668:	3304      	adds	r3, #4
7000766a:	6819      	ldr	r1, [r3, #0]
7000766c:	68fb      	ldr	r3, [r7, #12]
7000766e:	009b      	lsls	r3, r3, #2
70007670:	693a      	ldr	r2, [r7, #16]
70007672:	f7ff fb83 	bl	70006d7c <SAL_XSPI_GetSFDP>
70007676:	4603      	mov	r3, r0
70007678:	2b00      	cmp	r3, #0
7000767a:	d002      	beq.n	70007682 <SFDP_CollectData+0x14a>
                                     sfdp_param_info[index].address,
                                     ptr, size * 4u))
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
7000767c:	230c      	movs	r3, #12
7000767e:	77fb      	strb	r3, [r7, #31]
        goto error;
70007680:	e022      	b.n	700076c8 <SFDP_CollectData+0x190>
      }
    }

    if (SFDP_PARAMID_BASIC_SPIPROTOCOL == sfdp_param_info[index].type)
70007682:	7dba      	ldrb	r2, [r7, #22]
70007684:	4913      	ldr	r1, [pc, #76]	@ (700076d4 <SFDP_CollectData+0x19c>)
70007686:	4613      	mov	r3, r2
70007688:	005b      	lsls	r3, r3, #1
7000768a:	4413      	add	r3, r2
7000768c:	009b      	lsls	r3, r3, #2
7000768e:	440b      	add	r3, r1
70007690:	681b      	ldr	r3, [r3, #0]
70007692:	2b08      	cmp	r3, #8
70007694:	d109      	bne.n	700076aa <SFDP_CollectData+0x172>
    {
      /* Save data about the reset procedure */
      Object->sfdp_private.Reset_info = JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support;
70007696:	4b10      	ldr	r3, [pc, #64]	@ (700076d8 <SFDP_CollectData+0x1a0>)
70007698:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
7000769c:	f3c3 0305 	ubfx	r3, r3, #0, #6
700076a0:	b2db      	uxtb	r3, r3
700076a2:	461a      	mov	r2, r3
700076a4:	687b      	ldr	r3, [r7, #4]
700076a6:	f8c3 2098 	str.w	r2, [r3, #152]	@ 0x98
  for (uint8_t index = 0u; sfdp_param_info[index].type != SFDP_PARAMID_UNKNOWN; index++)
700076aa:	7dbb      	ldrb	r3, [r7, #22]
700076ac:	3301      	adds	r3, #1
700076ae:	75bb      	strb	r3, [r7, #22]
700076b0:	7dba      	ldrb	r2, [r7, #22]
700076b2:	4908      	ldr	r1, [pc, #32]	@ (700076d4 <SFDP_CollectData+0x19c>)
700076b4:	4613      	mov	r3, r2
700076b6:	005b      	lsls	r3, r3, #1
700076b8:	4413      	add	r3, r2
700076ba:	009b      	lsls	r3, r3, #2
700076bc:	440b      	add	r3, r1
700076be:	681b      	ldr	r3, [r3, #0]
700076c0:	2b00      	cmp	r3, #0
700076c2:	f47f af7f 	bne.w	700075c4 <SFDP_CollectData+0x8c>
    }
  }

error:
700076c6:	bf00      	nop
  return retr;
700076c8:	7ffb      	ldrb	r3, [r7, #31]
}
700076ca:	4618      	mov	r0, r3
700076cc:	3720      	adds	r7, #32
700076ce:	46bd      	mov	sp, r7
700076d0:	bd80      	pop	{r7, pc}
700076d2:	bf00      	nop
700076d4:	24000304 	.word	0x24000304
700076d8:	2400037c 	.word	0x2400037c
700076dc:	24000380 	.word	0x24000380
700076e0:	240003dc 	.word	0x240003dc
700076e4:	240003fc 	.word	0x240003fc
700076e8:	240003e4 	.word	0x240003e4
700076ec:	2400046c 	.word	0x2400046c

700076f0 <SFDP_MemoryReset>:
  * @brief Resets the NOR memory device using the SFDP-defined reset procedure.
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @retval SFDP_StatusTypeDef Status of the operation: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef SFDP_MemoryReset(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
700076f0:	b580      	push	{r7, lr}
700076f2:	b086      	sub	sp, #24
700076f4:	af00      	add	r7, sp, #0
700076f6:	6078      	str	r0, [r7, #4]
  RESET_METHOD reset_method;
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NO_PARAMTABLE_BASIC;
700076f8:	2307      	movs	r3, #7
700076fa:	75bb      	strb	r3, [r7, #22]
  uint32_t sfdp_address = SFDP_HEADER_SIZE;
700076fc:	2308      	movs	r3, #8
700076fe:	613b      	str	r3, [r7, #16]
  uint8_t find = 0u;
70007700:	2300      	movs	r3, #0
70007702:	73fb      	strb	r3, [r7, #15]
  SFDP_DEBUG_STR(__func__);

  /* Get the table param info */
  for (uint8_t index = 0u; index < (Object->sfdp_private.Sfdp_param_number + 1u); index++)
70007704:	2300      	movs	r3, #0
70007706:	73bb      	strb	r3, [r7, #14]
70007708:	e02e      	b.n	70007768 <SFDP_MemoryReset+0x78>
  {
    retr = sfdp_get_paraminfo(Object, sfdp_address, &sfdp_param_info[0]);
7000770a:	4a64      	ldr	r2, [pc, #400]	@ (7000789c <SFDP_MemoryReset+0x1ac>)
7000770c:	6939      	ldr	r1, [r7, #16]
7000770e:	6878      	ldr	r0, [r7, #4]
70007710:	f000 ff80 	bl	70008614 <sfdp_get_paraminfo>
70007714:	4603      	mov	r3, r0
70007716:	75bb      	strb	r3, [r7, #22]
    if (EXTMEM_SFDP_OK == retr)
70007718:	7dbb      	ldrb	r3, [r7, #22]
7000771a:	2b00      	cmp	r3, #0
7000771c:	d118      	bne.n	70007750 <SFDP_MemoryReset+0x60>
    {
      /* Check if the table is basic table */
      if (SFDP_PARAMID_BASIC_SPIPROTOCOL == sfdp_param_info[0].type)
7000771e:	4b5f      	ldr	r3, [pc, #380]	@ (7000789c <SFDP_MemoryReset+0x1ac>)
70007720:	681b      	ldr	r3, [r3, #0]
70007722:	2b08      	cmp	r3, #8
70007724:	d114      	bne.n	70007750 <SFDP_MemoryReset+0x60>
      {
        /* Read the JEDEC basic param */
        if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
70007726:	687b      	ldr	r3, [r7, #4]
70007728:	f103 0008 	add.w	r0, r3, #8
7000772c:	4b5b      	ldr	r3, [pc, #364]	@ (7000789c <SFDP_MemoryReset+0x1ac>)
7000772e:	6859      	ldr	r1, [r3, #4]
                                       sfdp_param_info[0].address,
                                       JEDEC_Basic.Params.data_BYTE,
                                       ((uint32_t)sfdp_param_info[0].size) * 4u))
70007730:	4b5a      	ldr	r3, [pc, #360]	@ (7000789c <SFDP_MemoryReset+0x1ac>)
70007732:	7a1b      	ldrb	r3, [r3, #8]
        if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject,
70007734:	009b      	lsls	r3, r3, #2
70007736:	4a5a      	ldr	r2, [pc, #360]	@ (700078a0 <SFDP_MemoryReset+0x1b0>)
70007738:	f7ff fb20 	bl	70006d7c <SAL_XSPI_GetSFDP>
7000773c:	4603      	mov	r3, r0
7000773e:	2b00      	cmp	r3, #0
70007740:	d002      	beq.n	70007748 <SFDP_MemoryReset+0x58>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
70007742:	230c      	movs	r3, #12
70007744:	75bb      	strb	r3, [r7, #22]
70007746:	e003      	b.n	70007750 <SFDP_MemoryReset+0x60>
        }
        else
        {
          retr = EXTMEM_SFDP_OK;
70007748:	2300      	movs	r3, #0
7000774a:	75bb      	strb	r3, [r7, #22]
          find = 1u;
7000774c:	2301      	movs	r3, #1
7000774e:	73fb      	strb	r3, [r7, #15]
        }
      }
    }

    if ((EXTMEM_SFDP_OK != retr) || (1u == find))
70007750:	7dbb      	ldrb	r3, [r7, #22]
70007752:	2b00      	cmp	r3, #0
70007754:	d10f      	bne.n	70007776 <SFDP_MemoryReset+0x86>
70007756:	7bfb      	ldrb	r3, [r7, #15]
70007758:	2b01      	cmp	r3, #1
7000775a:	d00c      	beq.n	70007776 <SFDP_MemoryReset+0x86>
    {
      /* Stop reading, if there is an error or if the table has been found */
      break;
    }
    /* Look for the next table */
    sfdp_address += SFDP_PARAM_HEADER_SIZE;
7000775c:	693b      	ldr	r3, [r7, #16]
7000775e:	3308      	adds	r3, #8
70007760:	613b      	str	r3, [r7, #16]
  for (uint8_t index = 0u; index < (Object->sfdp_private.Sfdp_param_number + 1u); index++)
70007762:	7bbb      	ldrb	r3, [r7, #14]
70007764:	3301      	adds	r3, #1
70007766:	73bb      	strb	r3, [r7, #14]
70007768:	7bba      	ldrb	r2, [r7, #14]
7000776a:	687b      	ldr	r3, [r7, #4]
7000776c:	f893 309c 	ldrb.w	r3, [r3, #156]	@ 0x9c
70007770:	3301      	adds	r3, #1
70007772:	429a      	cmp	r2, r3
70007774:	d3c9      	bcc.n	7000770a <SFDP_MemoryReset+0x1a>
  }

  /* If an error has been returned or if the table has not been found */
  if ((EXTMEM_SFDP_OK != retr) || (0u == find))
70007776:	7dbb      	ldrb	r3, [r7, #22]
70007778:	2b00      	cmp	r3, #0
7000777a:	d102      	bne.n	70007782 <SFDP_MemoryReset+0x92>
7000777c:	7bfb      	ldrb	r3, [r7, #15]
7000777e:	2b00      	cmp	r3, #0
70007780:	d102      	bne.n	70007788 <SFDP_MemoryReset+0x98>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70007782:	230c      	movs	r3, #12
70007784:	75bb      	strb	r3, [r7, #22]
    goto error;
70007786:	e083      	b.n	70007890 <SFDP_MemoryReset+0x1a0>
  }

  /* Determine how to proceed memory reset */
  if (0x0u == JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support)
70007788:	4b46      	ldr	r3, [pc, #280]	@ (700078a4 <SFDP_MemoryReset+0x1b4>)
7000778a:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
7000778e:	f003 033f 	and.w	r3, r3, #63	@ 0x3f
70007792:	b2db      	uxtb	r3, r3
70007794:	2b00      	cmp	r3, #0
70007796:	d102      	bne.n	7000779e <SFDP_MemoryReset+0xae>
  {
    /* 00_0000b: no software reset instruction is supported */
    reset_method = RESET_NONE;
70007798:	2300      	movs	r3, #0
7000779a:	75fb      	strb	r3, [r7, #23]
7000779c:	e053      	b.n	70007846 <SFDP_MemoryReset+0x156>
  }
  else if (0x1u == (0x1u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
7000779e:	4b41      	ldr	r3, [pc, #260]	@ (700078a4 <SFDP_MemoryReset+0x1b4>)
700077a0:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
700077a4:	f3c3 0305 	ubfx	r3, r3, #0, #6
700077a8:	b2db      	uxtb	r3, r3
700077aa:	f003 0301 	and.w	r3, r3, #1
700077ae:	b2db      	uxtb	r3, r3
700077b0:	2b00      	cmp	r3, #0
700077b2:	d002      	beq.n	700077ba <SFDP_MemoryReset+0xca>
  {
    /* xx_xxx1b: drive Fh on all 4 data wires for 8 clocks */
    reset_method = RESET_FH_4DATA_8CLOCK;
700077b4:	2301      	movs	r3, #1
700077b6:	75fb      	strb	r3, [r7, #23]
700077b8:	e045      	b.n	70007846 <SFDP_MemoryReset+0x156>
  }
  else if (0x2u == (0x2u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
700077ba:	4b3a      	ldr	r3, [pc, #232]	@ (700078a4 <SFDP_MemoryReset+0x1b4>)
700077bc:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
700077c0:	f3c3 0305 	ubfx	r3, r3, #0, #6
700077c4:	b2db      	uxtb	r3, r3
700077c6:	f003 0302 	and.w	r3, r3, #2
700077ca:	b2db      	uxtb	r3, r3
700077cc:	2b00      	cmp	r3, #0
700077ce:	d002      	beq.n	700077d6 <SFDP_MemoryReset+0xe6>
  {
    /* xx_xx1xb: drive Fh on all 4 data wires for 10 clocks if device is operating in 4-byte address mode */
    reset_method = RESET_FH_4DATA_10CLOCK;
700077d0:	2302      	movs	r3, #2
700077d2:	75fb      	strb	r3, [r7, #23]
700077d4:	e037      	b.n	70007846 <SFDP_MemoryReset+0x156>
  }
  else if (0x4u == (0x4u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
700077d6:	4b33      	ldr	r3, [pc, #204]	@ (700078a4 <SFDP_MemoryReset+0x1b4>)
700077d8:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
700077dc:	f3c3 0305 	ubfx	r3, r3, #0, #6
700077e0:	b2db      	uxtb	r3, r3
700077e2:	f003 0304 	and.w	r3, r3, #4
700077e6:	b2db      	uxtb	r3, r3
700077e8:	2b00      	cmp	r3, #0
700077ea:	d002      	beq.n	700077f2 <SFDP_MemoryReset+0x102>
  {
    /* xx_x1xxb: drive Fh on all 4 data wires for 16 clocks */
    reset_method = RESET_FH_4DATA_16CLOCK;
700077ec:	2303      	movs	r3, #3
700077ee:	75fb      	strb	r3, [r7, #23]
700077f0:	e029      	b.n	70007846 <SFDP_MemoryReset+0x156>
  }
  else if (0x8u == (0x8u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
700077f2:	4b2c      	ldr	r3, [pc, #176]	@ (700078a4 <SFDP_MemoryReset+0x1b4>)
700077f4:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
700077f8:	f3c3 0305 	ubfx	r3, r3, #0, #6
700077fc:	b2db      	uxtb	r3, r3
700077fe:	f003 0308 	and.w	r3, r3, #8
70007802:	b2db      	uxtb	r3, r3
70007804:	2b00      	cmp	r3, #0
70007806:	d002      	beq.n	7000780e <SFDP_MemoryReset+0x11e>
  {
    /* xx_1xxxb: issue instruction F0h */
    reset_method = RESET_INSTRUCTION_F0;
70007808:	2304      	movs	r3, #4
7000780a:	75fb      	strb	r3, [r7, #23]
7000780c:	e01b      	b.n	70007846 <SFDP_MemoryReset+0x156>
  }
  else if (0x10u == (0x10u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
7000780e:	4b25      	ldr	r3, [pc, #148]	@ (700078a4 <SFDP_MemoryReset+0x1b4>)
70007810:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
70007814:	f3c3 0305 	ubfx	r3, r3, #0, #6
70007818:	b2db      	uxtb	r3, r3
7000781a:	f003 0310 	and.w	r3, r3, #16
7000781e:	b2db      	uxtb	r3, r3
70007820:	2b00      	cmp	r3, #0
70007822:	d002      	beq.n	7000782a <SFDP_MemoryReset+0x13a>
  {
    /* x1_xxxxb: issue reset enable instruction 66h, then issue reset instruction 99h. The reset enable,
    reset sequence may be issued on 1, 2, or 4 wires depending on the device operating mode.
    */
    reset_method = RESET_INSTRUCTION_66_99;
70007824:	2305      	movs	r3, #5
70007826:	75fb      	strb	r3, [r7, #23]
70007828:	e00d      	b.n	70007846 <SFDP_MemoryReset+0x156>
  }
  else if (0x20u == (0x20u & JEDEC_Basic.Params.Param_DWORD.D16.SoftResetRescueSequence_Support))
7000782a:	4b1e      	ldr	r3, [pc, #120]	@ (700078a4 <SFDP_MemoryReset+0x1b4>)
7000782c:	f893 3041 	ldrb.w	r3, [r3, #65]	@ 0x41
70007830:	f3c3 0305 	ubfx	r3, r3, #0, #6
70007834:	b2db      	uxtb	r3, r3
70007836:	2b1f      	cmp	r3, #31
70007838:	d902      	bls.n	70007840 <SFDP_MemoryReset+0x150>
    xx_xx1x_xxxxb: Hardware reset
    xx_x1xx_xxxxb: Software reset (see bits 13:8 in this DWORD)
    xx_1xxx_xxxxb: Power cycle
    x1_xxxx_xxxxb: Reserved
    */
    retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
7000783a:	230f      	movs	r3, #15
7000783c:	75bb      	strb	r3, [r7, #22]
    goto error;
7000783e:	e027      	b.n	70007890 <SFDP_MemoryReset+0x1a0>
  }
  else
  {
    /* No coherence, should be managed as error */
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70007840:	230c      	movs	r3, #12
70007842:	75bb      	strb	r3, [r7, #22]
    goto error;
70007844:	e024      	b.n	70007890 <SFDP_MemoryReset+0x1a0>
  }

  switch (reset_method)
70007846:	7dfb      	ldrb	r3, [r7, #23]
70007848:	2b05      	cmp	r3, #5
7000784a:	d009      	beq.n	70007860 <SFDP_MemoryReset+0x170>
7000784c:	2b05      	cmp	r3, #5
7000784e:	dc1b      	bgt.n	70007888 <SFDP_MemoryReset+0x198>
70007850:	2b00      	cmp	r3, #0
70007852:	d01c      	beq.n	7000788e <SFDP_MemoryReset+0x19e>
70007854:	2b00      	cmp	r3, #0
70007856:	db17      	blt.n	70007888 <SFDP_MemoryReset+0x198>
70007858:	3b01      	subs	r3, #1
7000785a:	2b03      	cmp	r3, #3
7000785c:	d814      	bhi.n	70007888 <SFDP_MemoryReset+0x198>
7000785e:	e010      	b.n	70007882 <SFDP_MemoryReset+0x192>
    case RESET_NONE:
      break;
    case RESET_INSTRUCTION_66_99:
      /* Perform the reset in 1, 2 and 4 lines */
      SFDP_DEBUG_STR("::reset 0x66 0x99");
      (void)SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x66, NULL, 0);
70007860:	687b      	ldr	r3, [r7, #4]
70007862:	f103 0008 	add.w	r0, r3, #8
70007866:	2300      	movs	r3, #0
70007868:	2200      	movs	r2, #0
7000786a:	2166      	movs	r1, #102	@ 0x66
7000786c:	f7ff fbaf 	bl	70006fce <SAL_XSPI_CommandSendData>
      (void)SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x99, NULL, 0);
70007870:	687b      	ldr	r3, [r7, #4]
70007872:	f103 0008 	add.w	r0, r3, #8
70007876:	2300      	movs	r3, #0
70007878:	2200      	movs	r2, #0
7000787a:	2199      	movs	r1, #153	@ 0x99
7000787c:	f7ff fba7 	bl	70006fce <SAL_XSPI_CommandSendData>
      break;
70007880:	e006      	b.n	70007890 <SFDP_MemoryReset+0x1a0>
    case RESET_INSTRUCTION_F0:
    case RESET_FH_4DATA_8CLOCK:
    case RESET_FH_4DATA_10CLOCK:
    case RESET_FH_4DATA_16CLOCK:
      retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
70007882:	230f      	movs	r3, #15
70007884:	75bb      	strb	r3, [r7, #22]
      break;
70007886:	e003      	b.n	70007890 <SFDP_MemoryReset+0x1a0>
    /* case RESET_ERROR:*/
    default :
      retr = EXTMEM_SFDP_ERROR_PARAM;
70007888:	2301      	movs	r3, #1
7000788a:	75bb      	strb	r3, [r7, #22]
      break;
7000788c:	e000      	b.n	70007890 <SFDP_MemoryReset+0x1a0>
      break;
7000788e:	bf00      	nop
  }
error :
  return retr;
70007890:	7dbb      	ldrb	r3, [r7, #22]
}
70007892:	4618      	mov	r0, r3
70007894:	3718      	adds	r7, #24
70007896:	46bd      	mov	sp, r7
70007898:	bd80      	pop	{r7, pc}
7000789a:	bf00      	nop
7000789c:	24000304 	.word	0x24000304
700078a0:	24000380 	.word	0x24000380
700078a4:	2400037c 	.word	0x2400037c

700078a8 <SFDP_BuildGenericDriver>:
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @param FreqUpdated Pointer to a variable set to 1 if the frequency is updated, 0 otherwise.
  * @retval SFDP_StatusTypeDef Status of the operation: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef SFDP_BuildGenericDriver(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint8_t *FreqUpdated)
{
700078a8:	b5f0      	push	{r4, r5, r6, r7, lr}
700078aa:	b08f      	sub	sp, #60	@ 0x3c
700078ac:	af04      	add	r7, sp, #16
700078ae:	6078      	str	r0, [r7, #4]
700078b0:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
700078b2:	2300      	movs	r3, #0
700078b4:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  static const uint16_t block_erase_unit[] = { 16u, 256u, 4000u, 64000u};
  static const uint32_t chip_erase_unit[]  = { 16u, 256u, 4000u, 64000u};
  SFDP_DEBUG_STR(__func__);
  uint8_t flag4byteAddress = 0u;
700078b8:	2300      	movs	r3, #0
700078ba:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
  uint32_t dummyCycles;
  uint32_t dummyCyclesValue;
  uint8_t FlashSize;

  if ((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL) !=
700078be:	687b      	ldr	r3, [r7, #4]
700078c0:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
700078c4:	f003 0308 	and.w	r3, r3, #8
700078c8:	2b00      	cmp	r3, #0
700078ca:	d104      	bne.n	700078d6 <SFDP_BuildGenericDriver+0x2e>
      (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
  {
    /* This table is mandatory to build the driver data */
    retr = EXTMEM_SFDP_ERROR_NO_PARAMTABLE_BASIC;
700078cc:	2307      	movs	r3, #7
700078ce:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
700078d2:	f000 be26 	b.w	70008522 <SFDP_BuildGenericDriver+0xc7a>
  /* ---------------------------------------------------
   *  Flash sizing
   * ---------------------------------------------------
   */
  /* Calculation of the flash density in puissance of 2 */
  if ((JEDEC_Basic.Params.Param_DWORD.D2.FlashSize & 0x80000000u) == 0x0u)
700078d6:	4bba      	ldr	r3, [pc, #744]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
700078d8:	689b      	ldr	r3, [r3, #8]
700078da:	2b00      	cmp	r3, #0
700078dc:	db13      	blt.n	70007906 <SFDP_BuildGenericDriver+0x5e>
  {
#if ( __CORTEX_M == 0)
#error "the assembly instruction is not available"
#else
    Object->sfdp_private.FlashSize = 31u - (uint8_t)__CLZ((JEDEC_Basic.Params.Param_DWORD.D2.FlashSize + 1u));
700078de:	4bb8      	ldr	r3, [pc, #736]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
700078e0:	689b      	ldr	r3, [r3, #8]
700078e2:	3301      	adds	r3, #1
700078e4:	61bb      	str	r3, [r7, #24]
  if (value == 0U)
700078e6:	69bb      	ldr	r3, [r7, #24]
700078e8:	2b00      	cmp	r3, #0
700078ea:	d101      	bne.n	700078f0 <SFDP_BuildGenericDriver+0x48>
    return 32U;
700078ec:	2320      	movs	r3, #32
700078ee:	e003      	b.n	700078f8 <SFDP_BuildGenericDriver+0x50>
  return __builtin_clz(value);
700078f0:	69bb      	ldr	r3, [r7, #24]
700078f2:	fab3 f383 	clz	r3, r3
700078f6:	b2db      	uxtb	r3, r3
700078f8:	f1c3 031f 	rsb	r3, r3, #31
700078fc:	b2da      	uxtb	r2, r3
700078fe:	687b      	ldr	r3, [r7, #4]
70007900:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e
70007904:	e005      	b.n	70007912 <SFDP_BuildGenericDriver+0x6a>
#endif /* __CORTEX_M */
  }
  else
  {
    Object->sfdp_private.FlashSize = (uint8_t)(JEDEC_Basic.Params.Param_DWORD.D2.FlashSize & 0x7FFFFFFFu);
70007906:	4bae      	ldr	r3, [pc, #696]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007908:	689b      	ldr	r3, [r3, #8]
7000790a:	b2da      	uxtb	r2, r3
7000790c:	687b      	ldr	r3, [r7, #4]
7000790e:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e
  }

  /* Conversion bit to byte */
  Object->sfdp_private.FlashSize = Object->sfdp_private.FlashSize - 3u; /* divide by eight the value */
70007912:	687b      	ldr	r3, [r7, #4]
70007914:	f893 305e 	ldrb.w	r3, [r3, #94]	@ 0x5e
70007918:	3b03      	subs	r3, #3
7000791a:	b2da      	uxtb	r2, r3
7000791c:	687b      	ldr	r3, [r7, #4]
7000791e:	f883 205e 	strb.w	r2, [r3, #94]	@ 0x5e

  SFDP_DEBUG_INT("-> flash size: 2^", Object->sfdp_private.FlashSize);
  FlashSize = Object->sfdp_private.FlashSize - 1u;
70007922:	687b      	ldr	r3, [r7, #4]
70007924:	f893 305e 	ldrb.w	r3, [r3, #94]	@ 0x5e
70007928:	3b01      	subs	r3, #1
7000792a:	b2db      	uxtb	r3, r3
7000792c:	74fb      	strb	r3, [r7, #19]
  (void) SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_FLASHSIZE, &FlashSize);
7000792e:	687b      	ldr	r3, [r7, #4]
70007930:	3308      	adds	r3, #8
70007932:	f107 0213 	add.w	r2, r7, #19
70007936:	2104      	movs	r1, #4
70007938:	4618      	mov	r0, r3
7000793a:	f7ff f8cd 	bl	70006ad8 <SAL_XSPI_MemoryConfig>

  /* get the page size info */
  Object->sfdp_private.PageSize = ((uint32_t)1u <<  JEDEC_Basic.Params.Param_DWORD.D11.PageSize);
7000793e:	4ba0      	ldr	r3, [pc, #640]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007940:	f893 302c 	ldrb.w	r3, [r3, #44]	@ 0x2c
70007944:	f3c3 1303 	ubfx	r3, r3, #4, #4
70007948:	b2db      	uxtb	r3, r3
7000794a:	461a      	mov	r2, r3
7000794c:	2301      	movs	r3, #1
7000794e:	fa03 f202 	lsl.w	r2, r3, r2
70007952:	687b      	ldr	r3, [r7, #4]
70007954:	661a      	str	r2, [r3, #96]	@ 0x60

  /* ---------------------------------------------------
   *  Set default command
   * ---------------------------------------------------
   */
  Object->sfdp_private.DriverInfo.PageProgramInstruction = SFDP_DRIVER_PAGE_PROGRAM_COMMAND;
70007956:	687b      	ldr	r3, [r7, #4]
70007958:	2202      	movs	r2, #2
7000795a:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
  /* ---------------------------------------------------
   *  Erase management
   * ---------------------------------------------------
   */
  /* Manage erase data */
  Object->sfdp_private.DriverInfo.EraseType1Size    = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType1_Size;
7000795e:	4b98      	ldr	r3, [pc, #608]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007960:	f893 2020 	ldrb.w	r2, [r3, #32]
70007964:	687b      	ldr	r3, [r7, #4]
70007966:	f883 2077 	strb.w	r2, [r3, #119]	@ 0x77
  Object->sfdp_private.DriverInfo.EraseType1Command = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType1_Instruction;
7000796a:	4b95      	ldr	r3, [pc, #596]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
7000796c:	f893 2021 	ldrb.w	r2, [r3, #33]	@ 0x21
70007970:	687b      	ldr	r3, [r7, #4]
70007972:	f883 2078 	strb.w	r2, [r3, #120]	@ 0x78
  Object->sfdp_private.DriverInfo.EraseType2Size    = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType2_Size;
70007976:	4b92      	ldr	r3, [pc, #584]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007978:	f893 2022 	ldrb.w	r2, [r3, #34]	@ 0x22
7000797c:	687b      	ldr	r3, [r7, #4]
7000797e:	f883 2079 	strb.w	r2, [r3, #121]	@ 0x79
  Object->sfdp_private.DriverInfo.EraseType2Command = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D8.EraseType2_Instruction;
70007982:	4b8f      	ldr	r3, [pc, #572]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007984:	f893 2023 	ldrb.w	r2, [r3, #35]	@ 0x23
70007988:	687b      	ldr	r3, [r7, #4]
7000798a:	f883 207a 	strb.w	r2, [r3, #122]	@ 0x7a
  Object->sfdp_private.DriverInfo.EraseType3Size    = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType3_Size;
7000798e:	4b8c      	ldr	r3, [pc, #560]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007990:	f893 2024 	ldrb.w	r2, [r3, #36]	@ 0x24
70007994:	687b      	ldr	r3, [r7, #4]
70007996:	f883 207b 	strb.w	r2, [r3, #123]	@ 0x7b
  Object->sfdp_private.DriverInfo.EraseType3Command = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType3_Instruction;
7000799a:	4b89      	ldr	r3, [pc, #548]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
7000799c:	f893 2025 	ldrb.w	r2, [r3, #37]	@ 0x25
700079a0:	687b      	ldr	r3, [r7, #4]
700079a2:	f883 207c 	strb.w	r2, [r3, #124]	@ 0x7c
  Object->sfdp_private.DriverInfo.EraseType4Size    = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType4_Size;
700079a6:	4b86      	ldr	r3, [pc, #536]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
700079a8:	f893 2026 	ldrb.w	r2, [r3, #38]	@ 0x26
700079ac:	687b      	ldr	r3, [r7, #4]
700079ae:	f883 207d 	strb.w	r2, [r3, #125]	@ 0x7d
  Object->sfdp_private.DriverInfo.EraseType4Command = (uint8_t)JEDEC_Basic.Params.Param_DWORD.D9.EraseType4_Instruction;
700079b2:	4b83      	ldr	r3, [pc, #524]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
700079b4:	f893 2027 	ldrb.w	r2, [r3, #39]	@ 0x27
700079b8:	687b      	ldr	r3, [r7, #4]
700079ba:	f883 207e 	strb.w	r2, [r3, #126]	@ 0x7e

  if (Object->sfdp_private.DriverInfo.EraseType1Size != 0x0u)
700079be:	687b      	ldr	r3, [r7, #4]
700079c0:	f893 3077 	ldrb.w	r3, [r3, #119]	@ 0x77
700079c4:	2b00      	cmp	r3, #0
700079c6:	d01d      	beq.n	70007a04 <SFDP_BuildGenericDriver+0x15c>
  {
    Object->sfdp_private.DriverInfo.EraseType1Timing =
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
700079c8:	4b7d      	ldr	r3, [pc, #500]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
700079ca:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
700079ce:	f3c3 0303 	ubfx	r3, r3, #0, #4
700079d2:	b2db      	uxtb	r3, r3
700079d4:	461a      	mov	r2, r3
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType1_TypicalTime_count + 1u) *
700079d6:	4b7a      	ldr	r3, [pc, #488]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
700079d8:	8d1b      	ldrh	r3, [r3, #40]	@ 0x28
700079da:	f3c3 1304 	ubfx	r3, r3, #4, #5
700079de:	b2db      	uxtb	r3, r3
700079e0:	3301      	adds	r3, #1
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
700079e2:	fb02 f303 	mul.w	r3, r2, r3
      block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType1_TypicalTime_units];
700079e6:	4a76      	ldr	r2, [pc, #472]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
700079e8:	f892 2029 	ldrb.w	r2, [r2, #41]	@ 0x29
700079ec:	f3c2 0241 	ubfx	r2, r2, #1, #2
700079f0:	b2d2      	uxtb	r2, r2
700079f2:	4611      	mov	r1, r2
700079f4:	4a73      	ldr	r2, [pc, #460]	@ (70007bc4 <SFDP_BuildGenericDriver+0x31c>)
700079f6:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType1_TypicalTime_count + 1u) *
700079fa:	fb03 f202 	mul.w	r2, r3, r2
    Object->sfdp_private.DriverInfo.EraseType1Timing =
700079fe:	687b      	ldr	r3, [r7, #4]
70007a00:	f8c3 2080 	str.w	r2, [r3, #128]	@ 0x80
  }

  if (Object->sfdp_private.DriverInfo.EraseType2Size != 0x0u)
70007a04:	687b      	ldr	r3, [r7, #4]
70007a06:	f893 3079 	ldrb.w	r3, [r3, #121]	@ 0x79
70007a0a:	2b00      	cmp	r3, #0
70007a0c:	d01e      	beq.n	70007a4c <SFDP_BuildGenericDriver+0x1a4>
  {
    Object->sfdp_private.DriverInfo.EraseType2Timing =
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007a0e:	4b6c      	ldr	r3, [pc, #432]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007a10:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
70007a14:	f3c3 0303 	ubfx	r3, r3, #0, #4
70007a18:	b2db      	uxtb	r3, r3
70007a1a:	461a      	mov	r2, r3
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType2_TypicalTime_count + 1u) *
70007a1c:	4b68      	ldr	r3, [pc, #416]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007a1e:	f893 3029 	ldrb.w	r3, [r3, #41]	@ 0x29
70007a22:	f3c3 03c4 	ubfx	r3, r3, #3, #5
70007a26:	b2db      	uxtb	r3, r3
70007a28:	3301      	adds	r3, #1
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007a2a:	fb02 f303 	mul.w	r3, r2, r3
      block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType2_TypicalTime_units];
70007a2e:	4a64      	ldr	r2, [pc, #400]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007a30:	f892 202a 	ldrb.w	r2, [r2, #42]	@ 0x2a
70007a34:	f3c2 0201 	ubfx	r2, r2, #0, #2
70007a38:	b2d2      	uxtb	r2, r2
70007a3a:	4611      	mov	r1, r2
70007a3c:	4a61      	ldr	r2, [pc, #388]	@ (70007bc4 <SFDP_BuildGenericDriver+0x31c>)
70007a3e:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType2_TypicalTime_count + 1u) *
70007a42:	fb03 f202 	mul.w	r2, r3, r2
    Object->sfdp_private.DriverInfo.EraseType2Timing =
70007a46:	687b      	ldr	r3, [r7, #4]
70007a48:	f8c3 2084 	str.w	r2, [r3, #132]	@ 0x84
  }

  if (Object->sfdp_private.DriverInfo.EraseType3Size != 0x0u)
70007a4c:	687b      	ldr	r3, [r7, #4]
70007a4e:	f893 307b 	ldrb.w	r3, [r3, #123]	@ 0x7b
70007a52:	2b00      	cmp	r3, #0
70007a54:	d01d      	beq.n	70007a92 <SFDP_BuildGenericDriver+0x1ea>
  {
    Object->sfdp_private.DriverInfo.EraseType3Timing =
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007a56:	4b5a      	ldr	r3, [pc, #360]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007a58:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
70007a5c:	f3c3 0303 	ubfx	r3, r3, #0, #4
70007a60:	b2db      	uxtb	r3, r3
70007a62:	461a      	mov	r2, r3
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType3_TypicalTime_count + 1u) *
70007a64:	4b56      	ldr	r3, [pc, #344]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007a66:	f893 302a 	ldrb.w	r3, [r3, #42]	@ 0x2a
70007a6a:	f3c3 0384 	ubfx	r3, r3, #2, #5
70007a6e:	b2db      	uxtb	r3, r3
70007a70:	3301      	adds	r3, #1
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007a72:	fb02 f303 	mul.w	r3, r2, r3
      block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType3_TypicalTime_units];
70007a76:	4a52      	ldr	r2, [pc, #328]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007a78:	8d52      	ldrh	r2, [r2, #42]	@ 0x2a
70007a7a:	f3c2 12c1 	ubfx	r2, r2, #7, #2
70007a7e:	b2d2      	uxtb	r2, r2
70007a80:	4611      	mov	r1, r2
70007a82:	4a50      	ldr	r2, [pc, #320]	@ (70007bc4 <SFDP_BuildGenericDriver+0x31c>)
70007a84:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType3_TypicalTime_count + 1u) *
70007a88:	fb03 f202 	mul.w	r2, r3, r2
    Object->sfdp_private.DriverInfo.EraseType3Timing =
70007a8c:	687b      	ldr	r3, [r7, #4]
70007a8e:	f8c3 2088 	str.w	r2, [r3, #136]	@ 0x88
  }

  if (Object->sfdp_private.DriverInfo.EraseType4Size != 0x0u)
70007a92:	687b      	ldr	r3, [r7, #4]
70007a94:	f893 307d 	ldrb.w	r3, [r3, #125]	@ 0x7d
70007a98:	2b00      	cmp	r3, #0
70007a9a:	d01e      	beq.n	70007ada <SFDP_BuildGenericDriver+0x232>
  {
    Object->sfdp_private.DriverInfo.EraseType4Timing =
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007a9c:	4b48      	ldr	r3, [pc, #288]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007a9e:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
70007aa2:	f3c3 0303 	ubfx	r3, r3, #0, #4
70007aa6:	b2db      	uxtb	r3, r3
70007aa8:	461a      	mov	r2, r3
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType4_TypicalTime_count + 1u) *
70007aaa:	4b45      	ldr	r3, [pc, #276]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007aac:	f893 302b 	ldrb.w	r3, [r3, #43]	@ 0x2b
70007ab0:	f3c3 0344 	ubfx	r3, r3, #1, #5
70007ab4:	b2db      	uxtb	r3, r3
70007ab6:	3301      	adds	r3, #1
      (uint32_t)JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007ab8:	fb02 f303 	mul.w	r3, r2, r3
      block_erase_unit[JEDEC_Basic.Params.Param_DWORD.D10.EraseType4_TypicalTime_units];
70007abc:	4a40      	ldr	r2, [pc, #256]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007abe:	f892 202b 	ldrb.w	r2, [r2, #43]	@ 0x2b
70007ac2:	f3c2 1281 	ubfx	r2, r2, #6, #2
70007ac6:	b2d2      	uxtb	r2, r2
70007ac8:	4611      	mov	r1, r2
70007aca:	4a3e      	ldr	r2, [pc, #248]	@ (70007bc4 <SFDP_BuildGenericDriver+0x31c>)
70007acc:	f832 2011 	ldrh.w	r2, [r2, r1, lsl #1]
      (JEDEC_Basic.Params.Param_DWORD.D10.EraseType4_TypicalTime_count + 1u) *
70007ad0:	fb03 f202 	mul.w	r2, r3, r2
    Object->sfdp_private.DriverInfo.EraseType4Timing =
70007ad4:	687b      	ldr	r3, [r7, #4]
70007ad6:	f8c3 208c 	str.w	r2, [r3, #140]	@ 0x8c
  }

  Object->sfdp_private.DriverInfo.EraseChipTiming =
    JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007ada:	4b39      	ldr	r3, [pc, #228]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007adc:	f893 3028 	ldrb.w	r3, [r3, #40]	@ 0x28
70007ae0:	f3c3 0303 	ubfx	r3, r3, #0, #4
70007ae4:	b2db      	uxtb	r3, r3
70007ae6:	461a      	mov	r2, r3
    (JEDEC_Basic.Params.Param_DWORD.D11.ChipErase_TypicalTime_count + 1u) *
70007ae8:	4b35      	ldr	r3, [pc, #212]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007aea:	f893 302f 	ldrb.w	r3, [r3, #47]	@ 0x2f
70007aee:	f3c3 0304 	ubfx	r3, r3, #0, #5
70007af2:	b2db      	uxtb	r3, r3
70007af4:	3301      	adds	r3, #1
    JEDEC_Basic.Params.Param_DWORD.D10.MutliplierEraseTime *
70007af6:	fb02 f303 	mul.w	r3, r2, r3
    chip_erase_unit[JEDEC_Basic.Params.Param_DWORD.D11.ChipErase_TypicalTime_units];
70007afa:	4a31      	ldr	r2, [pc, #196]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007afc:	f892 202f 	ldrb.w	r2, [r2, #47]	@ 0x2f
70007b00:	f3c2 1241 	ubfx	r2, r2, #5, #2
70007b04:	b2d2      	uxtb	r2, r2
70007b06:	4611      	mov	r1, r2
70007b08:	4a2f      	ldr	r2, [pc, #188]	@ (70007bc8 <SFDP_BuildGenericDriver+0x320>)
70007b0a:	f852 2021 	ldr.w	r2, [r2, r1, lsl #2]
    (JEDEC_Basic.Params.Param_DWORD.D11.ChipErase_TypicalTime_count + 1u) *
70007b0e:	fb03 f202 	mul.w	r2, r3, r2
  Object->sfdp_private.DriverInfo.EraseChipTiming =
70007b12:	687b      	ldr	r3, [r7, #4]
70007b14:	f8c3 2090 	str.w	r2, [r3, #144]	@ 0x90
   *   WIP/WEL : write in progress/ write enable management
   * ------------------------------------------------------
   */
  /* This bit definition is maintained for legacy compatibility only. New system implementations
  should refer to 6.4.19 for a full definition of volatile and non-volatile behavior. */
  Object->sfdp_private.DriverInfo.ReadWELCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
70007b18:	687b      	ldr	r3, [r7, #4]
70007b1a:	2205      	movs	r2, #5
70007b1c:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
  Object->sfdp_private.DriverInfo.ReadWIPCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
70007b20:	687b      	ldr	r3, [r7, #4]
70007b22:	2205      	movs	r2, #5
70007b24:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
  if (JEDEC_Basic.Params.Param_DWORD.D1.WriteEnableInstructionVolatileRegister == 0u)
70007b28:	4b25      	ldr	r3, [pc, #148]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007b2a:	791b      	ldrb	r3, [r3, #4]
70007b2c:	f003 0310 	and.w	r3, r3, #16
70007b30:	b2db      	uxtb	r3, r3
70007b32:	2b00      	cmp	r3, #0
70007b34:	d104      	bne.n	70007b40 <SFDP_BuildGenericDriver+0x298>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_50H_COMMAND;
70007b36:	687b      	ldr	r3, [r7, #4]
70007b38:	2250      	movs	r2, #80	@ 0x50
70007b3a:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
70007b3e:	e003      	b.n	70007b48 <SFDP_BuildGenericDriver+0x2a0>
  }
  else
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
70007b40:	687b      	ldr	r3, [r7, #4]
70007b42:	2206      	movs	r2, #6
70007b44:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
     in either a volatile or non-volatile manner.
     Bits 1:0 in status register 1 are de-facto standard write enable and busy status and
     are excluded from the definitions below.
  */
  /* xxx_xxx1b: Non-Volatile Status Register 1, powers-up to last written value, use instruction 06h to enable write */
  if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x1u) != 0u)
70007b48:	4b1d      	ldr	r3, [pc, #116]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007b4a:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
70007b4e:	f3c3 0306 	ubfx	r3, r3, #0, #7
70007b52:	b2db      	uxtb	r3, r3
70007b54:	f003 0301 	and.w	r3, r3, #1
70007b58:	2b00      	cmp	r3, #0
70007b5a:	d004      	beq.n	70007b66 <SFDP_BuildGenericDriver+0x2be>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
70007b5c:	687b      	ldr	r3, [r7, #4]
70007b5e:	2206      	movs	r2, #6
70007b60:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
70007b64:	e046      	b.n	70007bf4 <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_xx1xb: Volatile Status Register 1,
                status register powers-up with bits set to "1"s, use instruction 06h to enable write */
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x02u) != 0u)
70007b66:	4b16      	ldr	r3, [pc, #88]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007b68:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
70007b6c:	f3c3 0306 	ubfx	r3, r3, #0, #7
70007b70:	b2db      	uxtb	r3, r3
70007b72:	f003 0302 	and.w	r3, r3, #2
70007b76:	2b00      	cmp	r3, #0
70007b78:	d004      	beq.n	70007b84 <SFDP_BuildGenericDriver+0x2dc>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
70007b7a:	687b      	ldr	r3, [r7, #4]
70007b7c:	2206      	movs	r2, #6
70007b7e:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
70007b82:	e037      	b.n	70007bf4 <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_x1xxb: Volatile Status Register 1, status register powers-up with bits set to "1"s,
                use instruction 50h to enable write */
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x04u) != 0u)
70007b84:	4b0e      	ldr	r3, [pc, #56]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007b86:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
70007b8a:	f3c3 0306 	ubfx	r3, r3, #0, #7
70007b8e:	b2db      	uxtb	r3, r3
70007b90:	f003 0304 	and.w	r3, r3, #4
70007b94:	2b00      	cmp	r3, #0
70007b96:	d004      	beq.n	70007ba2 <SFDP_BuildGenericDriver+0x2fa>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_50H_COMMAND;
70007b98:	687b      	ldr	r3, [r7, #4]
70007b9a:	2250      	movs	r2, #80	@ 0x50
70007b9c:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
70007ba0:	e028      	b.n	70007bf4 <SFDP_BuildGenericDriver+0x34c>
  }
  /* xxx_1xxxb: Non-Volatile/Volatile status register 1 powers-up to last written value in the non-volatile
                status register, use instruction 06h to enable write to non-volatile status register.
                Volatile status register may be activated after power-up to override the non-volatile status register,
                use instruction 50h to enable write and activate the volatile status register.*/
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x08u) != 0u)
70007ba2:	4b07      	ldr	r3, [pc, #28]	@ (70007bc0 <SFDP_BuildGenericDriver+0x318>)
70007ba4:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
70007ba8:	f3c3 0306 	ubfx	r3, r3, #0, #7
70007bac:	b2db      	uxtb	r3, r3
70007bae:	f003 0308 	and.w	r3, r3, #8
70007bb2:	2b00      	cmp	r3, #0
70007bb4:	d00a      	beq.n	70007bcc <SFDP_BuildGenericDriver+0x324>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
70007bb6:	687b      	ldr	r3, [r7, #4]
70007bb8:	2206      	movs	r2, #6
70007bba:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
70007bbe:	e019      	b.n	70007bf4 <SFDP_BuildGenericDriver+0x34c>
70007bc0:	2400037c 	.word	0x2400037c
70007bc4:	70009e7c 	.word	0x70009e7c
70007bc8:	70009e84 	.word	0x70009e84
  }
  /* xx1_xxxxb: Status Register 1 contains a mix of volatile and non-volatile bits. The 06h instruction is used to
     enable writing of the register.*/
  else if ((JEDEC_Basic.Params.Param_DWORD.D16.VolatileNonVolatileRegister_WriteEnable & 0x10u) != 0u)
70007bcc:	4b66      	ldr	r3, [pc, #408]	@ (70007d68 <SFDP_BuildGenericDriver+0x4c0>)
70007bce:	f893 3040 	ldrb.w	r3, [r3, #64]	@ 0x40
70007bd2:	f3c3 0306 	ubfx	r3, r3, #0, #7
70007bd6:	b2db      	uxtb	r3, r3
70007bd8:	f003 0310 	and.w	r3, r3, #16
70007bdc:	2b00      	cmp	r3, #0
70007bde:	d004      	beq.n	70007bea <SFDP_BuildGenericDriver+0x342>
  {
    Object->sfdp_private.DriverInfo.WriteWELCommand = SFDP_DRIVER_WRITE_ENABLE_06H_COMMAND;
70007be0:	687b      	ldr	r3, [r7, #4]
70007be2:	2206      	movs	r2, #6
70007be4:	f883 2070 	strb.w	r2, [r3, #112]	@ 0x70
70007be8:	e004      	b.n	70007bf4 <SFDP_BuildGenericDriver+0x34c>
     1xx_xxxxb: Reserved
     NOTE If the status register is read-only then this field will contain all zeros in bits 4:0.
  */
  else
  {
    retr = EXTMEM_SFDP_ERROR_JEDECBASIC_D16;
70007bea:	230a      	movs	r3, #10
70007bec:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
70007bf0:	f000 bc97 	b.w	70008522 <SFDP_BuildGenericDriver+0xc7a>
  }

  if (0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP))
70007bf4:	687b      	ldr	r3, [r7, #4]
70007bf6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
70007bfa:	f403 7300 	and.w	r3, r3, #512	@ 0x200
70007bfe:	2b00      	cmp	r3, #0
70007c00:	d078      	beq.n	70007cf4 <SFDP_BuildGenericDriver+0x44c>
  {
    /* WIP */
    if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitAvailable)
70007c02:	4b5a      	ldr	r3, [pc, #360]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c04:	7cdb      	ldrb	r3, [r3, #19]
70007c06:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
70007c0a:	b2db      	uxtb	r3, r3
70007c0c:	2b00      	cmp	r3, #0
70007c0e:	d034      	beq.n	70007c7a <SFDP_BuildGenericDriver+0x3d2>
    {
      Object->sfdp_private.DriverInfo.ReadWIPCommand  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.CommandReadAccess;
70007c10:	4b56      	ldr	r3, [pc, #344]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c12:	7c5a      	ldrb	r2, [r3, #17]
70007c14:	687b      	ldr	r3, [r7, #4]
70007c16:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
      Object->sfdp_private.DriverInfo.WIPPosition     = JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitLocationRegister;
70007c1a:	4b54      	ldr	r3, [pc, #336]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c1c:	7cdb      	ldrb	r3, [r3, #19]
70007c1e:	f3c3 0302 	ubfx	r3, r3, #0, #3
70007c22:	b2db      	uxtb	r3, r3
70007c24:	461a      	mov	r2, r3
70007c26:	687b      	ldr	r3, [r7, #4]
70007c28:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
      Object->sfdp_private.DriverInfo.WIPBusyPolarity = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.WIPpolarity;
70007c2c:	4b4f      	ldr	r3, [pc, #316]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c2e:	7cdb      	ldrb	r3, [r3, #19]
70007c30:	f3c3 1380 	ubfx	r3, r3, #6, #1
70007c34:	b2db      	uxtb	r3, r3
70007c36:	461a      	mov	r2, r3
70007c38:	687b      	ldr	r3, [r7, #4]
70007c3a:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
      Object->sfdp_private.DriverInfo.WIPPosition     = JEDEC_SCCR_Map.Param_DWORD.D5.WIPBitLocationRegister;
70007c3e:	4b4b      	ldr	r3, [pc, #300]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c40:	7cdb      	ldrb	r3, [r3, #19]
70007c42:	f3c3 0302 	ubfx	r3, r3, #0, #3
70007c46:	b2db      	uxtb	r3, r3
70007c48:	461a      	mov	r2, r3
70007c4a:	687b      	ldr	r3, [r7, #4]
70007c4c:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d

      if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.BitAccessedByCommandsUsingAddress)
70007c50:	4b46      	ldr	r3, [pc, #280]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c52:	7cdb      	ldrb	r3, [r3, #19]
70007c54:	f003 0310 	and.w	r3, r3, #16
70007c58:	b2db      	uxtb	r3, r3
70007c5a:	2b00      	cmp	r3, #0
70007c5c:	d009      	beq.n	70007c72 <SFDP_BuildGenericDriver+0x3ca>
      {
        /* Address management */
        Object->sfdp_private.DriverInfo.WIPAddress  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D5.LocalAddressForWIP;
70007c5e:	4b43      	ldr	r3, [pc, #268]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c60:	7cdb      	ldrb	r3, [r3, #19]
70007c62:	f3c3 03c0 	ubfx	r3, r3, #3, #1
70007c66:	b2db      	uxtb	r3, r3
70007c68:	461a      	mov	r2, r3
70007c6a:	687b      	ldr	r3, [r7, #4]
70007c6c:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
70007c70:	e003      	b.n	70007c7a <SFDP_BuildGenericDriver+0x3d2>
      }
      else
      {
        /* in that case there is no address to manage, the value EXTMEM_ADDRESS_NONE is used to detect the difference */
        Object->sfdp_private.DriverInfo.WIPAddress = EXTMEM_ADDRESS_NONE;
70007c72:	687b      	ldr	r3, [r7, #4]
70007c74:	22ff      	movs	r2, #255	@ 0xff
70007c76:	f883 206f 	strb.w	r2, [r3, #111]	@ 0x6f
      }
    }

    /* WEL */
    if (0u != JEDEC_SCCR_Map.Param_DWORD.D6.WELBitAvailable)
70007c7a:	4b3c      	ldr	r3, [pc, #240]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c7c:	7ddb      	ldrb	r3, [r3, #23]
70007c7e:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
70007c82:	b2db      	uxtb	r3, r3
70007c84:	2b00      	cmp	r3, #0
70007c86:	d073      	beq.n	70007d70 <SFDP_BuildGenericDriver+0x4c8>
    {
      Object->sfdp_private.DriverInfo.ReadWELCommand  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.CommandReadAccess;
70007c88:	4b38      	ldr	r3, [pc, #224]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c8a:	7d5a      	ldrb	r2, [r3, #21]
70007c8c:	687b      	ldr	r3, [r7, #4]
70007c8e:	f883 2071 	strb.w	r2, [r3, #113]	@ 0x71
      Object->sfdp_private.DriverInfo.WELPosition     = JEDEC_SCCR_Map.Param_DWORD.D6.WELBitLocationRegister;
70007c92:	4b36      	ldr	r3, [pc, #216]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007c94:	7ddb      	ldrb	r3, [r3, #23]
70007c96:	f3c3 0302 	ubfx	r3, r3, #0, #3
70007c9a:	b2db      	uxtb	r3, r3
70007c9c:	461a      	mov	r2, r3
70007c9e:	687b      	ldr	r3, [r7, #4]
70007ca0:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
      Object->sfdp_private.DriverInfo.WELBusyPolarity = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.WELpolarity;
70007ca4:	4b31      	ldr	r3, [pc, #196]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007ca6:	7ddb      	ldrb	r3, [r3, #23]
70007ca8:	f3c3 1380 	ubfx	r3, r3, #6, #1
70007cac:	b2db      	uxtb	r3, r3
70007cae:	461a      	mov	r2, r3
70007cb0:	687b      	ldr	r3, [r7, #4]
70007cb2:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73
      Object->sfdp_private.DriverInfo.WELPosition     = JEDEC_SCCR_Map.Param_DWORD.D6.WELBitLocationRegister;
70007cb6:	4b2d      	ldr	r3, [pc, #180]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007cb8:	7ddb      	ldrb	r3, [r3, #23]
70007cba:	f3c3 0302 	ubfx	r3, r3, #0, #3
70007cbe:	b2db      	uxtb	r3, r3
70007cc0:	461a      	mov	r2, r3
70007cc2:	687b      	ldr	r3, [r7, #4]
70007cc4:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72

      if (0u != JEDEC_SCCR_Map.Param_DWORD.D5.BitAccessedByCommandsUsingAddress)
70007cc8:	4b28      	ldr	r3, [pc, #160]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007cca:	7cdb      	ldrb	r3, [r3, #19]
70007ccc:	f003 0310 	and.w	r3, r3, #16
70007cd0:	b2db      	uxtb	r3, r3
70007cd2:	2b00      	cmp	r3, #0
70007cd4:	d009      	beq.n	70007cea <SFDP_BuildGenericDriver+0x442>
      {
        /* Address management */
        Object->sfdp_private.DriverInfo.WELAddress  = (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D6.WELLocalAddress;
70007cd6:	4b25      	ldr	r3, [pc, #148]	@ (70007d6c <SFDP_BuildGenericDriver+0x4c4>)
70007cd8:	7ddb      	ldrb	r3, [r3, #23]
70007cda:	f3c3 03c0 	ubfx	r3, r3, #3, #1
70007cde:	b2db      	uxtb	r3, r3
70007ce0:	461a      	mov	r2, r3
70007ce2:	687b      	ldr	r3, [r7, #4]
70007ce4:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
70007ce8:	e042      	b.n	70007d70 <SFDP_BuildGenericDriver+0x4c8>
      }
      else
      {
        /* in that case there is no address to manage, the value EXTMEM_ADDRESS_NONE is used to detect the difference */
        Object->sfdp_private.DriverInfo.WELAddress = EXTMEM_ADDRESS_NONE;
70007cea:	687b      	ldr	r3, [r7, #4]
70007cec:	22ff      	movs	r2, #255	@ 0xff
70007cee:	f883 2074 	strb.w	r2, [r3, #116]	@ 0x74
70007cf2:	e03d      	b.n	70007d70 <SFDP_BuildGenericDriver+0x4c8>
      }
    }
  }
  else
  {
    Object->sfdp_private.DriverInfo.WELPosition     = 1;
70007cf4:	687b      	ldr	r3, [r7, #4]
70007cf6:	2201      	movs	r2, #1
70007cf8:	f883 2072 	strb.w	r2, [r3, #114]	@ 0x72
    Object->sfdp_private.DriverInfo.WELBusyPolarity = 0;
70007cfc:	687b      	ldr	r3, [r7, #4]
70007cfe:	2200      	movs	r2, #0
70007d00:	f883 2073 	strb.w	r2, [r3, #115]	@ 0x73

    /*
     *   WIP : Status register read management
     *         Basic D14 Status register Polling device Busy
     */
    if (0x01u == (JEDEC_Basic.Params.Param_DWORD.D14.StatusRegister &  0x01u))
70007d04:	4b18      	ldr	r3, [pc, #96]	@ (70007d68 <SFDP_BuildGenericDriver+0x4c0>)
70007d06:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
70007d0a:	f3c3 0385 	ubfx	r3, r3, #2, #6
70007d0e:	b2db      	uxtb	r3, r3
70007d10:	f003 0301 	and.w	r3, r3, #1
70007d14:	2b00      	cmp	r3, #0
70007d16:	d00c      	beq.n	70007d32 <SFDP_BuildGenericDriver+0x48a>
    {
      /* xx_xxx1b: Use of legacy polling is supported by reading the Status Register with 05h instruction
         and checking WIP bit[0] (0=ready; 1=busy). */
      Object->sfdp_private.DriverInfo.ReadWIPCommand = SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND;
70007d18:	687b      	ldr	r3, [r7, #4]
70007d1a:	2205      	movs	r2, #5
70007d1c:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
      Object->sfdp_private.DriverInfo.WIPPosition = 0u;
70007d20:	687b      	ldr	r3, [r7, #4]
70007d22:	2200      	movs	r2, #0
70007d24:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
      Object->sfdp_private.DriverInfo.WIPBusyPolarity = 0u;
70007d28:	687b      	ldr	r3, [r7, #4]
70007d2a:	2200      	movs	r2, #0
70007d2c:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
70007d30:	e01e      	b.n	70007d70 <SFDP_BuildGenericDriver+0x4c8>
    }
    else if (0x02u == (JEDEC_Basic.Params.Param_DWORD.D14.StatusRegister &  0x02u))
70007d32:	4b0d      	ldr	r3, [pc, #52]	@ (70007d68 <SFDP_BuildGenericDriver+0x4c0>)
70007d34:	f893 3038 	ldrb.w	r3, [r3, #56]	@ 0x38
70007d38:	f3c3 0385 	ubfx	r3, r3, #2, #6
70007d3c:	b2db      	uxtb	r3, r3
70007d3e:	f003 0302 	and.w	r3, r3, #2
70007d42:	2b00      	cmp	r3, #0
70007d44:	d00c      	beq.n	70007d60 <SFDP_BuildGenericDriver+0x4b8>
    {
      /* xx_xx1xb: Bit 7 of the Flag Status Register may be polled any time a Program, Erase, Suspend/Resume
         command is issued, or after a Reset command while the device is busy. The read instruction is 70h.
         Flag Status Register bit definitions: bit[7]: Program or erase controller status (0=busy; 1=ready)*/
      Object->sfdp_private.DriverInfo.ReadWIPCommand = 0x70;
70007d46:	687b      	ldr	r3, [r7, #4]
70007d48:	2270      	movs	r2, #112	@ 0x70
70007d4a:	f883 206c 	strb.w	r2, [r3, #108]	@ 0x6c
      Object->sfdp_private.DriverInfo.WIPPosition = 7u;
70007d4e:	687b      	ldr	r3, [r7, #4]
70007d50:	2207      	movs	r2, #7
70007d52:	f883 206d 	strb.w	r2, [r3, #109]	@ 0x6d
      Object->sfdp_private.DriverInfo.WIPBusyPolarity = 0u;
70007d56:	687b      	ldr	r3, [r7, #4]
70007d58:	2200      	movs	r2, #0
70007d5a:	f883 206e 	strb.w	r2, [r3, #110]	@ 0x6e
70007d5e:	e007      	b.n	70007d70 <SFDP_BuildGenericDriver+0x4c8>
    }
    else
    {
      retr = EXTMEM_SFDP_ERROR_JEDECBASIC_D14;
70007d60:	2309      	movs	r3, #9
70007d62:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
70007d66:	e3dc      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
70007d68:	2400037c 	.word	0x2400037c
70007d6c:	240003fc 	.word	0x240003fc
    }
  }

  /* Set default value for Read instruction */
  Object->sfdp_private.DriverInfo.ReadInstruction     = SFDP_DRIVER_READ_COMMAND;
70007d70:	687b      	ldr	r3, [r7, #4]
70007d72:	2203      	movs	r2, #3
70007d74:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
  dummyCycles = 0;
70007d78:	2300      	movs	r3, #0
70007d7a:	617b      	str	r3, [r7, #20]
  (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
70007d7c:	687b      	ldr	r3, [r7, #4]
70007d7e:	3308      	adds	r3, #8
70007d80:	f107 0214 	add.w	r2, r7, #20
70007d84:	2101      	movs	r1, #1
70007d86:	4618      	mov	r0, r3
70007d88:	f7fe fea6 	bl	70006ad8 <SAL_XSPI_MemoryConfig>

  /* ---------------------------------------------------
   *  command based on SFDP_PARAMID_BASIC_SPIPROTOCOL
   * ---------------------------------------------------
   */
  if (((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
70007d8c:	687b      	ldr	r3, [r7, #4]
70007d8e:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
70007d92:	f003 0308 	and.w	r3, r3, #8
70007d96:	2b00      	cmp	r3, #0
70007d98:	f000 80b0 	beq.w	70007efc <SFDP_BuildGenericDriver+0x654>
       == (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)
      && (Object->sfdp_private.Config < EXTMEM_LINK_CONFIG_8LINES))
70007d9c:	687b      	ldr	r3, [r7, #4]
70007d9e:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
70007da2:	2b02      	cmp	r3, #2
70007da4:	f200 80aa 	bhi.w	70007efc <SFDP_BuildGenericDriver+0x654>
  {
    Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S1S;
70007da8:	687b      	ldr	r3, [r7, #4]
70007daa:	2200      	movs	r2, #0
70007dac:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64

    if (Object->sfdp_private.Config > EXTMEM_LINK_CONFIG_1LINE)
70007db0:	687b      	ldr	r3, [r7, #4]
70007db2:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
70007db6:	2b00      	cmp	r3, #0
70007db8:	d04c      	beq.n	70007e54 <SFDP_BuildGenericDriver+0x5ac>
    {
      /* control if read 1s1s2s is available */
      if (JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_FastReadInstruction != 0u)
70007dba:	4bb6      	ldr	r3, [pc, #728]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007dbc:	7c5b      	ldrb	r3, [r3, #17]
70007dbe:	2b00      	cmp	r3, #0
70007dc0:	d015      	beq.n	70007dee <SFDP_BuildGenericDriver+0x546>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_DummyClock
70007dc2:	4bb4      	ldr	r3, [pc, #720]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007dc4:	7c1b      	ldrb	r3, [r3, #16]
70007dc6:	f3c3 0304 	ubfx	r3, r3, #0, #5
70007dca:	b2db      	uxtb	r3, r3
70007dcc:	461a      	mov	r2, r3
                      + JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_ModeClock;
70007dce:	4bb1      	ldr	r3, [pc, #708]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007dd0:	7c1b      	ldrb	r3, [r3, #16]
70007dd2:	f3c3 1342 	ubfx	r3, r3, #5, #3
70007dd6:	b2db      	uxtb	r3, r3
70007dd8:	4413      	add	r3, r2
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_DummyClock
70007dda:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction =
          (uint8_t)JEDEC_Basic.Params.Param_DWORD.D4._1S1S2S_FastReadInstruction;
70007ddc:	4bad      	ldr	r3, [pc, #692]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007dde:	7c5a      	ldrb	r2, [r3, #17]
        Object->sfdp_private.DriverInfo.ReadInstruction =
70007de0:	687b      	ldr	r3, [r7, #4]
70007de2:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S2S;
70007de6:	687b      	ldr	r3, [r7, #4]
70007de8:	2201      	movs	r2, #1
70007dea:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      }

      /* control if read 1S2S2S is available */
      if (JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_FastReadInstruction != 0u)
70007dee:	4ba9      	ldr	r3, [pc, #676]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007df0:	7cdb      	ldrb	r3, [r3, #19]
70007df2:	2b00      	cmp	r3, #0
70007df4:	d015      	beq.n	70007e22 <SFDP_BuildGenericDriver+0x57a>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_DummyClock
70007df6:	4ba7      	ldr	r3, [pc, #668]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007df8:	7c9b      	ldrb	r3, [r3, #18]
70007dfa:	f3c3 0304 	ubfx	r3, r3, #0, #5
70007dfe:	b2db      	uxtb	r3, r3
70007e00:	461a      	mov	r2, r3
                      + JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_ModeClock;
70007e02:	4ba4      	ldr	r3, [pc, #656]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e04:	7c9b      	ldrb	r3, [r3, #18]
70007e06:	f3c3 1342 	ubfx	r3, r3, #5, #3
70007e0a:	b2db      	uxtb	r3, r3
70007e0c:	4413      	add	r3, r2
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_DummyClock
70007e0e:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction =
          (uint8_t)JEDEC_Basic.Params.Param_DWORD.D4._1S2S2S_FastReadInstruction;
70007e10:	4ba0      	ldr	r3, [pc, #640]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e12:	7cda      	ldrb	r2, [r3, #19]
        Object->sfdp_private.DriverInfo.ReadInstruction =
70007e14:	687b      	ldr	r3, [r7, #4]
70007e16:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S2S2S;
70007e1a:	687b      	ldr	r3, [r7, #4]
70007e1c:	2202      	movs	r2, #2
70007e1e:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
      }

      /* The memory work only in 2S2S2S */
      if (JEDEC_Basic.Params.Param_DWORD.D5._2S2S2S_FastReadSupport != 0u)
70007e22:	4b9c      	ldr	r3, [pc, #624]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e24:	7d1b      	ldrb	r3, [r3, #20]
70007e26:	f003 0301 	and.w	r3, r3, #1
70007e2a:	b2db      	uxtb	r3, r3
70007e2c:	2b00      	cmp	r3, #0
70007e2e:	d011      	beq.n	70007e54 <SFDP_BuildGenericDriver+0x5ac>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_DummyClock
70007e30:	4b98      	ldr	r3, [pc, #608]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e32:	7e9b      	ldrb	r3, [r3, #26]
70007e34:	f3c3 0304 	ubfx	r3, r3, #0, #5
70007e38:	b2db      	uxtb	r3, r3
70007e3a:	461a      	mov	r2, r3
                      + JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_ModeClock;
70007e3c:	4b95      	ldr	r3, [pc, #596]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e3e:	7e9b      	ldrb	r3, [r3, #26]
70007e40:	f3c3 1342 	ubfx	r3, r3, #5, #3
70007e44:	b2db      	uxtb	r3, r3
70007e46:	4413      	add	r3, r2
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_DummyClock
70007e48:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction =
          (uint8_t)JEDEC_Basic.Params.Param_DWORD.D6._2S2S2S_FastReadInstruction;
70007e4a:	4b92      	ldr	r3, [pc, #584]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e4c:	7eda      	ldrb	r2, [r3, #27]
        Object->sfdp_private.DriverInfo.ReadInstruction =
70007e4e:	687b      	ldr	r3, [r7, #4]
70007e50:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      }
    }

    /* the command set is only based on this table */
    /* determine the best line configuration */
    if (Object->sfdp_private.Config > EXTMEM_LINK_CONFIG_2LINES)
70007e54:	687b      	ldr	r3, [r7, #4]
70007e56:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
70007e5a:	2b01      	cmp	r3, #1
70007e5c:	d92f      	bls.n	70007ebe <SFDP_BuildGenericDriver+0x616>
    {
      if (JEDEC_Basic.Params.Param_DWORD.D5._4S4S4S_FastReadSupport != 0u)
70007e5e:	4b8d      	ldr	r3, [pc, #564]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e60:	7d1b      	ldrb	r3, [r3, #20]
70007e62:	f003 0310 	and.w	r3, r3, #16
70007e66:	b2db      	uxtb	r3, r3
70007e68:	2b00      	cmp	r3, #0
70007e6a:	d020      	beq.n	70007eae <SFDP_BuildGenericDriver+0x606>
      {
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_DummyClock
70007e6c:	4b89      	ldr	r3, [pc, #548]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e6e:	7f9b      	ldrb	r3, [r3, #30]
70007e70:	f3c3 0304 	ubfx	r3, r3, #0, #5
70007e74:	b2db      	uxtb	r3, r3
70007e76:	461a      	mov	r2, r3
                      + JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_ModeClock;
70007e78:	4b86      	ldr	r3, [pc, #536]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e7a:	7f9b      	ldrb	r3, [r3, #30]
70007e7c:	f3c3 1342 	ubfx	r3, r3, #5, #3
70007e80:	b2db      	uxtb	r3, r3
70007e82:	4413      	add	r3, r2
        dummyCycles = JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_DummyClock
70007e84:	617b      	str	r3, [r7, #20]
        Object->sfdp_private.DriverInfo.ReadInstruction =
          (uint8_t)JEDEC_Basic.Params.Param_DWORD.D7._4S4S4S_FastReadInstruction;
70007e86:	4b83      	ldr	r3, [pc, #524]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007e88:	7fda      	ldrb	r2, [r3, #31]
        Object->sfdp_private.DriverInfo.ReadInstruction =
70007e8a:	687b      	ldr	r3, [r7, #4]
70007e8c:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_4S4S4S;
70007e90:	687b      	ldr	r3, [r7, #4]
70007e92:	2204      	movs	r2, #4
70007e94:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64

        retr = JEDEC_Basic_Manage4S4S4SEnableSequence(Object);
70007e98:	6878      	ldr	r0, [r7, #4]
70007e9a:	f000 ff3b 	bl	70008d14 <JEDEC_Basic_Manage4S4S4SEnableSequence>
70007e9e:	4603      	mov	r3, r0
70007ea0:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        if (retr != EXTMEM_SFDP_OK)
70007ea4:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
70007ea8:	2b00      	cmp	r3, #0
70007eaa:	f040 8337 	bne.w	7000851c <SFDP_BuildGenericDriver+0xc74>
      }
      else /* other configuration with more 4 lines */
      {
        /* not yet handled */
      }
      (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
70007eae:	687b      	ldr	r3, [r7, #4]
70007eb0:	3308      	adds	r3, #8
70007eb2:	f107 0214 	add.w	r2, r7, #20
70007eb6:	2101      	movs	r1, #1
70007eb8:	4618      	mov	r0, r3
70007eba:	f7fe fe0d 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
#endif /* IS25WP032D_ENABLE_DTR */

    }

    /* Configure the link */
    if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
70007ebe:	687b      	ldr	r3, [r7, #4]
70007ec0:	f103 0008 	add.w	r0, r3, #8
                                        &Object->sfdp_private.DriverInfo.SpiPhyLink))
70007ec4:	687b      	ldr	r3, [r7, #4]
70007ec6:	3364      	adds	r3, #100	@ 0x64
    if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
70007ec8:	461a      	mov	r2, r3
70007eca:	2100      	movs	r1, #0
70007ecc:	f7fe fe04 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
70007ed0:	4603      	mov	r3, r0
70007ed2:	2b00      	cmp	r3, #0
70007ed4:	d003      	beq.n	70007ede <SFDP_BuildGenericDriver+0x636>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
70007ed6:	230c      	movs	r3, #12
70007ed8:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
70007edc:	e321      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
    }

    if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, &dummyCycles))
70007ede:	687b      	ldr	r3, [r7, #4]
70007ee0:	3308      	adds	r3, #8
70007ee2:	f107 0214 	add.w	r2, r7, #20
70007ee6:	2101      	movs	r1, #1
70007ee8:	4618      	mov	r0, r3
70007eea:	f7fe fdf5 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
70007eee:	4603      	mov	r3, r0
70007ef0:	2b00      	cmp	r3, #0
70007ef2:	d003      	beq.n	70007efc <SFDP_BuildGenericDriver+0x654>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
70007ef4:	230c      	movs	r3, #12
70007ef6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
70007efa:	e312      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
  /* -----------------------------------------------------------------------------------------------------------------
     If an octal DDR table is present and the target is 8D8D8D,
     when switch in octal DDR mode
     -----------------------------------------------------------------------------------------------------------------
  */
  if (((uint32_t)SFDP_PARAMID_OCTAL_DDR == (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_OCTAL_DDR))
70007efc:	687b      	ldr	r3, [r7, #4]
70007efe:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
70007f02:	f403 5380 	and.w	r3, r3, #4096	@ 0x1000
70007f06:	2b00      	cmp	r3, #0
70007f08:	f000 8087 	beq.w	7000801a <SFDP_BuildGenericDriver+0x772>
      && (EXTMEM_LINK_CONFIG_8LINES == Object->sfdp_private.Config))
70007f0c:	687b      	ldr	r3, [r7, #4]
70007f0e:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
70007f12:	2b03      	cmp	r3, #3
70007f14:	f040 8081 	bne.w	7000801a <SFDP_BuildGenericDriver+0x772>
  {
    /* check if we are not already in octal mode */
    if (PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)
70007f18:	687b      	ldr	r3, [r7, #4]
70007f1a:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
70007f1e:	2b09      	cmp	r3, #9
70007f20:	d103      	bne.n	70007f2a <SFDP_BuildGenericDriver+0x682>
    {
      flag4byteAddress = 1u;
70007f22:	2301      	movs	r3, #1
70007f24:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
70007f28:	e044      	b.n	70007fb4 <SFDP_BuildGenericDriver+0x70c>
    }
    else
    {
      /* Execute the flash command sequence to switch in octal DDR */
      if (EXTMEM_SFDP_OK == sfdp_enter_octal_mode(Object))
70007f2a:	6878      	ldr	r0, [r7, #4]
70007f2c:	f000 fc6e 	bl	7000880c <sfdp_enter_octal_mode>
70007f30:	4603      	mov	r3, r0
70007f32:	2b00      	cmp	r3, #0
70007f34:	d13e      	bne.n	70007fb4 <SFDP_BuildGenericDriver+0x70c>
      {
        /* switch the memory interface configuration according to the Access protocol field */
        flag4byteAddress = 1u;
70007f36:	2301      	movs	r3, #1
70007f38:	f887 3026 	strb.w	r3, [r7, #38]	@ 0x26
        /* Specific case of GigaDevice memory GD25LX512ME whose Instruction mode remains on 8S (8bit commands) */
        if (Object->sfdp_private.ManuID == EXTMEM_MANUFACTURER_GIGADEVICE)
70007f3c:	687b      	ldr	r3, [r7, #4]
70007f3e:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
70007f42:	2bc8      	cmp	r3, #200	@ 0xc8
70007f44:	d104      	bne.n	70007f50 <SFDP_BuildGenericDriver+0x6a8>
        {
          Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_8S8D8D;
70007f46:	687b      	ldr	r3, [r7, #4]
70007f48:	2208      	movs	r2, #8
70007f4a:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
70007f4e:	e003      	b.n	70007f58 <SFDP_BuildGenericDriver+0x6b0>
        }
        else
        {
          Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_8D8D8D;
70007f50:	687b      	ldr	r3, [r7, #4]
70007f52:	2209      	movs	r2, #9
70007f54:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
        }

        /* update the physical link */
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
70007f58:	687b      	ldr	r3, [r7, #4]
70007f5a:	f103 0008 	add.w	r0, r3, #8
                                            &Object->sfdp_private.DriverInfo.SpiPhyLink))
70007f5e:	687b      	ldr	r3, [r7, #4]
70007f60:	3364      	adds	r3, #100	@ 0x64
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
70007f62:	461a      	mov	r2, r3
70007f64:	2100      	movs	r1, #0
70007f66:	f7fe fdb7 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
70007f6a:	4603      	mov	r3, r0
70007f6c:	2b00      	cmp	r3, #0
70007f6e:	d003      	beq.n	70007f78 <SFDP_BuildGenericDriver+0x6d0>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
70007f70:	230c      	movs	r3, #12
70007f72:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
70007f76:	e2d4      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
        }

        if (Object->sfdp_private.Sfdp_AccessProtocol == 0xFDu)
70007f78:	687b      	ldr	r3, [r7, #4]
70007f7a:	f893 309d 	ldrb.w	r3, [r3, #157]	@ 0x9d
70007f7e:	2bfd      	cmp	r3, #253	@ 0xfd
70007f80:	d109      	bne.n	70007f96 <SFDP_BuildGenericDriver+0x6ee>
        {
          /* set 20 wait state */
          dummyCycles = 20;
70007f82:	2314      	movs	r3, #20
70007f84:	617b      	str	r3, [r7, #20]
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
70007f86:	687b      	ldr	r3, [r7, #4]
70007f88:	3308      	adds	r3, #8
70007f8a:	f107 0214 	add.w	r2, r7, #20
70007f8e:	2101      	movs	r1, #1
70007f90:	4618      	mov	r0, r3
70007f92:	f7fe fda1 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
        }
        if (Object->sfdp_private.Sfdp_AccessProtocol == 0xFEu)
70007f96:	687b      	ldr	r3, [r7, #4]
70007f98:	f893 309d 	ldrb.w	r3, [r3, #157]	@ 0x9d
70007f9c:	2bfe      	cmp	r3, #254	@ 0xfe
70007f9e:	d109      	bne.n	70007fb4 <SFDP_BuildGenericDriver+0x70c>
        {
          /* set 8 wait state */
          dummyCycles = 8;
70007fa0:	2308      	movs	r3, #8
70007fa2:	617b      	str	r3, [r7, #20]
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
70007fa4:	687b      	ldr	r3, [r7, #4]
70007fa6:	3308      	adds	r3, #8
70007fa8:	f107 0214 	add.w	r2, r7, #20
70007fac:	2101      	movs	r1, #1
70007fae:	4618      	mov	r0, r3
70007fb0:	f7fe fd92 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
        /* an error occurs when trying to switch the mode                        */
        /* when continue the process and check if another mode could be targeted */
      }
    }

    if ((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)) &&
70007fb4:	687b      	ldr	r3, [r7, #4]
70007fb6:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
70007fba:	f003 0308 	and.w	r3, r3, #8
70007fbe:	2b00      	cmp	r3, #0
70007fc0:	d019      	beq.n	70007ff6 <SFDP_BuildGenericDriver+0x74e>
        (JEDEC_Basic.size > 16u))
70007fc2:	4b34      	ldr	r3, [pc, #208]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007fc4:	681b      	ldr	r3, [r3, #0]
    if ((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_BASIC_SPIPROTOCOL)) &&
70007fc6:	2b10      	cmp	r3, #16
70007fc8:	d915      	bls.n	70007ff6 <SFDP_BuildGenericDriver+0x74e>
      /* 0b00 Command Extension is the same as the Command.
              (Command / Command Extension has the same value for the whole clock period.)*/
      /* 0b01 Command Extension is the inverse of the Command.
              Command Extension acts as a confirmation of the Command */
      /* 0b11 Command and Command Extension forms a 16-bit command word */
      if (JEDEC_Basic.Params.Param_DWORD.D18.OctalDTRCommandExtension > 1u)
70007fca:	4b32      	ldr	r3, [pc, #200]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007fcc:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
70007fd0:	f3c3 1341 	ubfx	r3, r3, #5, #2
70007fd4:	b2db      	uxtb	r3, r3
70007fd6:	2b01      	cmp	r3, #1
70007fd8:	d903      	bls.n	70007fe2 <SFDP_BuildGenericDriver+0x73a>
      {
        retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
70007fda:	230f      	movs	r3, #15
70007fdc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
70007fe0:	e29f      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
      }
      SAL_XSPI_SET_COMMANDEXTENSION(Object->sfdp_private.SALObject,
70007fe2:	4b2c      	ldr	r3, [pc, #176]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
70007fe4:	f893 304b 	ldrb.w	r3, [r3, #75]	@ 0x4b
70007fe8:	f3c3 1341 	ubfx	r3, r3, #5, #2
70007fec:	b2db      	uxtb	r3, r3
70007fee:	461a      	mov	r2, r3
70007ff0:	687b      	ldr	r3, [r7, #4]
70007ff2:	f883 2058 	strb.w	r2, [r3, #88]	@ 0x58
                                    (uint8_t)JEDEC_Basic.Params.Param_DWORD.D18.OctalDTRCommandExtension);
    }

    /* In octal mode, check if JEDEC xSPI (Profile 1.0) Parameter Table is provided, and if yes,
       check value of SFDP command dummy cycles in 1st DWORD */
    if ((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_XSPI_V1_0)
70007ff6:	687b      	ldr	r3, [r7, #4]
70007ff8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
70007ffc:	f003 0380 	and.w	r3, r3, #128	@ 0x80
70008000:	2b00      	cmp	r3, #0
70008002:	d00a      	beq.n	7000801a <SFDP_BuildGenericDriver+0x772>
        == (uint32_t)SFDP_PARAMID_XSPI_V1_0)
    {
      if (JEDEC_XSPI10.Param_DWORD.D1.SFDPCommand_8D8D8DMode_DummyCycles == 1U)
70008004:	4b24      	ldr	r3, [pc, #144]	@ (70008098 <SFDP_BuildGenericDriver+0x7f0>)
70008006:	78db      	ldrb	r3, [r3, #3]
70008008:	f003 0340 	and.w	r3, r3, #64	@ 0x40
7000800c:	b2db      	uxtb	r3, r3
7000800e:	2b00      	cmp	r3, #0
70008010:	d003      	beq.n	7000801a <SFDP_BuildGenericDriver+0x772>
      {
        SAL_XSPI_SET_SFDPDUMMYCYLE(Object->sfdp_private.SALObject, EXTMEM_READ_SFDP_NB_DUMMY_CYCLES_OPI);
70008012:	687b      	ldr	r3, [r7, #4]
70008014:	2214      	movs	r2, #20
70008016:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59
      }
    }
  }

  /* Check WIP flag with new access mode */
  if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
7000801a:	2164      	movs	r1, #100	@ 0x64
7000801c:	6878      	ldr	r0, [r7, #4]
7000801e:	f000 fa95 	bl	7000854c <driver_check_FlagBUSY>
70008022:	4603      	mov	r3, r0
70008024:	2b00      	cmp	r3, #0
70008026:	d003      	beq.n	70008030 <SFDP_BuildGenericDriver+0x788>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70008028:	230c      	movs	r3, #12
7000802a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
7000802e:	e278      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
  }

  if ((Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION) ==
70008030:	687b      	ldr	r3, [r7, #4]
70008032:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
70008036:	f003 0340 	and.w	r3, r3, #64	@ 0x40
7000803a:	2b00      	cmp	r3, #0
7000803c:	f000 8182 	beq.w	70008344 <SFDP_BuildGenericDriver+0xa9c>
      (uint32_t)SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION)
  {
    if (0u == flag4byteAddress)
70008040:	f897 3026 	ldrb.w	r3, [r7, #38]	@ 0x26
70008044:	2b00      	cmp	r3, #0
70008046:	f040 8101 	bne.w	7000824c <SFDP_BuildGenericDriver+0x9a4>
    {
      /* xxxx_xxx1b: issue instruction B7h (preceding write enable not required) */
      if (0x01u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x01u))
7000804a:	4b12      	ldr	r3, [pc, #72]	@ (70008094 <SFDP_BuildGenericDriver+0x7ec>)
7000804c:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
70008050:	f003 0301 	and.w	r3, r3, #1
70008054:	2b00      	cmp	r3, #0
70008056:	d021      	beq.n	7000809c <SFDP_BuildGenericDriver+0x7f4>
      {
        /* send command to enter 4-bytes Address mode */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0xB7, NULL, 0))
70008058:	687b      	ldr	r3, [r7, #4]
7000805a:	f103 0008 	add.w	r0, r3, #8
7000805e:	2300      	movs	r3, #0
70008060:	2200      	movs	r2, #0
70008062:	21b7      	movs	r1, #183	@ 0xb7
70008064:	f7fe ffb3 	bl	70006fce <SAL_XSPI_CommandSendData>
70008068:	4603      	mov	r3, r0
7000806a:	2b00      	cmp	r3, #0
7000806c:	d003      	beq.n	70008076 <SFDP_BuildGenericDriver+0x7ce>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
7000806e:	230c      	movs	r3, #12
70008070:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
70008074:	e255      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
        }

        /* Set 4-Byte addressing on PHY side */
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_ADDRESS_4BYTES, NULL))
70008076:	687b      	ldr	r3, [r7, #4]
70008078:	3308      	adds	r3, #8
7000807a:	2200      	movs	r2, #0
7000807c:	2102      	movs	r1, #2
7000807e:	4618      	mov	r0, r3
70008080:	f7fe fd2a 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
70008084:	4603      	mov	r3, r0
70008086:	2b00      	cmp	r3, #0
70008088:	d072      	beq.n	70008170 <SFDP_BuildGenericDriver+0x8c8>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
7000808a:	230c      	movs	r3, #12
7000808c:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
70008090:	e247      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
70008092:	bf00      	nop
70008094:	2400037c 	.word	0x2400037c
70008098:	240003e4 	.word	0x240003e4
        }

        /* flag4byteAddress = 1u; this setting is not needed because variable is no more used */
      }
      /* xxxx_xx1xb: issue write enable instruction 06h, then issue instruction B7h */
      else if (0x2u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x2u))
7000809c:	4b81      	ldr	r3, [pc, #516]	@ (700082a4 <SFDP_BuildGenericDriver+0x9fc>)
7000809e:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
700080a2:	f003 0302 	and.w	r3, r3, #2
700080a6:	2b00      	cmp	r3, #0
700080a8:	d050      	beq.n	7000814c <SFDP_BuildGenericDriver+0x8a4>
      {
        /* send command to write enable */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,
700080aa:	687b      	ldr	r3, [r7, #4]
700080ac:	f103 0008 	add.w	r0, r3, #8
700080b0:	687b      	ldr	r3, [r7, #4]
700080b2:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
700080b6:	2300      	movs	r3, #0
700080b8:	2200      	movs	r2, #0
700080ba:	f7fe ff88 	bl	70006fce <SAL_XSPI_CommandSendData>
700080be:	4603      	mov	r3, r0
700080c0:	2b00      	cmp	r3, #0
700080c2:	d003      	beq.n	700080cc <SFDP_BuildGenericDriver+0x824>
                                               Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
700080c4:	230c      	movs	r3, #12
700080c6:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
700080ca:	e22a      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
        }

        /* control the write enable */
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
700080cc:	687b      	ldr	r3, [r7, #4]
700080ce:	f103 0008 	add.w	r0, r3, #8
700080d2:	687b      	ldr	r3, [r7, #4]
700080d4:	f893 1071 	ldrb.w	r1, [r3, #113]	@ 0x71
                                                   Object->sfdp_private.DriverInfo.ReadWELCommand,
                                                   Object->sfdp_private.DriverInfo.WELAddress,
700080d8:	687b      	ldr	r3, [r7, #4]
700080da:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
700080de:	461e      	mov	r6, r3
                                                   (((Object->sfdp_private.DriverInfo.WELBusyPolarity == 0u) ? 1u : 0u)
700080e0:	687b      	ldr	r3, [r7, #4]
700080e2:	f893 3073 	ldrb.w	r3, [r3, #115]	@ 0x73
700080e6:	2b00      	cmp	r3, #0
700080e8:	d101      	bne.n	700080ee <SFDP_BuildGenericDriver+0x846>
700080ea:	2301      	movs	r3, #1
700080ec:	e000      	b.n	700080f0 <SFDP_BuildGenericDriver+0x848>
700080ee:	2300      	movs	r3, #0
                                                    << Object->sfdp_private.DriverInfo.WELPosition),
700080f0:	687a      	ldr	r2, [r7, #4]
700080f2:	f892 2072 	ldrb.w	r2, [r2, #114]	@ 0x72
700080f6:	4093      	lsls	r3, r2
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
700080f8:	b2dc      	uxtb	r4, r3
                                                   1u << Object->sfdp_private.DriverInfo.WELPosition,
700080fa:	687b      	ldr	r3, [r7, #4]
700080fc:	f893 3072 	ldrb.w	r3, [r3, #114]	@ 0x72
70008100:	461a      	mov	r2, r3
70008102:	2301      	movs	r3, #1
70008104:	4093      	lsls	r3, r2
        if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
70008106:	b2db      	uxtb	r3, r3
70008108:	687a      	ldr	r2, [r7, #4]
7000810a:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
7000810e:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
70008112:	9502      	str	r5, [sp, #8]
70008114:	9201      	str	r2, [sp, #4]
70008116:	9300      	str	r3, [sp, #0]
70008118:	4623      	mov	r3, r4
7000811a:	4632      	mov	r2, r6
7000811c:	f7ff f864 	bl	700071e8 <SAL_XSPI_CheckStatusRegister>
70008120:	4603      	mov	r3, r0
70008122:	2b00      	cmp	r3, #0
70008124:	d003      	beq.n	7000812e <SFDP_BuildGenericDriver+0x886>
                                                   Object->sfdp_private.ManuID, 1000))
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
70008126:	230c      	movs	r3, #12
70008128:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
7000812c:	e1f9      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
        }

        /* send command to enter 4-bytes Address mode */
        if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0xB7, NULL, 0u))
7000812e:	687b      	ldr	r3, [r7, #4]
70008130:	f103 0008 	add.w	r0, r3, #8
70008134:	2300      	movs	r3, #0
70008136:	2200      	movs	r2, #0
70008138:	21b7      	movs	r1, #183	@ 0xb7
7000813a:	f7fe ff48 	bl	70006fce <SAL_XSPI_CommandSendData>
7000813e:	4603      	mov	r3, r0
70008140:	2b00      	cmp	r3, #0
70008142:	d015      	beq.n	70008170 <SFDP_BuildGenericDriver+0x8c8>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
70008144:	230c      	movs	r3, #12
70008146:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
7000814a:	e1ea      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
        }
      }
      /* x1xx_xxxxb: Always operates in 4-Byte address mode */
      else if (0x40u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x40u))
7000814c:	4b55      	ldr	r3, [pc, #340]	@ (700082a4 <SFDP_BuildGenericDriver+0x9fc>)
7000814e:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
70008152:	f003 0340 	and.w	r3, r3, #64	@ 0x40
70008156:	2b00      	cmp	r3, #0
70008158:	d10a      	bne.n	70008170 <SFDP_BuildGenericDriver+0x8c8>
        /* nothing to do */
        /* flag4byteAddress = 1u; this setting is not needed because variable is no more used */
      }
      /* xx1x_xxxxb: Supports dedicated 4-Byte address instruction set.
                    Consult vendor data sheet for the instruction set definition.*/
      else if (0x20u == (JEDEC_Basic.Params.Param_DWORD.D16.Enter4ByteAddressing & 0x20u))
7000815a:	4b52      	ldr	r3, [pc, #328]	@ (700082a4 <SFDP_BuildGenericDriver+0x9fc>)
7000815c:	f893 3043 	ldrb.w	r3, [r3, #67]	@ 0x43
70008160:	f003 0320 	and.w	r3, r3, #32
70008164:	2b00      	cmp	r3, #0
70008166:	d103      	bne.n	70008170 <SFDP_BuildGenericDriver+0x8c8>
                     Read instruction is B5h. Bit[0] controls address mode [0=3-Byte;1=4-Byte].
                     Write configuration register instruction is B1h, data length is 2 bytes.
      */
      else
      {
        retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
70008168:	230f      	movs	r3, #15
7000816a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
7000816e:	e1d8      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>

      }

      /* Set 4 bytes addressing on PHY side */
      if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_ADDRESS_4BYTES, NULL))
70008170:	687b      	ldr	r3, [r7, #4]
70008172:	3308      	adds	r3, #8
70008174:	2200      	movs	r2, #0
70008176:	2102      	movs	r1, #2
70008178:	4618      	mov	r0, r3
7000817a:	f7fe fcad 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
7000817e:	4603      	mov	r3, r0
70008180:	2b00      	cmp	r3, #0
70008182:	d003      	beq.n	7000818c <SFDP_BuildGenericDriver+0x8e4>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008184:	230c      	movs	r3, #12
70008186:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
7000818a:	e1ca      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
      }

      /* Set the read and program instruction for 4 bytes Address */
      if (PHY_LINK_1S1S1S == Object->sfdp_private.DriverInfo.SpiPhyLink)
7000818c:	687b      	ldr	r3, [r7, #4]
7000818e:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
70008192:	2b00      	cmp	r3, #0
70008194:	d12a      	bne.n	700081ec <SFDP_BuildGenericDriver+0x944>
      {
        if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_ReadCommand)
70008196:	4b44      	ldr	r3, [pc, #272]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
70008198:	781b      	ldrb	r3, [r3, #0]
7000819a:	f003 0301 	and.w	r3, r3, #1
7000819e:	b2db      	uxtb	r3, r3
700081a0:	2b00      	cmp	r3, #0
700081a2:	d003      	beq.n	700081ac <SFDP_BuildGenericDriver+0x904>
        {
          Object->sfdp_private.DriverInfo.ReadInstruction = 0x13U;
700081a4:	687b      	ldr	r3, [r7, #4]
700081a6:	2213      	movs	r2, #19
700081a8:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        }
        if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_PageProgramCommand)
700081ac:	4b3e      	ldr	r3, [pc, #248]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
700081ae:	781b      	ldrb	r3, [r3, #0]
700081b0:	f003 0340 	and.w	r3, r3, #64	@ 0x40
700081b4:	b2db      	uxtb	r3, r3
700081b6:	2b00      	cmp	r3, #0
700081b8:	d003      	beq.n	700081c2 <SFDP_BuildGenericDriver+0x91a>
        {
          Object->sfdp_private.DriverInfo.PageProgramInstruction = 0x12u;
700081ba:	687b      	ldr	r3, [r7, #4]
700081bc:	2212      	movs	r2, #18
700081be:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
        }
        if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S1S_FastReadCommand)
700081c2:	4b39      	ldr	r3, [pc, #228]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
700081c4:	781b      	ldrb	r3, [r3, #0]
700081c6:	f003 0302 	and.w	r3, r3, #2
700081ca:	b2db      	uxtb	r3, r3
700081cc:	2b00      	cmp	r3, #0
700081ce:	d00d      	beq.n	700081ec <SFDP_BuildGenericDriver+0x944>
        {
          Object->sfdp_private.DriverInfo.ReadInstruction = 0x0Cu;
700081d0:	687b      	ldr	r3, [r7, #4]
700081d2:	220c      	movs	r2, #12
700081d4:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
          dummyCycles = EXTMEM_FAST_READ_NB_DUMMY_CYCLES_DEFAULT;
700081d8:	2308      	movs	r3, #8
700081da:	617b      	str	r3, [r7, #20]
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
700081dc:	687b      	ldr	r3, [r7, #4]
700081de:	3308      	adds	r3, #8
700081e0:	f107 0214 	add.w	r2, r7, #20
700081e4:	2101      	movs	r1, #1
700081e6:	4618      	mov	r0, r3
700081e8:	f7fe fc76 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
        }
      }

      if (PHY_LINK_1S1S2S == Object->sfdp_private.DriverInfo.SpiPhyLink)
700081ec:	687b      	ldr	r3, [r7, #4]
700081ee:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
700081f2:	2b01      	cmp	r3, #1
700081f4:	d10a      	bne.n	7000820c <SFDP_BuildGenericDriver+0x964>
      {
        if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1S2S_FastReadCommand)
700081f6:	4b2c      	ldr	r3, [pc, #176]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
700081f8:	781b      	ldrb	r3, [r3, #0]
700081fa:	f003 0304 	and.w	r3, r3, #4
700081fe:	b2db      	uxtb	r3, r3
70008200:	2b00      	cmp	r3, #0
70008202:	d003      	beq.n	7000820c <SFDP_BuildGenericDriver+0x964>
        {
          Object->sfdp_private.DriverInfo.ReadInstruction = 0x3CU;
70008204:	687b      	ldr	r3, [r7, #4]
70008206:	223c      	movs	r2, #60	@ 0x3c
70008208:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        }
      }

      if (PHY_LINK_1S2S2S == Object->sfdp_private.DriverInfo.SpiPhyLink)
7000820c:	687b      	ldr	r3, [r7, #4]
7000820e:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
70008212:	2b02      	cmp	r3, #2
70008214:	d10a      	bne.n	7000822c <SFDP_BuildGenericDriver+0x984>
      {
        if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S2S2S_FastReadCommand)
70008216:	4b24      	ldr	r3, [pc, #144]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
70008218:	781b      	ldrb	r3, [r3, #0]
7000821a:	f003 0308 	and.w	r3, r3, #8
7000821e:	b2db      	uxtb	r3, r3
70008220:	2b00      	cmp	r3, #0
70008222:	d003      	beq.n	7000822c <SFDP_BuildGenericDriver+0x984>
        {
          Object->sfdp_private.DriverInfo.ReadInstruction = 0xBCU;
70008224:	687b      	ldr	r3, [r7, #4]
70008226:	22bc      	movs	r2, #188	@ 0xbc
70008228:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        }
      }

      if (PHY_LINK_1S1D1D == Object->sfdp_private.DriverInfo.SpiPhyLink)
7000822c:	687b      	ldr	r3, [r7, #4]
7000822e:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
70008232:	2b03      	cmp	r3, #3
70008234:	d10a      	bne.n	7000824c <SFDP_BuildGenericDriver+0x9a4>
      {
        if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S1D1D_DTRReadCommand)
70008236:	4b1c      	ldr	r3, [pc, #112]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
70008238:	785b      	ldrb	r3, [r3, #1]
7000823a:	f003 0320 	and.w	r3, r3, #32
7000823e:	b2db      	uxtb	r3, r3
70008240:	2b00      	cmp	r3, #0
70008242:	d003      	beq.n	7000824c <SFDP_BuildGenericDriver+0x9a4>
        {
          Object->sfdp_private.DriverInfo.ReadInstruction = 0x0EU;
70008244:	687b      	ldr	r3, [r7, #4]
70008246:	220e      	movs	r2, #14
70008248:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        }
      }
    }

    if ((EXTMEM_LINK_CONFIG_8LINES == Object->sfdp_private.Config)
7000824c:	687b      	ldr	r3, [r7, #4]
7000824e:	f893 305c 	ldrb.w	r3, [r3, #92]	@ 0x5c
70008252:	2b03      	cmp	r3, #3
70008254:	d132      	bne.n	700082bc <SFDP_BuildGenericDriver+0xa14>
        && (PHY_LINK_1S1S1S == Object->sfdp_private.DriverInfo.SpiPhyLink))
70008256:	687b      	ldr	r3, [r7, #4]
70008258:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
7000825c:	2b00      	cmp	r3, #0
7000825e:	d12d      	bne.n	700082bc <SFDP_BuildGenericDriver+0xa14>
    {
      /* check if we can switch to 1S8S8S */
      if ((0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_FastReadCommand)
70008260:	4b11      	ldr	r3, [pc, #68]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
70008262:	789b      	ldrb	r3, [r3, #2]
70008264:	f003 0320 	and.w	r3, r3, #32
70008268:	b2db      	uxtb	r3, r3
7000826a:	2b00      	cmp	r3, #0
7000826c:	d026      	beq.n	700082bc <SFDP_BuildGenericDriver+0xa14>
          && (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_PageProgramCommand))
7000826e:	4b0e      	ldr	r3, [pc, #56]	@ (700082a8 <SFDP_BuildGenericDriver+0xa00>)
70008270:	78db      	ldrb	r3, [r3, #3]
70008272:	f003 0301 	and.w	r3, r3, #1
70008276:	b2db      	uxtb	r3, r3
70008278:	2b00      	cmp	r3, #0
7000827a:	d01f      	beq.n	700082bc <SFDP_BuildGenericDriver+0xa14>
      {
        /* Patch Micron write command 0x81 @0x0 0xE7 */
        Object->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S8S8S;
7000827c:	687b      	ldr	r3, [r7, #4]
7000827e:	2207      	movs	r2, #7
70008280:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
70008284:	687b      	ldr	r3, [r7, #4]
70008286:	f103 0008 	add.w	r0, r3, #8
                                            &Object->sfdp_private.DriverInfo.SpiPhyLink))
7000828a:	687b      	ldr	r3, [r7, #4]
7000828c:	3364      	adds	r3, #100	@ 0x64
        if (HAL_OK != SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_PHY_LINK,
7000828e:	461a      	mov	r2, r3
70008290:	2100      	movs	r1, #0
70008292:	f7fe fc21 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
70008296:	4603      	mov	r3, r0
70008298:	2b00      	cmp	r3, #0
7000829a:	d007      	beq.n	700082ac <SFDP_BuildGenericDriver+0xa04>
        {
          retr = EXTMEM_SFDP_ERROR_DRIVER;
7000829c:	230c      	movs	r3, #12
7000829e:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
          goto error;
700082a2:	e13e      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
700082a4:	2400037c 	.word	0x2400037c
700082a8:	240003dc 	.word	0x240003dc
        }
        Object->sfdp_private.DriverInfo.ReadInstruction = 0xCC;
700082ac:	687b      	ldr	r3, [r7, #4]
700082ae:	22cc      	movs	r2, #204	@ 0xcc
700082b0:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        Object->sfdp_private.DriverInfo.PageProgramInstruction = 0x8E;
700082b4:	687b      	ldr	r3, [r7, #4]
700082b6:	228e      	movs	r2, #142	@ 0x8e
700082b8:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75

    /*
      need to be study more; it seems that Macronix used it to define the command maybe because only one mode is
      supported in their case
    */
    if (Object->sfdp_private.DriverInfo.SpiPhyLink == PHY_LINK_8S8D8D)
700082bc:	687b      	ldr	r3, [r7, #4]
700082be:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
700082c2:	2b08      	cmp	r3, #8
700082c4:	d12a      	bne.n	7000831c <SFDP_BuildGenericDriver+0xa74>
    {
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_PageProgramCommand)
700082c6:	4b9a      	ldr	r3, [pc, #616]	@ (70008530 <SFDP_BuildGenericDriver+0xc88>)
700082c8:	78db      	ldrb	r3, [r3, #3]
700082ca:	f003 0301 	and.w	r3, r3, #1
700082ce:	b2db      	uxtb	r3, r3
700082d0:	2b00      	cmp	r3, #0
700082d2:	d003      	beq.n	700082dc <SFDP_BuildGenericDriver+0xa34>
      {
        Object->sfdp_private.DriverInfo.PageProgramInstruction  = 0x02u;
700082d4:	687b      	ldr	r3, [r7, #4]
700082d6:	2202      	movs	r2, #2
700082d8:	f883 2075 	strb.w	r2, [r3, #117]	@ 0x75
      }
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8S8S_FastReadCommand)
700082dc:	4b94      	ldr	r3, [pc, #592]	@ (70008530 <SFDP_BuildGenericDriver+0xc88>)
700082de:	789b      	ldrb	r3, [r3, #2]
700082e0:	f003 0320 	and.w	r3, r3, #32
700082e4:	b2db      	uxtb	r3, r3
700082e6:	2b00      	cmp	r3, #0
700082e8:	d00d      	beq.n	70008306 <SFDP_BuildGenericDriver+0xa5e>
      {
        Object->sfdp_private.DriverInfo.ReadInstruction         = 0xCCu;
700082ea:	687b      	ldr	r3, [r7, #4]
700082ec:	22cc      	movs	r2, #204	@ 0xcc
700082ee:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
        dummyCycles = EXTMEM_FAST_READ_NB_DUMMY_CYCLES_DEFAULT;
700082f2:	2308      	movs	r3, #8
700082f4:	617b      	str	r3, [r7, #20]
        (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
700082f6:	687b      	ldr	r3, [r7, #4]
700082f8:	3308      	adds	r3, #8
700082fa:	f107 0214 	add.w	r2, r7, #20
700082fe:	2101      	movs	r1, #1
70008300:	4618      	mov	r0, r3
70008302:	f7fe fbe9 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
      }
      if (0u != JEDEC_Address4Bytes.Param_DWORD.D1.Support_1S8D8D_DTRReadCommand)
70008306:	4b8a      	ldr	r3, [pc, #552]	@ (70008530 <SFDP_BuildGenericDriver+0xc88>)
70008308:	789b      	ldrb	r3, [r3, #2]
7000830a:	f003 0340 	and.w	r3, r3, #64	@ 0x40
7000830e:	b2db      	uxtb	r3, r3
70008310:	2b00      	cmp	r3, #0
70008312:	d003      	beq.n	7000831c <SFDP_BuildGenericDriver+0xa74>
      {
        Object->sfdp_private.DriverInfo.ReadInstruction         = 0xFDu;
70008314:	687b      	ldr	r3, [r7, #4]
70008316:	22fd      	movs	r2, #253	@ 0xfd
70008318:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
      }
    }

    Object->sfdp_private.DriverInfo.EraseType1Command =
      (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType1;
7000831c:	4b84      	ldr	r3, [pc, #528]	@ (70008530 <SFDP_BuildGenericDriver+0xc88>)
7000831e:	791a      	ldrb	r2, [r3, #4]
    Object->sfdp_private.DriverInfo.EraseType1Command =
70008320:	687b      	ldr	r3, [r7, #4]
70008322:	f883 2078 	strb.w	r2, [r3, #120]	@ 0x78
    Object->sfdp_private.DriverInfo.EraseType2Command =
      (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType2;
70008326:	4b82      	ldr	r3, [pc, #520]	@ (70008530 <SFDP_BuildGenericDriver+0xc88>)
70008328:	795a      	ldrb	r2, [r3, #5]
    Object->sfdp_private.DriverInfo.EraseType2Command =
7000832a:	687b      	ldr	r3, [r7, #4]
7000832c:	f883 207a 	strb.w	r2, [r3, #122]	@ 0x7a
    Object->sfdp_private.DriverInfo.EraseType3Command =
      (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType3;
70008330:	4b7f      	ldr	r3, [pc, #508]	@ (70008530 <SFDP_BuildGenericDriver+0xc88>)
70008332:	799a      	ldrb	r2, [r3, #6]
    Object->sfdp_private.DriverInfo.EraseType3Command =
70008334:	687b      	ldr	r3, [r7, #4]
70008336:	f883 207c 	strb.w	r2, [r3, #124]	@ 0x7c
    Object->sfdp_private.DriverInfo.EraseType4Command =
      (uint8_t)JEDEC_Address4Bytes.Param_DWORD.D2.InstructionEraseType4;
7000833a:	4b7d      	ldr	r3, [pc, #500]	@ (70008530 <SFDP_BuildGenericDriver+0xc88>)
7000833c:	79da      	ldrb	r2, [r3, #7]
    Object->sfdp_private.DriverInfo.EraseType4Command =
7000833e:	687b      	ldr	r3, [r7, #4]
70008340:	f883 207e 	strb.w	r2, [r3, #126]	@ 0x7e
  }

  if (((uint32_t)SFDP_PARAMID_XSPI_V1_0 == (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_XSPI_V1_0))
70008344:	687b      	ldr	r3, [r7, #4]
70008346:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
7000834a:	f003 0380 	and.w	r3, r3, #128	@ 0x80
7000834e:	2b00      	cmp	r3, #0
70008350:	f000 80e6 	beq.w	70008520 <SFDP_BuildGenericDriver+0xc78>
      &&
      ((PHY_LINK_8D8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)
70008354:	687b      	ldr	r3, [r7, #4]
70008356:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
      &&
7000835a:	2b09      	cmp	r3, #9
7000835c:	d005      	beq.n	7000836a <SFDP_BuildGenericDriver+0xac2>
       || (PHY_LINK_8S8D8D == Object->sfdp_private.DriverInfo.SpiPhyLink)))
7000835e:	687b      	ldr	r3, [r7, #4]
70008360:	f893 3064 	ldrb.w	r3, [r3, #100]	@ 0x64
70008364:	2b08      	cmp	r3, #8
70008366:	f040 80db 	bne.w	70008520 <SFDP_BuildGenericDriver+0xc78>
  {
    uint32_t ClockOut = 0u;
7000836a:	2300      	movs	r3, #0
7000836c:	60fb      	str	r3, [r7, #12]
    uint32_t MaxFreqMhz;
    /* Read command */
    if (0u != JEDEC_XSPI10.Param_DWORD.D1.ReadFastCommand)
7000836e:	4b71      	ldr	r3, [pc, #452]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008370:	785b      	ldrb	r3, [r3, #1]
70008372:	2b00      	cmp	r3, #0
70008374:	d004      	beq.n	70008380 <SFDP_BuildGenericDriver+0xad8>
    {
      Object->sfdp_private.DriverInfo.ReadInstruction = (uint8_t)JEDEC_XSPI10.Param_DWORD.D1.ReadFastCommand;
70008376:	4b6f      	ldr	r3, [pc, #444]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008378:	785a      	ldrb	r2, [r3, #1]
7000837a:	687b      	ldr	r3, [r7, #4]
7000837c:	f883 2076 	strb.w	r2, [r3, #118]	@ 0x76
    }

    if (JEDEC_XSPI10.Param_DWORD.D6._8D8D8DDefaultPOR_DummyCycle != 0u)
70008380:	4b6c      	ldr	r3, [pc, #432]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008382:	7d1b      	ldrb	r3, [r3, #20]
70008384:	f003 031f 	and.w	r3, r3, #31
70008388:	b2db      	uxtb	r3, r3
7000838a:	2b00      	cmp	r3, #0
7000838c:	d00d      	beq.n	700083aa <SFDP_BuildGenericDriver+0xb02>
    {
      /* Set the default dummy cycle of this mode */
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D6._8D8D8DDefaultPOR_DummyCycle;
7000838e:	4b69      	ldr	r3, [pc, #420]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008390:	7d1b      	ldrb	r3, [r3, #20]
70008392:	f3c3 0304 	ubfx	r3, r3, #0, #5
70008396:	b2db      	uxtb	r3, r3
70008398:	617b      	str	r3, [r7, #20]
      (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
7000839a:	687b      	ldr	r3, [r7, #4]
7000839c:	3308      	adds	r3, #8
7000839e:	f107 0214 	add.w	r2, r7, #20
700083a2:	2101      	movs	r1, #1
700083a4:	4618      	mov	r0, r3
700083a6:	f7fe fb97 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
    }

    /* Adapt the memory interface frequency according to its capabilities */
    MaxFreqMhz = sfdp_getfrequencevalue(JEDEC_Basic.Params.Param_DWORD.D20._8D8D8D_MaximumSpeedWithStrobe);
700083aa:	4b63      	ldr	r3, [pc, #396]	@ (70008538 <SFDP_BuildGenericDriver+0xc90>)
700083ac:	f893 3053 	ldrb.w	r3, [r3, #83]	@ 0x53
700083b0:	f3c3 1303 	ubfx	r3, r3, #4, #4
700083b4:	b2db      	uxtb	r3, r3
700083b6:	4618      	mov	r0, r3
700083b8:	f000 f906 	bl	700085c8 <sfdp_getfrequencevalue>
700083bc:	61f8      	str	r0, [r7, #28]
    if (MaxFreqMhz > Object->sfdp_private.DriverInfo.ClockIn)
700083be:	687b      	ldr	r3, [r7, #4]
700083c0:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
700083c2:	69fa      	ldr	r2, [r7, #28]
700083c4:	429a      	cmp	r2, r3
700083c6:	d902      	bls.n	700083ce <SFDP_BuildGenericDriver+0xb26>
    {
      /* Adjust the frequency with the ClockIn */
      MaxFreqMhz = Object->sfdp_private.DriverInfo.ClockIn;
700083c8:	687b      	ldr	r3, [r7, #4]
700083ca:	6e9b      	ldr	r3, [r3, #104]	@ 0x68
700083cc:	61fb      	str	r3, [r7, #28]
    }

    /* Adapt the memory interface frequency according to max requested frequency as defined in configuration table. */
    if (Object->sfdp_public.MaxFreq != 0)
700083ce:	687b      	ldr	r3, [r7, #4]
700083d0:	681b      	ldr	r3, [r3, #0]
700083d2:	2b00      	cmp	r3, #0
700083d4:	d007      	beq.n	700083e6 <SFDP_BuildGenericDriver+0xb3e>
    {
      if (MaxFreqMhz > Object->sfdp_public.MaxFreq)
700083d6:	687b      	ldr	r3, [r7, #4]
700083d8:	681b      	ldr	r3, [r3, #0]
700083da:	69fa      	ldr	r2, [r7, #28]
700083dc:	429a      	cmp	r2, r3
700083de:	d902      	bls.n	700083e6 <SFDP_BuildGenericDriver+0xb3e>
      {
        /* Adjust the frequency with the max clock frequency defined in configuration table */
        MaxFreqMhz = Object->sfdp_public.MaxFreq;
700083e0:	687b      	ldr	r3, [r7, #4]
700083e2:	681b      	ldr	r3, [r3, #0]
700083e4:	61fb      	str	r3, [r7, #28]
      }
    }

    /* Update the clock to be aligned with selected configuration */
    if (HAL_OK != SAL_XSPI_SetClock(&Object->sfdp_private.SALObject, Object->sfdp_private.DriverInfo.ClockIn,
700083e6:	687b      	ldr	r3, [r7, #4]
700083e8:	f103 0008 	add.w	r0, r3, #8
700083ec:	687b      	ldr	r3, [r7, #4]
700083ee:	6e99      	ldr	r1, [r3, #104]	@ 0x68
700083f0:	f107 030c 	add.w	r3, r7, #12
700083f4:	69fa      	ldr	r2, [r7, #28]
700083f6:	f7fe fafd 	bl	700069f4 <SAL_XSPI_SetClock>
700083fa:	4603      	mov	r3, r0
700083fc:	2b00      	cmp	r3, #0
700083fe:	d003      	beq.n	70008408 <SFDP_BuildGenericDriver+0xb60>
                                    MaxFreqMhz, &ClockOut))
    {
      retr = EXTMEM_SFDP_ERROR_SETCLOCK;
70008400:	230d      	movs	r3, #13
70008402:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
      goto error;
70008406:	e08c      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
    }
    *FreqUpdated = 1u; /* Used to indicate that the clock configuration has been updated */
70008408:	683b      	ldr	r3, [r7, #0]
7000840a:	2201      	movs	r2, #1
7000840c:	701a      	strb	r2, [r3, #0]

    /* get the dummy cycle value according to the real output clock */
    if ((ClockOut >= CLOCK_200MHZ) && (JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_DummyCycle != 0u))
7000840e:	68fb      	ldr	r3, [r7, #12]
70008410:	4a4a      	ldr	r2, [pc, #296]	@ (7000853c <SFDP_BuildGenericDriver+0xc94>)
70008412:	4293      	cmp	r3, r2
70008414:	d913      	bls.n	7000843e <SFDP_BuildGenericDriver+0xb96>
70008416:	4b47      	ldr	r3, [pc, #284]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008418:	899b      	ldrh	r3, [r3, #12]
7000841a:	f403 6378 	and.w	r3, r3, #3968	@ 0xf80
7000841e:	b29b      	uxth	r3, r3
70008420:	2b00      	cmp	r3, #0
70008422:	d00c      	beq.n	7000843e <SFDP_BuildGenericDriver+0xb96>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_DummyCycle;
70008424:	4b43      	ldr	r3, [pc, #268]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008426:	899b      	ldrh	r3, [r3, #12]
70008428:	f3c3 13c4 	ubfx	r3, r3, #7, #5
7000842c:	b2db      	uxtb	r3, r3
7000842e:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D4.Operation200Mhz_ConfigPattern;
70008430:	4b40      	ldr	r3, [pc, #256]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008432:	7b1b      	ldrb	r3, [r3, #12]
70008434:	f3c3 0384 	ubfx	r3, r3, #2, #5
70008438:	b2db      	uxtb	r3, r3
7000843a:	623b      	str	r3, [r7, #32]
7000843c:	e03b      	b.n	700084b6 <SFDP_BuildGenericDriver+0xc0e>
    }
    else if ((ClockOut >= CLOCK_166MHZ) && (JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_DummyCycle != 0u))
7000843e:	68fb      	ldr	r3, [r7, #12]
70008440:	4a3f      	ldr	r2, [pc, #252]	@ (70008540 <SFDP_BuildGenericDriver+0xc98>)
70008442:	4293      	cmp	r3, r2
70008444:	d913      	bls.n	7000846e <SFDP_BuildGenericDriver+0xbc6>
70008446:	4b3b      	ldr	r3, [pc, #236]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008448:	7cdb      	ldrb	r3, [r3, #19]
7000844a:	f023 0307 	bic.w	r3, r3, #7
7000844e:	b2db      	uxtb	r3, r3
70008450:	2b00      	cmp	r3, #0
70008452:	d00c      	beq.n	7000846e <SFDP_BuildGenericDriver+0xbc6>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_DummyCycle;
70008454:	4b37      	ldr	r3, [pc, #220]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008456:	7cdb      	ldrb	r3, [r3, #19]
70008458:	f3c3 03c4 	ubfx	r3, r3, #3, #5
7000845c:	b2db      	uxtb	r3, r3
7000845e:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation166Mhz_ConfigPattern;
70008460:	4b34      	ldr	r3, [pc, #208]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008462:	8a5b      	ldrh	r3, [r3, #18]
70008464:	f3c3 1384 	ubfx	r3, r3, #6, #5
70008468:	b2db      	uxtb	r3, r3
7000846a:	623b      	str	r3, [r7, #32]
7000846c:	e023      	b.n	700084b6 <SFDP_BuildGenericDriver+0xc0e>
    }
    else if ((ClockOut >= CLOCK_133MHZ) && (JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_DummyCycle != 0u))
7000846e:	68fb      	ldr	r3, [r7, #12]
70008470:	4a34      	ldr	r2, [pc, #208]	@ (70008544 <SFDP_BuildGenericDriver+0xc9c>)
70008472:	4293      	cmp	r3, r2
70008474:	d913      	bls.n	7000849e <SFDP_BuildGenericDriver+0xbf6>
70008476:	4b2f      	ldr	r3, [pc, #188]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008478:	7c9b      	ldrb	r3, [r3, #18]
7000847a:	f003 033e 	and.w	r3, r3, #62	@ 0x3e
7000847e:	b2db      	uxtb	r3, r3
70008480:	2b00      	cmp	r3, #0
70008482:	d00c      	beq.n	7000849e <SFDP_BuildGenericDriver+0xbf6>
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_DummyCycle;
70008484:	4b2b      	ldr	r3, [pc, #172]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008486:	7c9b      	ldrb	r3, [r3, #18]
70008488:	f3c3 0344 	ubfx	r3, r3, #1, #5
7000848c:	b2db      	uxtb	r3, r3
7000848e:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation133Mhz_ConfigPattern;
70008490:	4b28      	ldr	r3, [pc, #160]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
70008492:	691b      	ldr	r3, [r3, #16]
70008494:	f3c3 3304 	ubfx	r3, r3, #12, #5
70008498:	b2db      	uxtb	r3, r3
7000849a:	623b      	str	r3, [r7, #32]
7000849c:	e00b      	b.n	700084b6 <SFDP_BuildGenericDriver+0xc0e>
    }
    else /* if (ClockOut =< 100Mhz) */
    {
      dummyCycles = JEDEC_XSPI10.Param_DWORD.D5.Operation100Mhz_DummyCycle;
7000849e:	4b25      	ldr	r3, [pc, #148]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
700084a0:	8a1b      	ldrh	r3, [r3, #16]
700084a2:	f3c3 13c4 	ubfx	r3, r3, #7, #5
700084a6:	b2db      	uxtb	r3, r3
700084a8:	617b      	str	r3, [r7, #20]
      dummyCyclesValue = JEDEC_XSPI10.Param_DWORD.D5.Operation100Mhz_ConfigPattern;
700084aa:	4b22      	ldr	r3, [pc, #136]	@ (70008534 <SFDP_BuildGenericDriver+0xc8c>)
700084ac:	7c1b      	ldrb	r3, [r3, #16]
700084ae:	f3c3 0384 	ubfx	r3, r3, #2, #5
700084b2:	b2db      	uxtb	r3, r3
700084b4:	623b      	str	r3, [r7, #32]
    }

    /* Specific case of GigaDevice memory with wrongly coded SFDP table in JEDEC_SCCR_Map.Param_DWORD.D9 */
    if (Object->sfdp_private.ManuID == EXTMEM_MANUFACTURER_GIGADEVICE)
700084b6:	687b      	ldr	r3, [r7, #4]
700084b8:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
700084bc:	2bc8      	cmp	r3, #200	@ 0xc8
700084be:	d10a      	bne.n	700084d6 <SFDP_BuildGenericDriver+0xc2e>
    {
      dummyCycles = 16;
700084c0:	2310      	movs	r3, #16
700084c2:	617b      	str	r3, [r7, #20]
      (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
700084c4:	687b      	ldr	r3, [r7, #4]
700084c6:	3308      	adds	r3, #8
700084c8:	f107 0214 	add.w	r2, r7, #20
700084cc:	2101      	movs	r1, #1
700084ce:	4618      	mov	r0, r3
700084d0:	f7fe fb02 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
700084d4:	e025      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
    }
    else
    {
      /* Write the dummy cycle value in the configuration register using information coming from SCCR Map */
      if ((0u != (Object->sfdp_private.Sfdp_table_mask & (uint32_t)SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP))
700084d6:	687b      	ldr	r3, [r7, #4]
700084d8:	f8d3 3094 	ldr.w	r3, [r3, #148]	@ 0x94
700084dc:	f403 7300 	and.w	r3, r3, #512	@ 0x200
700084e0:	2b00      	cmp	r3, #0
700084e2:	d017      	beq.n	70008514 <SFDP_BuildGenericDriver+0xc6c>
          && (0u != JEDEC_SCCR_Map.Param_DWORD.D9.BitAvailable))
700084e4:	4b18      	ldr	r3, [pc, #96]	@ (70008548 <SFDP_BuildGenericDriver+0xca0>)
700084e6:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
700084ea:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
700084ee:	b2db      	uxtb	r3, r3
700084f0:	2b00      	cmp	r3, #0
700084f2:	d00f      	beq.n	70008514 <SFDP_BuildGenericDriver+0xc6c>
      {
        /* Update the frequency with MaxFreqMhz information */
        if (sfdp_set_dummycycle(Object, dummyCyclesValue) == EXTMEM_SFDP_OK)
700084f4:	6a39      	ldr	r1, [r7, #32]
700084f6:	6878      	ldr	r0, [r7, #4]
700084f8:	f000 fa6c 	bl	700089d4 <sfdp_set_dummycycle>
700084fc:	4603      	mov	r3, r0
700084fe:	2b00      	cmp	r3, #0
70008500:	d10f      	bne.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
        {
          /* Set the dummy cycle corresponding */
          (void)SAL_XSPI_MemoryConfig(&Object->sfdp_private.SALObject, PARAM_DUMMY_CYCLES, (void *)&dummyCycles);
70008502:	687b      	ldr	r3, [r7, #4]
70008504:	3308      	adds	r3, #8
70008506:	f107 0214 	add.w	r2, r7, #20
7000850a:	2101      	movs	r1, #1
7000850c:	4618      	mov	r0, r3
7000850e:	f7fe fae3 	bl	70006ad8 <SAL_XSPI_MemoryConfig>
        if (sfdp_set_dummycycle(Object, dummyCyclesValue) == EXTMEM_SFDP_OK)
70008512:	e006      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
        }
      }
      else
      {
        retr = EXTMEM_SFDP_ERROR_CONFIGDUMMY;
70008514:	230e      	movs	r3, #14
70008516:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
        goto error;
7000851a:	e002      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
          goto error;
7000851c:	bf00      	nop
7000851e:	e000      	b.n	70008522 <SFDP_BuildGenericDriver+0xc7a>
      }
    }
  }

error :
70008520:	bf00      	nop
  return retr;
70008522:	f897 3027 	ldrb.w	r3, [r7, #39]	@ 0x27
}
70008526:	4618      	mov	r0, r3
70008528:	372c      	adds	r7, #44	@ 0x2c
7000852a:	46bd      	mov	sp, r7
7000852c:	bdf0      	pop	{r4, r5, r6, r7, pc}
7000852e:	bf00      	nop
70008530:	240003dc 	.word	0x240003dc
70008534:	240003e4 	.word	0x240003e4
70008538:	2400037c 	.word	0x2400037c
7000853c:	0bebc1ff 	.word	0x0bebc1ff
70008540:	09e4f57f 	.word	0x09e4f57f
70008544:	07ed6b3f 	.word	0x07ed6b3f
70008548:	240003fc 	.word	0x240003fc

7000854c <driver_check_FlagBUSY>:
  * @retval EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef Status of the operation: EXTMEM_DRIVER_NOR_SFDP_OK if not busy,
  *         error code otherwise.
  */
EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef driver_check_FlagBUSY(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *SFDPObject,
                                                           uint32_t Timeout)
{
7000854c:	b5f0      	push	{r4, r5, r6, r7, lr}
7000854e:	b089      	sub	sp, #36	@ 0x24
70008550:	af04      	add	r7, sp, #16
70008552:	6078      	str	r0, [r7, #4]
70008554:	6039      	str	r1, [r7, #0]
  EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_BUSY;
70008556:	23fb      	movs	r3, #251	@ 0xfb
70008558:	73fb      	strb	r3, [r7, #15]
  SFDP_DEBUG_STR((uint8_t *)__func__)
  if (0u != SFDPObject->sfdp_private.DriverInfo.ReadWIPCommand)
7000855a:	687b      	ldr	r3, [r7, #4]
7000855c:	f893 306c 	ldrb.w	r3, [r3, #108]	@ 0x6c
70008560:	2b00      	cmp	r3, #0
70008562:	d02b      	beq.n	700085bc <driver_check_FlagBUSY+0x70>
  {
    /* check that the WIP flag is not set */
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
70008564:	687b      	ldr	r3, [r7, #4]
70008566:	f103 0008 	add.w	r0, r3, #8
7000856a:	687b      	ldr	r3, [r7, #4]
7000856c:	f893 406c 	ldrb.w	r4, [r3, #108]	@ 0x6c
                                               SFDPObject->sfdp_private.DriverInfo.ReadWIPCommand,
                                               SFDPObject->sfdp_private.DriverInfo.WIPAddress,
70008570:	687b      	ldr	r3, [r7, #4]
70008572:	f893 306f 	ldrb.w	r3, [r3, #111]	@ 0x6f
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
70008576:	461e      	mov	r6, r3
                                               SFDPObject->sfdp_private.DriverInfo.WIPBusyPolarity
70008578:	687b      	ldr	r3, [r7, #4]
7000857a:	f893 306e 	ldrb.w	r3, [r3, #110]	@ 0x6e
7000857e:	461a      	mov	r2, r3
                                               << SFDPObject->sfdp_private.DriverInfo.WIPPosition,
70008580:	687b      	ldr	r3, [r7, #4]
70008582:	f893 306d 	ldrb.w	r3, [r3, #109]	@ 0x6d
70008586:	fa02 f303 	lsl.w	r3, r2, r3
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
7000858a:	b2dd      	uxtb	r5, r3
                                               1u << SFDPObject->sfdp_private.DriverInfo.WIPPosition,
7000858c:	687b      	ldr	r3, [r7, #4]
7000858e:	f893 306d 	ldrb.w	r3, [r3, #109]	@ 0x6d
70008592:	461a      	mov	r2, r3
70008594:	2301      	movs	r3, #1
70008596:	4093      	lsls	r3, r2
    if (HAL_OK == SAL_XSPI_CheckStatusRegister(&SFDPObject->sfdp_private.SALObject,
70008598:	b2db      	uxtb	r3, r3
7000859a:	687a      	ldr	r2, [r7, #4]
7000859c:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
700085a0:	6839      	ldr	r1, [r7, #0]
700085a2:	9102      	str	r1, [sp, #8]
700085a4:	9201      	str	r2, [sp, #4]
700085a6:	9300      	str	r3, [sp, #0]
700085a8:	462b      	mov	r3, r5
700085aa:	4632      	mov	r2, r6
700085ac:	4621      	mov	r1, r4
700085ae:	f7fe fe1b 	bl	700071e8 <SAL_XSPI_CheckStatusRegister>
700085b2:	4603      	mov	r3, r0
700085b4:	2b00      	cmp	r3, #0
700085b6:	d101      	bne.n	700085bc <driver_check_FlagBUSY+0x70>
                                               SFDPObject->sfdp_private.ManuID, Timeout))
    {
      retr = EXTMEM_DRIVER_NOR_SFDP_OK;
700085b8:	2300      	movs	r3, #0
700085ba:	73fb      	strb	r3, [r7, #15]
    }
  }
  return retr;
700085bc:	f997 300f 	ldrsb.w	r3, [r7, #15]
}
700085c0:	4618      	mov	r0, r3
700085c2:	3714      	adds	r7, #20
700085c4:	46bd      	mov	sp, r7
700085c6:	bdf0      	pop	{r4, r5, r6, r7, pc}

700085c8 <sfdp_getfrequencevalue>:
  * @brief Returns the frequency value in Hz corresponding to a bit field.
  * @param BitField Bit field value from SFDP table.
  * @return Frequency value in Hz, or 0 if unknown.
  */
uint32_t sfdp_getfrequencevalue(uint32_t BitField)
{
700085c8:	b4b0      	push	{r4, r5, r7}
700085ca:	b08b      	sub	sp, #44	@ 0x2c
700085cc:	af00      	add	r7, sp, #0
700085ce:	6078      	str	r0, [r7, #4]
  const uint16_t freqMhz_table[] = { 0x0, 33, 50, 66, 80, 100, 133, 166, 200, 250, 266, 333, 400 };
700085d0:	4b0e      	ldr	r3, [pc, #56]	@ (7000860c <sfdp_getfrequencevalue+0x44>)
700085d2:	f107 040c 	add.w	r4, r7, #12
700085d6:	461d      	mov	r5, r3
700085d8:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
700085da:	c40f      	stmia	r4!, {r0, r1, r2, r3}
700085dc:	e895 0007 	ldmia.w	r5, {r0, r1, r2}
700085e0:	c403      	stmia	r4!, {r0, r1}
700085e2:	8022      	strh	r2, [r4, #0]
  SFDP_DEBUG_STR(__func__);

  if (BitField < 0b1010u)
700085e4:	687b      	ldr	r3, [r7, #4]
700085e6:	2b09      	cmp	r3, #9
700085e8:	d80a      	bhi.n	70008600 <sfdp_getfrequencevalue+0x38>
  {
    return (uint32_t)freqMhz_table[BitField] * 1000000u;
700085ea:	687b      	ldr	r3, [r7, #4]
700085ec:	005b      	lsls	r3, r3, #1
700085ee:	3328      	adds	r3, #40	@ 0x28
700085f0:	443b      	add	r3, r7
700085f2:	f833 3c1c 	ldrh.w	r3, [r3, #-28]
700085f6:	461a      	mov	r2, r3
700085f8:	4b05      	ldr	r3, [pc, #20]	@ (70008610 <sfdp_getfrequencevalue+0x48>)
700085fa:	fb02 f303 	mul.w	r3, r2, r3
700085fe:	e000      	b.n	70008602 <sfdp_getfrequencevalue+0x3a>
  }
  return 0; /* the max frequency is unknown */
70008600:	2300      	movs	r3, #0
}
70008602:	4618      	mov	r0, r3
70008604:	372c      	adds	r7, #44	@ 0x2c
70008606:	46bd      	mov	sp, r7
70008608:	bcb0      	pop	{r4, r5, r7}
7000860a:	4770      	bx	lr
7000860c:	70009e38 	.word	0x70009e38
70008610:	000f4240 	.word	0x000f4240

70008614 <sfdp_get_paraminfo>:
  * @param Param_info Pointer to the parameter info structure to be filled.
  * @return SFDP_StatusTypeDef: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef sfdp_get_paraminfo(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t sfdp_address,
                                      SFDP_ParameterTable_t *Param_info)
{
70008614:	b580      	push	{r7, lr}
70008616:	b088      	sub	sp, #32
70008618:	af00      	add	r7, sp, #0
7000861a:	60f8      	str	r0, [r7, #12]
7000861c:	60b9      	str	r1, [r7, #8]
7000861e:	607a      	str	r2, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
70008620:	2300      	movs	r3, #0
70008622:	77fb      	strb	r3, [r7, #31]
  SFDP_ParameterHeader_t sfdp_param_header = {0};
70008624:	f107 0314 	add.w	r3, r7, #20
70008628:	2200      	movs	r2, #0
7000862a:	601a      	str	r2, [r3, #0]
7000862c:	605a      	str	r2, [r3, #4]
  SFDP_DEBUG_STR(__func__);

  /* send the SFDP command to read the header */
  if (HAL_OK != SAL_XSPI_GetSFDP(&Object->sfdp_private.SALObject, sfdp_address,
7000862e:	68fb      	ldr	r3, [r7, #12]
70008630:	f103 0008 	add.w	r0, r3, #8
70008634:	f107 0214 	add.w	r2, r7, #20
70008638:	2308      	movs	r3, #8
7000863a:	68b9      	ldr	r1, [r7, #8]
7000863c:	f7fe fb9e 	bl	70006d7c <SAL_XSPI_GetSFDP>
70008640:	4603      	mov	r3, r0
70008642:	2b00      	cmp	r3, #0
70008644:	d002      	beq.n	7000864c <sfdp_get_paraminfo+0x38>
                                 (uint8_t *)&sfdp_param_header, SFDP_PARAM_HEADER_SIZE))
  {
    retr = EXTMEM_SFDP_ERROR_SFDPREAD;
70008646:	2303      	movs	r3, #3
70008648:	77fb      	strb	r3, [r7, #31]
    goto error;
7000864a:	e0d9      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
  }

  Param_info->type = SFDP_PARAMID_UNKNOWN;
7000864c:	687b      	ldr	r3, [r7, #4]
7000864e:	2200      	movs	r2, #0
70008650:	601a      	str	r2, [r3, #0]
  Param_info->size = sfdp_param_header.Length ;
70008652:	7dfa      	ldrb	r2, [r7, #23]
70008654:	687b      	ldr	r3, [r7, #4]
70008656:	721a      	strb	r2, [r3, #8]
  Param_info->address = (((uint32_t)sfdp_param_header.TableAddressPointer[2u] << 16u)
70008658:	7ebb      	ldrb	r3, [r7, #26]
7000865a:	041a      	lsls	r2, r3, #16
                         | ((uint32_t)sfdp_param_header.TableAddressPointer[1u] << 8u)
7000865c:	7e7b      	ldrb	r3, [r7, #25]
7000865e:	021b      	lsls	r3, r3, #8
70008660:	4313      	orrs	r3, r2
                         | ((uint32_t)sfdp_param_header.TableAddressPointer[0u]));
70008662:	7e3a      	ldrb	r2, [r7, #24]
70008664:	431a      	orrs	r2, r3
  Param_info->address = (((uint32_t)sfdp_param_header.TableAddressPointer[2u] << 16u)
70008666:	687b      	ldr	r3, [r7, #4]
70008668:	605a      	str	r2, [r3, #4]

  if ((sfdp_param_header.ID_msb > 0x00u) && (sfdp_param_header.ID_msb < 0x80u))
7000866a:	7efb      	ldrb	r3, [r7, #27]
7000866c:	2b00      	cmp	r3, #0
7000866e:	d010      	beq.n	70008692 <sfdp_get_paraminfo+0x7e>
70008670:	7efb      	ldrb	r3, [r7, #27]
70008672:	b25b      	sxtb	r3, r3
70008674:	2b00      	cmp	r3, #0
70008676:	db0c      	blt.n	70008692 <sfdp_get_paraminfo+0x7e>
  {
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
70008678:	7d3b      	ldrb	r3, [r7, #20]
7000867a:	f003 0301 	and.w	r3, r3, #1
7000867e:	2b00      	cmp	r3, #0
70008680:	d003      	beq.n	7000868a <sfdp_get_paraminfo+0x76>
    {
      Param_info->type = SFDP_PARAMID_VENDOR;
70008682:	687b      	ldr	r3, [r7, #4]
70008684:	2201      	movs	r2, #1
70008686:	601a      	str	r2, [r3, #0]
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
70008688:	e0ba      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_VENDOR");
    }
    else
    {
      Param_info->type = SFDP_PARAMID_FUNCTION_VENDOR;
7000868a:	687b      	ldr	r3, [r7, #4]
7000868c:	2202      	movs	r2, #2
7000868e:	601a      	str	r2, [r3, #0]
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x01u)
70008690:	e0b6      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_FUNCTION_VENDOR");
    }
  }
  else if (sfdp_param_header.ID_msb >= 0x80u)
70008692:	7efb      	ldrb	r3, [r7, #27]
70008694:	b25b      	sxtb	r3, r3
70008696:	2b00      	cmp	r3, #0
70008698:	f280 80ae 	bge.w	700087f8 <sfdp_get_paraminfo+0x1e4>
  {
    if ((sfdp_param_header.ID_lsb & 0x01u) == 0x00u)
7000869c:	7d3b      	ldrb	r3, [r7, #20]
7000869e:	f003 0301 	and.w	r3, r3, #1
700086a2:	2b00      	cmp	r3, #0
700086a4:	d102      	bne.n	700086ac <sfdp_get_paraminfo+0x98>
    {
      Param_info->type = SFDP_PARAMID_FUNCTION_JEDEC;
700086a6:	687b      	ldr	r3, [r7, #4]
700086a8:	2204      	movs	r2, #4
700086aa:	601a      	str	r2, [r3, #0]
      SFDP_DEBUG_STR("-> type SFDP_PARAMID_FUNCTION_JEDEC");
    }

    if (sfdp_param_header.ID_msb == SFDP_BASIC_PARAMETER_TABLE_MSB)
700086ac:	7efb      	ldrb	r3, [r7, #27]
700086ae:	2bff      	cmp	r3, #255	@ 0xff
700086b0:	f040 80a6 	bne.w	70008800 <sfdp_get_paraminfo+0x1ec>
    {
      switch (sfdp_param_header.ID_lsb)
700086b4:	7d3b      	ldrb	r3, [r7, #20]
700086b6:	2b0f      	cmp	r3, #15
700086b8:	dc4c      	bgt.n	70008754 <sfdp_get_paraminfo+0x140>
700086ba:	2b00      	cmp	r3, #0
700086bc:	da24      	bge.n	70008708 <sfdp_get_paraminfo+0xf4>
          Param_info->type = SFDP_PARAMID_RESERVED;
          SFDP_DEBUG_STR("-> info SFDP_PARAMID_RESERVED");
          break;
        default :
          SFDP_DEBUG_STR("-> info SFDP_PARAMID_????");
          break;
700086be:	e09e      	b.n	700087fe <sfdp_get_paraminfo+0x1ea>
      switch (sfdp_param_header.ID_lsb)
700086c0:	3b81      	subs	r3, #129	@ 0x81
700086c2:	2b0d      	cmp	r3, #13
700086c4:	f200 809b 	bhi.w	700087fe <sfdp_get_paraminfo+0x1ea>
700086c8:	a201      	add	r2, pc, #4	@ (adr r2, 700086d0 <sfdp_get_paraminfo+0xbc>)
700086ca:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
700086ce:	bf00      	nop
700086d0:	70008775 	.word	0x70008775
700086d4:	700087ff 	.word	0x700087ff
700086d8:	700087ff 	.word	0x700087ff
700086dc:	70008785 	.word	0x70008785
700086e0:	700087ff 	.word	0x700087ff
700086e4:	700087ff 	.word	0x700087ff
700086e8:	7000879f 	.word	0x7000879f
700086ec:	700087a9 	.word	0x700087a9
700086f0:	700087ff 	.word	0x700087ff
700086f4:	700087ff 	.word	0x700087ff
700086f8:	700087c7 	.word	0x700087c7
700086fc:	700087ff 	.word	0x700087ff
70008700:	700087db 	.word	0x700087db
70008704:	700087e5 	.word	0x700087e5
70008708:	2b0f      	cmp	r3, #15
7000870a:	d878      	bhi.n	700087fe <sfdp_get_paraminfo+0x1ea>
7000870c:	a201      	add	r2, pc, #4	@ (adr r2, 70008714 <sfdp_get_paraminfo+0x100>)
7000870e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70008712:	bf00      	nop
70008714:	7000875f 	.word	0x7000875f
70008718:	700087ff 	.word	0x700087ff
7000871c:	700087ff 	.word	0x700087ff
70008720:	7000877d 	.word	0x7000877d
70008724:	700087ff 	.word	0x700087ff
70008728:	7000878d 	.word	0x7000878d
7000872c:	70008795 	.word	0x70008795
70008730:	700087ff 	.word	0x700087ff
70008734:	700087ff 	.word	0x700087ff
70008738:	700087b3 	.word	0x700087b3
7000873c:	700087bd 	.word	0x700087bd
70008740:	700087ff 	.word	0x700087ff
70008744:	700087d1 	.word	0x700087d1
70008748:	700087ff 	.word	0x700087ff
7000874c:	700087ff 	.word	0x700087ff
70008750:	700087ef 	.word	0x700087ef
70008754:	2b8e      	cmp	r3, #142	@ 0x8e
70008756:	dc52      	bgt.n	700087fe <sfdp_get_paraminfo+0x1ea>
70008758:	2b81      	cmp	r3, #129	@ 0x81
7000875a:	dab1      	bge.n	700086c0 <sfdp_get_paraminfo+0xac>
          break;
7000875c:	e04f      	b.n	700087fe <sfdp_get_paraminfo+0x1ea>
          Param_info->type = SFDP_PARAMID_BASIC_SPIPROTOCOL;
7000875e:	687b      	ldr	r3, [r7, #4]
70008760:	2208      	movs	r2, #8
70008762:	601a      	str	r2, [r3, #0]
          Param_info->size = ((sfdp_param_header.Length) < SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE)
70008764:	7dfb      	ldrb	r3, [r7, #23]
                             ? sfdp_param_header.Length : SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE;
70008766:	2b17      	cmp	r3, #23
70008768:	bf28      	it	cs
7000876a:	2317      	movcs	r3, #23
7000876c:	b2da      	uxtb	r2, r3
          Param_info->size = ((sfdp_param_header.Length) < SFDP_PARAMS_BASIC_TABLE_DEFAULTSIZE)
7000876e:	687b      	ldr	r3, [r7, #4]
70008770:	721a      	strb	r2, [r3, #8]
          break;
70008772:	e045      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_SECTORMAP;
70008774:	687b      	ldr	r3, [r7, #4]
70008776:	2210      	movs	r2, #16
70008778:	601a      	str	r2, [r3, #0]
          break;
7000877a:	e041      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_RPMC;
7000877c:	687b      	ldr	r3, [r7, #4]
7000877e:	2220      	movs	r2, #32
70008780:	601a      	str	r2, [r3, #0]
          break;
70008782:	e03d      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_4BYTE_ADDRESS_INSTRUCTION;
70008784:	687b      	ldr	r3, [r7, #4]
70008786:	2240      	movs	r2, #64	@ 0x40
70008788:	601a      	str	r2, [r3, #0]
          break;
7000878a:	e039      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_XSPI_V1_0;
7000878c:	687b      	ldr	r3, [r7, #4]
7000878e:	2280      	movs	r2, #128	@ 0x80
70008790:	601a      	str	r2, [r3, #0]
          break;
70008792:	e035      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_XSPI_V2_0;
70008794:	687b      	ldr	r3, [r7, #4]
70008796:	f44f 7280 	mov.w	r2, #256	@ 0x100
7000879a:	601a      	str	r2, [r3, #0]
          break;
7000879c:	e030      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP;
7000879e:	687b      	ldr	r3, [r7, #4]
700087a0:	f44f 7200 	mov.w	r2, #512	@ 0x200
700087a4:	601a      	str	r2, [r3, #0]
          break;
700087a6:	e02b      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_REGISTER_MAP_MULTICHIP;
700087a8:	687b      	ldr	r3, [r7, #4]
700087aa:	f44f 6280 	mov.w	r2, #1024	@ 0x400
700087ae:	601a      	str	r2, [r3, #0]
          break;
700087b0:	e026      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_STATUS_CONTROL_CONFIG_XSPI_V2_0;
700087b2:	687b      	ldr	r3, [r7, #4]
700087b4:	f44f 6200 	mov.w	r2, #2048	@ 0x800
700087b8:	601a      	str	r2, [r3, #0]
          break;
700087ba:	e021      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_OCTAL_DDR;
700087bc:	687b      	ldr	r3, [r7, #4]
700087be:	f44f 5280 	mov.w	r2, #4096	@ 0x1000
700087c2:	601a      	str	r2, [r3, #0]
          break;
700087c4:	e01c      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_MSPT;
700087c6:	687b      	ldr	r3, [r7, #4]
700087c8:	f44f 5200 	mov.w	r2, #8192	@ 0x2000
700087cc:	601a      	str	r2, [r3, #0]
          break;
700087ce:	e017      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_X4QUAD_DS;
700087d0:	687b      	ldr	r3, [r7, #4]
700087d2:	f44f 4280 	mov.w	r2, #16384	@ 0x4000
700087d6:	601a      	str	r2, [r3, #0]
          break;
700087d8:	e012      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_QUAD_DDR;
700087da:	687b      	ldr	r3, [r7, #4]
700087dc:	f44f 4200 	mov.w	r2, #32768	@ 0x8000
700087e0:	601a      	str	r2, [r3, #0]
          break;
700087e2:	e00d      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_SECURE_PACKET_READ_WRITE;
700087e4:	687b      	ldr	r3, [r7, #4]
700087e6:	f44f 3280 	mov.w	r2, #65536	@ 0x10000
700087ea:	601a      	str	r2, [r3, #0]
          break;
700087ec:	e008      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          Param_info->type = SFDP_PARAMID_RESERVED;
700087ee:	687b      	ldr	r3, [r7, #4]
700087f0:	f44f 3200 	mov.w	r2, #131072	@ 0x20000
700087f4:	601a      	str	r2, [r3, #0]
          break;
700087f6:	e003      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
  }
  else
  {
    /* Unexpected value for MSB field of SFDP Parameter ID */
    SFDP_DEBUG_STR("-> Unexpected value for MSB field of SFDP Parameter ID");
    retr = EXTMEM_SFDP_ERROR_SFDPREAD;
700087f8:	2303      	movs	r3, #3
700087fa:	77fb      	strb	r3, [r7, #31]
    goto error;
700087fc:	e000      	b.n	70008800 <sfdp_get_paraminfo+0x1ec>
          break;
700087fe:	bf00      	nop
  }

error:
  return retr;
70008800:	7ffb      	ldrb	r3, [r7, #31]
}
70008802:	4618      	mov	r0, r3
70008804:	3720      	adds	r7, #32
70008806:	46bd      	mov	sp, r7
70008808:	bd80      	pop	{r7, pc}
7000880a:	bf00      	nop

7000880c <sfdp_enter_octal_mode>:
  * @brief Executes the octal DDR table to enter octal DDR mode.
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @return SFDP_StatusTypeDef: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef sfdp_enter_octal_mode(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
7000880c:	b590      	push	{r4, r7, lr}
7000880e:	b085      	sub	sp, #20
70008810:	af00      	add	r7, sp, #0
70008812:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
70008814:	2300      	movs	r3, #0
70008816:	73fb      	strb	r3, [r7, #15]
  uint8_t data[7];
  SFDP_DEBUG_STR(__func__);
  /* D1-D2 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D1.LengthCommand)
70008818:	4b6d      	ldr	r3, [pc, #436]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000881a:	78db      	ldrb	r3, [r3, #3]
7000881c:	2b00      	cmp	r3, #0
7000881e:	d028      	beq.n	70008872 <sfdp_enter_octal_mode+0x66>
  {
    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte1CommandSequence;
70008820:	4b6b      	ldr	r3, [pc, #428]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008822:	789b      	ldrb	r3, [r3, #2]
70008824:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte2CommandSequence;
70008826:	4b6a      	ldr	r3, [pc, #424]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008828:	785b      	ldrb	r3, [r3, #1]
7000882a:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D1.Byte3CommandSequence;
7000882c:	4b68      	ldr	r3, [pc, #416]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000882e:	781b      	ldrb	r3, [r3, #0]
70008830:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte4CommandSequence;
70008832:	4b67      	ldr	r3, [pc, #412]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008834:	79db      	ldrb	r3, [r3, #7]
70008836:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte5CommandSequence;
70008838:	4b65      	ldr	r3, [pc, #404]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000883a:	799b      	ldrb	r3, [r3, #6]
7000883c:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte6CommandSequence;
7000883e:	4b64      	ldr	r3, [pc, #400]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008840:	795b      	ldrb	r3, [r3, #5]
70008842:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D2.Byte7CommandSequence;
70008844:	4b62      	ldr	r3, [pc, #392]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008846:	791b      	ldrb	r3, [r3, #4]
70008848:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
7000884a:	687b      	ldr	r3, [r7, #4]
7000884c:	f103 0008 	add.w	r0, r3, #8
70008850:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D1.LengthCommand - 1u)))
70008852:	4b5f      	ldr	r3, [pc, #380]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008854:	78db      	ldrb	r3, [r3, #3]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
70008856:	3b01      	subs	r3, #1
70008858:	b29c      	uxth	r4, r3
7000885a:	f107 0308 	add.w	r3, r7, #8
7000885e:	1c5a      	adds	r2, r3, #1
70008860:	4623      	mov	r3, r4
70008862:	f7fe fbb4 	bl	70006fce <SAL_XSPI_CommandSendData>
70008866:	4603      	mov	r3, r0
70008868:	2b00      	cmp	r3, #0
7000886a:	d002      	beq.n	70008872 <sfdp_enter_octal_mode+0x66>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
7000886c:	230b      	movs	r3, #11
7000886e:	73fb      	strb	r3, [r7, #15]
      goto error;
70008870:	e0a9      	b.n	700089c6 <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D3-D4 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D3.LengthCommand)
70008872:	4b57      	ldr	r3, [pc, #348]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008874:	7adb      	ldrb	r3, [r3, #11]
70008876:	2b00      	cmp	r3, #0
70008878:	d032      	beq.n	700088e0 <sfdp_enter_octal_mode+0xd4>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
7000887a:	2164      	movs	r1, #100	@ 0x64
7000887c:	6878      	ldr	r0, [r7, #4]
7000887e:	f7ff fe65 	bl	7000854c <driver_check_FlagBUSY>
70008882:	4603      	mov	r3, r0
70008884:	2b00      	cmp	r3, #0
70008886:	d002      	beq.n	7000888e <sfdp_enter_octal_mode+0x82>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
70008888:	230c      	movs	r3, #12
7000888a:	73fb      	strb	r3, [r7, #15]
      goto error;
7000888c:	e09b      	b.n	700089c6 <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte1CommandSequence;
7000888e:	4b50      	ldr	r3, [pc, #320]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008890:	7a9b      	ldrb	r3, [r3, #10]
70008892:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte2CommandSequence;
70008894:	4b4e      	ldr	r3, [pc, #312]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008896:	7a5b      	ldrb	r3, [r3, #9]
70008898:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D3.Byte3CommandSequence;
7000889a:	4b4d      	ldr	r3, [pc, #308]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000889c:	7a1b      	ldrb	r3, [r3, #8]
7000889e:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte4CommandSequence;
700088a0:	4b4b      	ldr	r3, [pc, #300]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
700088a2:	7bdb      	ldrb	r3, [r3, #15]
700088a4:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte5CommandSequence;
700088a6:	4b4a      	ldr	r3, [pc, #296]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
700088a8:	7b9b      	ldrb	r3, [r3, #14]
700088aa:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte6CommandSequence;
700088ac:	4b48      	ldr	r3, [pc, #288]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
700088ae:	7b5b      	ldrb	r3, [r3, #13]
700088b0:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D4.Byte7CommandSequence;
700088b2:	4b47      	ldr	r3, [pc, #284]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
700088b4:	7b1b      	ldrb	r3, [r3, #12]
700088b6:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
700088b8:	687b      	ldr	r3, [r7, #4]
700088ba:	f103 0008 	add.w	r0, r3, #8
700088be:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D3.LengthCommand - 1u)))
700088c0:	4b43      	ldr	r3, [pc, #268]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
700088c2:	7adb      	ldrb	r3, [r3, #11]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
700088c4:	3b01      	subs	r3, #1
700088c6:	b29c      	uxth	r4, r3
700088c8:	f107 0308 	add.w	r3, r7, #8
700088cc:	1c5a      	adds	r2, r3, #1
700088ce:	4623      	mov	r3, r4
700088d0:	f7fe fb7d 	bl	70006fce <SAL_XSPI_CommandSendData>
700088d4:	4603      	mov	r3, r0
700088d6:	2b00      	cmp	r3, #0
700088d8:	d002      	beq.n	700088e0 <sfdp_enter_octal_mode+0xd4>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
700088da:	230b      	movs	r3, #11
700088dc:	73fb      	strb	r3, [r7, #15]
      goto error;
700088de:	e072      	b.n	700089c6 <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D5-D6 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D5.LengthCommand)
700088e0:	4b3b      	ldr	r3, [pc, #236]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
700088e2:	7cdb      	ldrb	r3, [r3, #19]
700088e4:	2b00      	cmp	r3, #0
700088e6:	d032      	beq.n	7000894e <sfdp_enter_octal_mode+0x142>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
700088e8:	2164      	movs	r1, #100	@ 0x64
700088ea:	6878      	ldr	r0, [r7, #4]
700088ec:	f7ff fe2e 	bl	7000854c <driver_check_FlagBUSY>
700088f0:	4603      	mov	r3, r0
700088f2:	2b00      	cmp	r3, #0
700088f4:	d002      	beq.n	700088fc <sfdp_enter_octal_mode+0xf0>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
700088f6:	230c      	movs	r3, #12
700088f8:	73fb      	strb	r3, [r7, #15]
      goto error;
700088fa:	e064      	b.n	700089c6 <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte1CommandSequence;
700088fc:	4b34      	ldr	r3, [pc, #208]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
700088fe:	7c9b      	ldrb	r3, [r3, #18]
70008900:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte2CommandSequence;
70008902:	4b33      	ldr	r3, [pc, #204]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008904:	7c5b      	ldrb	r3, [r3, #17]
70008906:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D5.Byte3CommandSequence;
70008908:	4b31      	ldr	r3, [pc, #196]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000890a:	7c1b      	ldrb	r3, [r3, #16]
7000890c:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte4CommandSequence;
7000890e:	4b30      	ldr	r3, [pc, #192]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008910:	7ddb      	ldrb	r3, [r3, #23]
70008912:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte5CommandSequence;
70008914:	4b2e      	ldr	r3, [pc, #184]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008916:	7d9b      	ldrb	r3, [r3, #22]
70008918:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte6CommandSequence;
7000891a:	4b2d      	ldr	r3, [pc, #180]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000891c:	7d5b      	ldrb	r3, [r3, #21]
7000891e:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D6.Byte7CommandSequence;
70008920:	4b2b      	ldr	r3, [pc, #172]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008922:	7d1b      	ldrb	r3, [r3, #20]
70008924:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
70008926:	687b      	ldr	r3, [r7, #4]
70008928:	f103 0008 	add.w	r0, r3, #8
7000892c:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D5.LengthCommand - 1u)))
7000892e:	4b28      	ldr	r3, [pc, #160]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008930:	7cdb      	ldrb	r3, [r3, #19]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
70008932:	3b01      	subs	r3, #1
70008934:	b29c      	uxth	r4, r3
70008936:	f107 0308 	add.w	r3, r7, #8
7000893a:	1c5a      	adds	r2, r3, #1
7000893c:	4623      	mov	r3, r4
7000893e:	f7fe fb46 	bl	70006fce <SAL_XSPI_CommandSendData>
70008942:	4603      	mov	r3, r0
70008944:	2b00      	cmp	r3, #0
70008946:	d002      	beq.n	7000894e <sfdp_enter_octal_mode+0x142>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
70008948:	230b      	movs	r3, #11
7000894a:	73fb      	strb	r3, [r7, #15]
      goto error;
7000894c:	e03b      	b.n	700089c6 <sfdp_enter_octal_mode+0x1ba>
    }
  }

  /* D7-D8 command */
  if (0u != JEDEC_OctalDdr.Param_DWORD.D7.LengthCommand)
7000894e:	4b20      	ldr	r3, [pc, #128]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008950:	7edb      	ldrb	r3, [r3, #27]
70008952:	2b00      	cmp	r3, #0
70008954:	d032      	beq.n	700089bc <sfdp_enter_octal_mode+0x1b0>
  {
    /* wait for busy flag clear */
    if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
70008956:	2164      	movs	r1, #100	@ 0x64
70008958:	6878      	ldr	r0, [r7, #4]
7000895a:	f7ff fdf7 	bl	7000854c <driver_check_FlagBUSY>
7000895e:	4603      	mov	r3, r0
70008960:	2b00      	cmp	r3, #0
70008962:	d002      	beq.n	7000896a <sfdp_enter_octal_mode+0x15e>
    {
      retr = EXTMEM_SFDP_ERROR_DRIVER;
70008964:	230c      	movs	r3, #12
70008966:	73fb      	strb	r3, [r7, #15]
      goto error;
70008968:	e02d      	b.n	700089c6 <sfdp_enter_octal_mode+0x1ba>
    }

    data[0] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte1CommandSequence;
7000896a:	4b19      	ldr	r3, [pc, #100]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000896c:	7e9b      	ldrb	r3, [r3, #26]
7000896e:	723b      	strb	r3, [r7, #8]
    data[1] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte2CommandSequence;
70008970:	4b17      	ldr	r3, [pc, #92]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008972:	7e5b      	ldrb	r3, [r3, #25]
70008974:	727b      	strb	r3, [r7, #9]
    data[2] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D7.Byte3CommandSequence;
70008976:	4b16      	ldr	r3, [pc, #88]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008978:	7e1b      	ldrb	r3, [r3, #24]
7000897a:	72bb      	strb	r3, [r7, #10]
    data[3] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte4CommandSequence;
7000897c:	4b14      	ldr	r3, [pc, #80]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000897e:	7fdb      	ldrb	r3, [r3, #31]
70008980:	72fb      	strb	r3, [r7, #11]
    data[4] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte5CommandSequence;
70008982:	4b13      	ldr	r3, [pc, #76]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008984:	7f9b      	ldrb	r3, [r3, #30]
70008986:	733b      	strb	r3, [r7, #12]
    data[5] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte6CommandSequence;
70008988:	4b11      	ldr	r3, [pc, #68]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000898a:	7f5b      	ldrb	r3, [r3, #29]
7000898c:	737b      	strb	r3, [r7, #13]
    data[6] = (uint8_t)JEDEC_OctalDdr.Param_DWORD.D8.Byte7CommandSequence;
7000898e:	4b10      	ldr	r3, [pc, #64]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
70008990:	7f1b      	ldrb	r3, [r3, #28]
70008992:	73bb      	strb	r3, [r7, #14]

    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
70008994:	687b      	ldr	r3, [r7, #4]
70008996:	f103 0008 	add.w	r0, r3, #8
7000899a:	7a39      	ldrb	r1, [r7, #8]
                                           (uint16_t)(JEDEC_OctalDdr.Param_DWORD.D7.LengthCommand - 1u)))
7000899c:	4b0c      	ldr	r3, [pc, #48]	@ (700089d0 <sfdp_enter_octal_mode+0x1c4>)
7000899e:	7edb      	ldrb	r3, [r3, #27]
    if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, data[0], &data[1],
700089a0:	3b01      	subs	r3, #1
700089a2:	b29c      	uxth	r4, r3
700089a4:	f107 0308 	add.w	r3, r7, #8
700089a8:	1c5a      	adds	r2, r3, #1
700089aa:	4623      	mov	r3, r4
700089ac:	f7fe fb0f 	bl	70006fce <SAL_XSPI_CommandSendData>
700089b0:	4603      	mov	r3, r0
700089b2:	2b00      	cmp	r3, #0
700089b4:	d002      	beq.n	700089bc <sfdp_enter_octal_mode+0x1b0>
    {
      retr = EXTMEM_SFDP_ERROR_OCTALMODE;
700089b6:	230b      	movs	r3, #11
700089b8:	73fb      	strb	r3, [r7, #15]
      goto error;
700089ba:	e004      	b.n	700089c6 <sfdp_enter_octal_mode+0x1ba>

    /* no more wait for busy flag clear here, as command format might have changed to Octal */
  }

  /* Abort any ongoing transfer to avoid performance issue */
  SAL_XSPI_Abort(&Object->sfdp_private.SALObject);
700089bc:	687b      	ldr	r3, [r7, #4]
700089be:	3308      	adds	r3, #8
700089c0:	4618      	mov	r0, r3
700089c2:	f7fe fcd3 	bl	7000736c <SAL_XSPI_Abort>

error:
  return retr;
700089c6:	7bfb      	ldrb	r3, [r7, #15]
}
700089c8:	4618      	mov	r0, r3
700089ca:	3714      	adds	r7, #20
700089cc:	46bd      	mov	sp, r7
700089ce:	bd90      	pop	{r4, r7, pc}
700089d0:	2400046c 	.word	0x2400046c

700089d4 <sfdp_set_dummycycle>:
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @param DummyValue Dummy cycle value to set.
  * @return SFDP_StatusTypeDef: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef sfdp_set_dummycycle(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t DummyValue)
{
700089d4:	b5f0      	push	{r4, r5, r6, r7, lr}
700089d6:	b08b      	sub	sp, #44	@ 0x2c
700089d8:	af04      	add	r7, sp, #16
700089da:	6078      	str	r0, [r7, #4]
700089dc:	6039      	str	r1, [r7, #0]
  const uint8_t MaskWaitStateValue[4] = { 0x3u, 0x7u, 0xFu, 0x1Fu };
700089de:	4b6d      	ldr	r3, [pc, #436]	@ (70008b94 <sfdp_set_dummycycle+0x1c0>)
700089e0:	60fb      	str	r3, [r7, #12]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_OK;
700089e2:	2300      	movs	r3, #0
700089e4:	75fb      	strb	r3, [r7, #23]
  uint8_t localValue[2] = { 0 };
700089e6:	2300      	movs	r3, #0
700089e8:	813b      	strh	r3, [r7, #8]
  uint32_t Address;

  if ((JEDEC_SCCR_Map.Param_DWORD.D9.BitAccessedByCommandsUsingAddress == 0u) &&
700089ea:	4b6b      	ldr	r3, [pc, #428]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
700089ec:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
700089f0:	f003 0310 	and.w	r3, r3, #16
700089f4:	b2db      	uxtb	r3, r3
700089f6:	2b00      	cmp	r3, #0
700089f8:	d10a      	bne.n	70008a10 <sfdp_set_dummycycle+0x3c>
      (JEDEC_SCCR_Map.Param_DWORD.D9.BitAvailable == 1u))
700089fa:	4b67      	ldr	r3, [pc, #412]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
700089fc:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
70008a00:	f023 037f 	bic.w	r3, r3, #127	@ 0x7f
70008a04:	b2db      	uxtb	r3, r3
  if ((JEDEC_SCCR_Map.Param_DWORD.D9.BitAccessedByCommandsUsingAddress == 0u) &&
70008a06:	2b00      	cmp	r3, #0
70008a08:	d002      	beq.n	70008a10 <sfdp_set_dummycycle+0x3c>
  {
    /* Not yet supported */
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70008a0a:	230c      	movs	r3, #12
70008a0c:	75fb      	strb	r3, [r7, #23]
    goto error;
70008a0e:	e0bb      	b.n	70008b88 <sfdp_set_dummycycle+0x1b4>
  }

  /* Compute the Address */
  if (JEDEC_SCCR_Map.Param_DWORD.D9.LocalAddress == 1u)
70008a10:	4b61      	ldr	r3, [pc, #388]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008a12:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
70008a16:	f003 0308 	and.w	r3, r3, #8
70008a1a:	b2db      	uxtb	r3, r3
70008a1c:	2b00      	cmp	r3, #0
70008a1e:	d005      	beq.n	70008a2c <sfdp_set_dummycycle+0x58>
  {
    /* Local Address is found in Byte 1 of 32-bit address */
    Address = JEDEC_SCCR_Map.Param_DWORD.D9.AddressRegisterOrModesSupported << 8;
70008a20:	4b5d      	ldr	r3, [pc, #372]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008a22:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
70008a26:	021b      	lsls	r3, r3, #8
70008a28:	613b      	str	r3, [r7, #16]
70008a2a:	e00b      	b.n	70008a44 <sfdp_set_dummycycle+0x70>
  }
  else
  {
    /* Specific case of GigaDevice GD25LX512ME where register address is wrongly coded in SFDP table */
    if (Object->sfdp_private.ManuID == 0xC8)
70008a2c:	687b      	ldr	r3, [r7, #4]
70008a2e:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
70008a32:	2bc8      	cmp	r3, #200	@ 0xc8
70008a34:	d102      	bne.n	70008a3c <sfdp_set_dummycycle+0x68>
    {
      /* Address value in datasheet : 1, address value coded in SFDP table 200 */
      Address = 1U;
70008a36:	2301      	movs	r3, #1
70008a38:	613b      	str	r3, [r7, #16]
70008a3a:	e003      	b.n	70008a44 <sfdp_set_dummycycle+0x70>
    }
    else
    {
      /* Local address for Variable Dummy Cycle Settings bits is found in last byte of the address */
      Address = JEDEC_SCCR_Map.Param_DWORD.D9.AddressRegisterOrModesSupported;
70008a3c:	4b56      	ldr	r3, [pc, #344]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008a3e:	f893 3022 	ldrb.w	r3, [r3, #34]	@ 0x22
70008a42:	613b      	str	r3, [r7, #16]
    }
  }

  /* Read the configuration */
  if (HAL_OK != SAL_XSPI_CommandSendReadAddress(&Object->sfdp_private.SALObject,
70008a44:	687b      	ldr	r3, [r7, #4]
70008a46:	f103 0008 	add.w	r0, r3, #8
70008a4a:	4b53      	ldr	r3, [pc, #332]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008a4c:	f893 1021 	ldrb.w	r1, [r3, #33]	@ 0x21
70008a50:	687b      	ldr	r3, [r7, #4]
70008a52:	f893 305d 	ldrb.w	r3, [r3, #93]	@ 0x5d
70008a56:	f107 0208 	add.w	r2, r7, #8
70008a5a:	9301      	str	r3, [sp, #4]
70008a5c:	2302      	movs	r3, #2
70008a5e:	9300      	str	r3, [sp, #0]
70008a60:	4613      	mov	r3, r2
70008a62:	693a      	ldr	r2, [r7, #16]
70008a64:	f7fe fb5b 	bl	7000711e <SAL_XSPI_CommandSendReadAddress>
70008a68:	4603      	mov	r3, r0
70008a6a:	2b00      	cmp	r3, #0
70008a6c:	d002      	beq.n	70008a74 <sfdp_set_dummycycle+0xa0>
                                                Address,
                                                (uint8_t *)localValue,
                                                2u,
                                                Object->sfdp_private.ManuID))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70008a6e:	230c      	movs	r3, #12
70008a70:	75fb      	strb	r3, [r7, #23]
    goto error;
70008a72:	e089      	b.n	70008b88 <sfdp_set_dummycycle+0x1b4>
  }

  /* send command to write enable */
  if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject,
70008a74:	687b      	ldr	r3, [r7, #4]
70008a76:	f103 0008 	add.w	r0, r3, #8
70008a7a:	687b      	ldr	r3, [r7, #4]
70008a7c:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
70008a80:	2300      	movs	r3, #0
70008a82:	2200      	movs	r2, #0
70008a84:	f7fe faa3 	bl	70006fce <SAL_XSPI_CommandSendData>
70008a88:	4603      	mov	r3, r0
70008a8a:	2b00      	cmp	r3, #0
70008a8c:	d002      	beq.n	70008a94 <sfdp_set_dummycycle+0xc0>
                                         Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70008a8e:	230c      	movs	r3, #12
70008a90:	75fb      	strb	r3, [r7, #23]
    goto error;
70008a92:	e079      	b.n	70008b88 <sfdp_set_dummycycle+0x1b4>
  }

  /* control the write enable */
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
70008a94:	687b      	ldr	r3, [r7, #4]
70008a96:	f103 0008 	add.w	r0, r3, #8
70008a9a:	687b      	ldr	r3, [r7, #4]
70008a9c:	f893 1071 	ldrb.w	r1, [r3, #113]	@ 0x71
                                             Object->sfdp_private.DriverInfo.ReadWELCommand,
                                             Object->sfdp_private.DriverInfo.WELAddress,
70008aa0:	687b      	ldr	r3, [r7, #4]
70008aa2:	f893 3074 	ldrb.w	r3, [r3, #116]	@ 0x74
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
70008aa6:	461e      	mov	r6, r3
                                             ((Object->sfdp_private.DriverInfo.WELBusyPolarity == 0u) ? 1u : 0u)
70008aa8:	687b      	ldr	r3, [r7, #4]
70008aaa:	f893 3073 	ldrb.w	r3, [r3, #115]	@ 0x73
70008aae:	2b00      	cmp	r3, #0
70008ab0:	d101      	bne.n	70008ab6 <sfdp_set_dummycycle+0xe2>
70008ab2:	2301      	movs	r3, #1
70008ab4:	e000      	b.n	70008ab8 <sfdp_set_dummycycle+0xe4>
70008ab6:	2300      	movs	r3, #0
                                             << Object->sfdp_private.DriverInfo.WELPosition,
70008ab8:	687a      	ldr	r2, [r7, #4]
70008aba:	f892 2072 	ldrb.w	r2, [r2, #114]	@ 0x72
70008abe:	4093      	lsls	r3, r2
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
70008ac0:	b2dc      	uxtb	r4, r3
                                             1u << Object->sfdp_private.DriverInfo.WELPosition,
70008ac2:	687b      	ldr	r3, [r7, #4]
70008ac4:	f893 3072 	ldrb.w	r3, [r3, #114]	@ 0x72
70008ac8:	461a      	mov	r2, r3
70008aca:	2301      	movs	r3, #1
70008acc:	4093      	lsls	r3, r2
  if (HAL_OK != SAL_XSPI_CheckStatusRegister(&Object->sfdp_private.SALObject,
70008ace:	b2db      	uxtb	r3, r3
70008ad0:	687a      	ldr	r2, [r7, #4]
70008ad2:	f892 205d 	ldrb.w	r2, [r2, #93]	@ 0x5d
70008ad6:	f44f 757a 	mov.w	r5, #1000	@ 0x3e8
70008ada:	9502      	str	r5, [sp, #8]
70008adc:	9201      	str	r2, [sp, #4]
70008ade:	9300      	str	r3, [sp, #0]
70008ae0:	4623      	mov	r3, r4
70008ae2:	4632      	mov	r2, r6
70008ae4:	f7fe fb80 	bl	700071e8 <SAL_XSPI_CheckStatusRegister>
70008ae8:	4603      	mov	r3, r0
70008aea:	2b00      	cmp	r3, #0
70008aec:	d002      	beq.n	70008af4 <sfdp_set_dummycycle+0x120>
                                             Object->sfdp_private.ManuID, 1000))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70008aee:	230c      	movs	r3, #12
70008af0:	75fb      	strb	r3, [r7, #23]
    goto error;
70008af2:	e049      	b.n	70008b88 <sfdp_set_dummycycle+0x1b4>
  }

  /* clear the value */
  localValue[0] = localValue[0] & ~(MaskWaitStateValue[JEDEC_SCCR_Map.Param_DWORD.D9.NumberBitsUsedToSetWaitStates]
70008af4:	7a3b      	ldrb	r3, [r7, #8]
70008af6:	b25a      	sxtb	r2, r3
70008af8:	4b27      	ldr	r3, [pc, #156]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008afa:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
70008afe:	f3c3 1341 	ubfx	r3, r3, #5, #2
70008b02:	b2db      	uxtb	r3, r3
70008b04:	3318      	adds	r3, #24
70008b06:	443b      	add	r3, r7
70008b08:	f813 3c0c 	ldrb.w	r3, [r3, #-12]
70008b0c:	4619      	mov	r1, r3
                                    << JEDEC_SCCR_Map.Param_DWORD.D9.BitLocationLSBPhysicalBitsRegister);
70008b0e:	4b22      	ldr	r3, [pc, #136]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008b10:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
70008b14:	f3c3 0302 	ubfx	r3, r3, #0, #3
70008b18:	b2db      	uxtb	r3, r3
70008b1a:	fa01 f303 	lsl.w	r3, r1, r3
  localValue[0] = localValue[0] & ~(MaskWaitStateValue[JEDEC_SCCR_Map.Param_DWORD.D9.NumberBitsUsedToSetWaitStates]
70008b1e:	b25b      	sxtb	r3, r3
70008b20:	43db      	mvns	r3, r3
70008b22:	b25b      	sxtb	r3, r3
70008b24:	4013      	ands	r3, r2
70008b26:	b25b      	sxtb	r3, r3
70008b28:	b2db      	uxtb	r3, r3
70008b2a:	723b      	strb	r3, [r7, #8]

  /* Apply the value with the mask */
  localValue[0] = localValue[0]
70008b2c:	7a3a      	ldrb	r2, [r7, #8]
                  | (uint8_t)(DummyValue << JEDEC_SCCR_Map.Param_DWORD.D9.BitLocationLSBPhysicalBitsRegister);
70008b2e:	4b1a      	ldr	r3, [pc, #104]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008b30:	f893 3023 	ldrb.w	r3, [r3, #35]	@ 0x23
70008b34:	f3c3 0302 	ubfx	r3, r3, #0, #3
70008b38:	b2db      	uxtb	r3, r3
70008b3a:	4619      	mov	r1, r3
70008b3c:	683b      	ldr	r3, [r7, #0]
70008b3e:	408b      	lsls	r3, r1
70008b40:	b2db      	uxtb	r3, r3
  localValue[0] = localValue[0]
70008b42:	4313      	orrs	r3, r2
70008b44:	b2db      	uxtb	r3, r3
70008b46:	723b      	strb	r3, [r7, #8]
  localValue[1] = localValue[0];
70008b48:	7a3b      	ldrb	r3, [r7, #8]
70008b4a:	727b      	strb	r3, [r7, #9]

  /* Write de configuration */
  if (HAL_OK != SAL_XSPI_Write(&Object->sfdp_private.SALObject,
70008b4c:	687b      	ldr	r3, [r7, #4]
70008b4e:	f103 0008 	add.w	r0, r3, #8
70008b52:	4b11      	ldr	r3, [pc, #68]	@ (70008b98 <sfdp_set_dummycycle+0x1c4>)
70008b54:	f893 1020 	ldrb.w	r1, [r3, #32]
70008b58:	f107 0308 	add.w	r3, r7, #8
70008b5c:	2202      	movs	r2, #2
70008b5e:	9200      	str	r2, [sp, #0]
70008b60:	693a      	ldr	r2, [r7, #16]
70008b62:	f7fe f9eb 	bl	70006f3c <SAL_XSPI_Write>
70008b66:	4603      	mov	r3, r0
70008b68:	2b00      	cmp	r3, #0
70008b6a:	d002      	beq.n	70008b72 <sfdp_set_dummycycle+0x19e>
                               (uint8_t)JEDEC_SCCR_Map.Param_DWORD.D9.CommandWriteAccess,
                               Address, (uint8_t *)localValue, 2u))
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70008b6c:	230c      	movs	r3, #12
70008b6e:	75fb      	strb	r3, [r7, #23]
    goto error;
70008b70:	e00a      	b.n	70008b88 <sfdp_set_dummycycle+0x1b4>
  }

  /* wait for busy flag clear */
  if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100u))
70008b72:	2164      	movs	r1, #100	@ 0x64
70008b74:	6878      	ldr	r0, [r7, #4]
70008b76:	f7ff fce9 	bl	7000854c <driver_check_FlagBUSY>
70008b7a:	4603      	mov	r3, r0
70008b7c:	2b00      	cmp	r3, #0
70008b7e:	d002      	beq.n	70008b86 <sfdp_set_dummycycle+0x1b2>
  {
    retr = EXTMEM_SFDP_ERROR_DRIVER;
70008b80:	230c      	movs	r3, #12
70008b82:	75fb      	strb	r3, [r7, #23]
    goto error;
70008b84:	e000      	b.n	70008b88 <sfdp_set_dummycycle+0x1b4>
  }

error :
70008b86:	bf00      	nop
  return retr;
70008b88:	7dfb      	ldrb	r3, [r7, #23]
}
70008b8a:	4618      	mov	r0, r3
70008b8c:	371c      	adds	r7, #28
70008b8e:	46bd      	mov	sp, r7
70008b90:	bdf0      	pop	{r4, r5, r6, r7, pc}
70008b92:	bf00      	nop
70008b94:	1f0f0703 	.word	0x1f0f0703
70008b98:	240003fc 	.word	0x240003fc

70008b9c <JEDEC_Basic_ManageQuadEnableRequirement>:
  * @brief Manages the Quad Enable Requirement (QER) for the NOR memory device.
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @return SFDP_StatusTypeDef: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef JEDEC_Basic_ManageQuadEnableRequirement(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
70008b9c:	b580      	push	{r7, lr}
70008b9e:	b084      	sub	sp, #16
70008ba0:	af00      	add	r7, sp, #0
70008ba2:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
70008ba4:	230f      	movs	r3, #15
70008ba6:	73fb      	strb	r3, [r7, #15]
  uint8_t localValue[2];

  /* switch the mode in QSPI if available */
  switch (JEDEC_Basic.Params.Param_DWORD.D15.QuadEnableRequirement & 0x7u)
70008ba8:	4b59      	ldr	r3, [pc, #356]	@ (70008d10 <JEDEC_Basic_ManageQuadEnableRequirement+0x174>)
70008baa:	f893 303e 	ldrb.w	r3, [r3, #62]	@ 0x3e
70008bae:	f3c3 1302 	ubfx	r3, r3, #4, #3
70008bb2:	b2db      	uxtb	r3, r3
70008bb4:	2b07      	cmp	r3, #7
70008bb6:	f200 80a4 	bhi.w	70008d02 <JEDEC_Basic_ManageQuadEnableRequirement+0x166>
70008bba:	a201      	add	r2, pc, #4	@ (adr r2, 70008bc0 <JEDEC_Basic_ManageQuadEnableRequirement+0x24>)
70008bbc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
70008bc0:	70008d03 	.word	0x70008d03
70008bc4:	70008d03 	.word	0x70008d03
70008bc8:	70008be1 	.word	0x70008be1
70008bcc:	70008d03 	.word	0x70008d03
70008bd0:	70008c61 	.word	0x70008c61
70008bd4:	70008d03 	.word	0x70008d03
70008bd8:	70008d03 	.word	0x70008d03
70008bdc:	70008d03 	.word	0x70008d03
    case 0x2u:
    {
      /* 010b: QE is bit 6 of status register 1. It is set via Write Status with one data byte where bit 6 is one.
                     It is cleared via Write Status with one data byte where bit 6 is zero. */
      /* 1 - set the write enable */
      if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject,
70008be0:	687b      	ldr	r3, [r7, #4]
70008be2:	f103 0008 	add.w	r0, r3, #8
70008be6:	687b      	ldr	r3, [r7, #4]
70008be8:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
70008bec:	2300      	movs	r3, #0
70008bee:	2200      	movs	r2, #0
70008bf0:	f7fe fa41 	bl	70007076 <SAL_XSPI_SendReadCommand>
70008bf4:	4603      	mov	r3, r0
70008bf6:	2b00      	cmp	r3, #0
70008bf8:	d002      	beq.n	70008c00 <JEDEC_Basic_ManageQuadEnableRequirement+0x64>
                                             Object->sfdp_private.DriverInfo.WriteWELCommand, NULL, 0u))
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008bfa:	230c      	movs	r3, #12
70008bfc:	73fb      	strb	r3, [r7, #15]
        goto error;
70008bfe:	e081      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      /* 2 - read the status register */
      if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, SFDP_DRIVER_READ_STATUS_REGISTER_COMMAND,
70008c00:	687b      	ldr	r3, [r7, #4]
70008c02:	f103 0008 	add.w	r0, r3, #8
70008c06:	f107 020c 	add.w	r2, r7, #12
70008c0a:	2301      	movs	r3, #1
70008c0c:	2105      	movs	r1, #5
70008c0e:	f7fe fa32 	bl	70007076 <SAL_XSPI_SendReadCommand>
70008c12:	4603      	mov	r3, r0
70008c14:	2b00      	cmp	r3, #0
70008c16:	d002      	beq.n	70008c1e <JEDEC_Basic_ManageQuadEnableRequirement+0x82>
                                             (uint8_t *)&localValue[0], 1u))
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008c18:	230c      	movs	r3, #12
70008c1a:	73fb      	strb	r3, [r7, #15]
        goto error;
70008c1c:	e072      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      /* 3 - update the status register to enable QPI mode*/
      localValue[0] = localValue[0] | 0x40u;
70008c1e:	7b3b      	ldrb	r3, [r7, #12]
70008c20:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70008c24:	b2db      	uxtb	r3, r3
70008c26:	733b      	strb	r3, [r7, #12]

      /* 4 - write the status register with QPI mode to 1 */
      if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x1u, (uint8_t *)&localValue[0], 1u))
70008c28:	687b      	ldr	r3, [r7, #4]
70008c2a:	f103 0008 	add.w	r0, r3, #8
70008c2e:	f107 020c 	add.w	r2, r7, #12
70008c32:	2301      	movs	r3, #1
70008c34:	2101      	movs	r1, #1
70008c36:	f7fe f9ca 	bl	70006fce <SAL_XSPI_CommandSendData>
70008c3a:	4603      	mov	r3, r0
70008c3c:	2b00      	cmp	r3, #0
70008c3e:	d002      	beq.n	70008c46 <JEDEC_Basic_ManageQuadEnableRequirement+0xaa>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008c40:	230c      	movs	r3, #12
70008c42:	73fb      	strb	r3, [r7, #15]
        goto error;
70008c44:	e05e      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      /* wait busy flag  */
      if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100))
70008c46:	2164      	movs	r1, #100	@ 0x64
70008c48:	6878      	ldr	r0, [r7, #4]
70008c4a:	f7ff fc7f 	bl	7000854c <driver_check_FlagBUSY>
70008c4e:	4603      	mov	r3, r0
70008c50:	2b00      	cmp	r3, #0
70008c52:	d002      	beq.n	70008c5a <JEDEC_Basic_ManageQuadEnableRequirement+0xbe>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008c54:	230c      	movs	r3, #12
70008c56:	73fb      	strb	r3, [r7, #15]
        goto error;
70008c58:	e054      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      retr = EXTMEM_SFDP_OK;
70008c5a:	2300      	movs	r3, #0
70008c5c:	73fb      	strb	r3, [r7, #15]
      break;
70008c5e:	e051      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
               where bit 1 of the second byte is one.
               It is cleared via Write Status with two data bytes where bit 1 of the second byte is zero.
               In contrast to the 001b code, writing 1 byte to the status register does not modify status register 2.*/

      /* Read the status register */
      if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, 0x5, (uint8_t *)&localValue[0], 2u))
70008c60:	687b      	ldr	r3, [r7, #4]
70008c62:	f103 0008 	add.w	r0, r3, #8
70008c66:	f107 020c 	add.w	r2, r7, #12
70008c6a:	2302      	movs	r3, #2
70008c6c:	2105      	movs	r1, #5
70008c6e:	f7fe fa02 	bl	70007076 <SAL_XSPI_SendReadCommand>
70008c72:	4603      	mov	r3, r0
70008c74:	2b00      	cmp	r3, #0
70008c76:	d002      	beq.n	70008c7e <JEDEC_Basic_ManageQuadEnableRequirement+0xe2>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008c78:	230c      	movs	r3, #12
70008c7a:	73fb      	strb	r3, [r7, #15]
        goto error;
70008c7c:	e042      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      /* Update the status register */
      localValue[1] |= 2u;
70008c7e:	7b7b      	ldrb	r3, [r7, #13]
70008c80:	f043 0302 	orr.w	r3, r3, #2
70008c84:	b2db      	uxtb	r3, r3
70008c86:	737b      	strb	r3, [r7, #13]

      /* WEL */
      if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject,
70008c88:	687b      	ldr	r3, [r7, #4]
70008c8a:	f103 0008 	add.w	r0, r3, #8
70008c8e:	687b      	ldr	r3, [r7, #4]
70008c90:	f893 1070 	ldrb.w	r1, [r3, #112]	@ 0x70
70008c94:	2300      	movs	r3, #0
70008c96:	2200      	movs	r2, #0
70008c98:	f7fe f9ed 	bl	70007076 <SAL_XSPI_SendReadCommand>
70008c9c:	4603      	mov	r3, r0
70008c9e:	2b00      	cmp	r3, #0
70008ca0:	d002      	beq.n	70008ca8 <JEDEC_Basic_ManageQuadEnableRequirement+0x10c>
                                             Object->sfdp_private.DriverInfo.WriteWELCommand,
                                             NULL, 0u))
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008ca2:	230c      	movs	r3, #12
70008ca4:	73fb      	strb	r3, [r7, #15]
        goto error;
70008ca6:	e02d      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      /* Write the status register */
      if (HAL_OK != SAL_XSPI_CommandSendData(&Object->sfdp_private.SALObject, 0x1u, (uint8_t *)&localValue[0], 2u))
70008ca8:	687b      	ldr	r3, [r7, #4]
70008caa:	f103 0008 	add.w	r0, r3, #8
70008cae:	f107 020c 	add.w	r2, r7, #12
70008cb2:	2302      	movs	r3, #2
70008cb4:	2101      	movs	r1, #1
70008cb6:	f7fe f98a 	bl	70006fce <SAL_XSPI_CommandSendData>
70008cba:	4603      	mov	r3, r0
70008cbc:	2b00      	cmp	r3, #0
70008cbe:	d002      	beq.n	70008cc6 <JEDEC_Basic_ManageQuadEnableRequirement+0x12a>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008cc0:	230c      	movs	r3, #12
70008cc2:	73fb      	strb	r3, [r7, #15]
        goto error;
70008cc4:	e01e      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      /* Wait busy flag  */
      if (EXTMEM_DRIVER_NOR_SFDP_OK != driver_check_FlagBUSY(Object, 100))
70008cc6:	2164      	movs	r1, #100	@ 0x64
70008cc8:	6878      	ldr	r0, [r7, #4]
70008cca:	f7ff fc3f 	bl	7000854c <driver_check_FlagBUSY>
70008cce:	4603      	mov	r3, r0
70008cd0:	2b00      	cmp	r3, #0
70008cd2:	d002      	beq.n	70008cda <JEDEC_Basic_ManageQuadEnableRequirement+0x13e>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008cd4:	230c      	movs	r3, #12
70008cd6:	73fb      	strb	r3, [r7, #15]
        goto error;
70008cd8:	e014      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      /* Optional : only for control read the status register and check write operation is OK */
      localValue[1] = 0xFF;
70008cda:	23ff      	movs	r3, #255	@ 0xff
70008cdc:	737b      	strb	r3, [r7, #13]
      if (HAL_OK != SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, 0x5, (uint8_t *)&localValue[0], 2u))
70008cde:	687b      	ldr	r3, [r7, #4]
70008ce0:	f103 0008 	add.w	r0, r3, #8
70008ce4:	f107 020c 	add.w	r2, r7, #12
70008ce8:	2302      	movs	r3, #2
70008cea:	2105      	movs	r1, #5
70008cec:	f7fe f9c3 	bl	70007076 <SAL_XSPI_SendReadCommand>
70008cf0:	4603      	mov	r3, r0
70008cf2:	2b00      	cmp	r3, #0
70008cf4:	d002      	beq.n	70008cfc <JEDEC_Basic_ManageQuadEnableRequirement+0x160>
      {
        retr = EXTMEM_SFDP_ERROR_DRIVER;
70008cf6:	230c      	movs	r3, #12
70008cf8:	73fb      	strb	r3, [r7, #15]
        goto error;
70008cfa:	e003      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
      }

      retr = EXTMEM_SFDP_OK;
70008cfc:	2300      	movs	r3, #0
70008cfe:	73fb      	strb	r3, [r7, #15]
      break;
70008d00:	e000      	b.n	70008d04 <JEDEC_Basic_ManageQuadEnableRequirement+0x168>
                  It is cleared via Write Status Register instruction 31h with one data byte where bit 1 is zero.*/
      break;
    case 0x7u: /*111b: Reserved */
      break;
    default :/* Added for Misra */
      break;
70008d02:	bf00      	nop
  }
error :
  return retr;
70008d04:	7bfb      	ldrb	r3, [r7, #15]
}
70008d06:	4618      	mov	r0, r3
70008d08:	3710      	adds	r7, #16
70008d0a:	46bd      	mov	sp, r7
70008d0c:	bd80      	pop	{r7, pc}
70008d0e:	bf00      	nop
70008d10:	2400037c 	.word	0x2400037c

70008d14 <JEDEC_Basic_Manage4S4S4SEnableSequence>:
  * @brief Manages the 4S-4S-4S enable sequence for the NOR memory device.
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @return SFDP_StatusTypeDef: EXTMEM_SFDP_OK if successful, error code otherwise.
  */
SFDP_StatusTypeDef JEDEC_Basic_Manage4S4S4SEnableSequence(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object)
{
70008d14:	b580      	push	{r7, lr}
70008d16:	b084      	sub	sp, #16
70008d18:	af00      	add	r7, sp, #0
70008d1a:	6078      	str	r0, [r7, #4]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_NOTYETHANDLED;
70008d1c:	230f      	movs	r3, #15
70008d1e:	73fb      	strb	r3, [r7, #15]
  uint8_t instruction = 0x00u;
70008d20:	2300      	movs	r3, #0
70008d22:	73bb      	strb	r3, [r7, #14]

  /* 4-4-4 mode enable sequences; This field describes the supported methods to enter 4-4-4 mode from 1-1-1 mode */
  /* x_xxx1b: set QE per QER description above, then issue instruction 38h */
  if ((JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence & 0x1u) == 0x1u)
70008d24:	4b1a      	ldr	r3, [pc, #104]	@ (70008d90 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x7c>)
70008d26:	8f9b      	ldrh	r3, [r3, #60]	@ 0x3c
70008d28:	f3c3 1304 	ubfx	r3, r3, #4, #5
70008d2c:	b2db      	uxtb	r3, r3
70008d2e:	f003 0301 	and.w	r3, r3, #1
70008d32:	2b00      	cmp	r3, #0
70008d34:	d007      	beq.n	70008d46 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x32>
  {
    retr = JEDEC_Basic_ManageQuadEnableRequirement(Object);
70008d36:	6878      	ldr	r0, [r7, #4]
70008d38:	f7ff ff30 	bl	70008b9c <JEDEC_Basic_ManageQuadEnableRequirement>
70008d3c:	4603      	mov	r3, r0
70008d3e:	73fb      	strb	r3, [r7, #15]
    instruction = 0x38u;
70008d40:	2338      	movs	r3, #56	@ 0x38
70008d42:	73bb      	strb	r3, [r7, #14]
70008d44:	e00f      	b.n	70008d66 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x52>
  }
  /* x_x1xxb: issue instruction 35h */
  else if ((JEDEC_Basic.Params.Param_DWORD.D15._4S4S4S_EnableSequence & 0x4u) == 0x4u)
70008d46:	4b12      	ldr	r3, [pc, #72]	@ (70008d90 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x7c>)
70008d48:	8f9b      	ldrh	r3, [r3, #60]	@ 0x3c
70008d4a:	f3c3 1304 	ubfx	r3, r3, #4, #5
70008d4e:	b2db      	uxtb	r3, r3
70008d50:	f003 0304 	and.w	r3, r3, #4
70008d54:	2b00      	cmp	r3, #0
70008d56:	d006      	beq.n	70008d66 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x52>
  {
    /* If QE bit exists, Quad Enable Requirement describes method to enable Quad operations */
    retr = JEDEC_Basic_ManageQuadEnableRequirement(Object);
70008d58:	6878      	ldr	r0, [r7, #4]
70008d5a:	f7ff ff1f 	bl	70008b9c <JEDEC_Basic_ManageQuadEnableRequirement>
70008d5e:	4603      	mov	r3, r0
70008d60:	73fb      	strb	r3, [r7, #15]
    instruction = 0x35u;
70008d62:	2335      	movs	r3, #53	@ 0x35
70008d64:	73bb      	strb	r3, [r7, #14]
       Read Volatile Enhanced Configuration Register using instruction 65h, no address is required, set bit 7 to 1.
       Write Volatile Enhanced Configuration Register using instruction 61h, no address is required.
       This configuration is volatile.
  NOTE If device is in 0-4-4 mode, then this mode must be exited before the 4-4-4 enable sequence is issued.
  */
  if ((retr == EXTMEM_SFDP_OK) && (instruction != 0u))
70008d66:	7bfb      	ldrb	r3, [r7, #15]
70008d68:	2b00      	cmp	r3, #0
70008d6a:	d10c      	bne.n	70008d86 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x72>
70008d6c:	7bbb      	ldrb	r3, [r7, #14]
70008d6e:	2b00      	cmp	r3, #0
70008d70:	d009      	beq.n	70008d86 <JEDEC_Basic_Manage4S4S4SEnableSequence+0x72>
  {
    (void)SAL_XSPI_SendReadCommand(&Object->sfdp_private.SALObject, instruction, NULL, 0u);
70008d72:	687b      	ldr	r3, [r7, #4]
70008d74:	f103 0008 	add.w	r0, r3, #8
70008d78:	7bb9      	ldrb	r1, [r7, #14]
70008d7a:	2300      	movs	r3, #0
70008d7c:	2200      	movs	r2, #0
70008d7e:	f7fe f97a 	bl	70007076 <SAL_XSPI_SendReadCommand>
    /* @note on memory W25Q64JV the command 38h does not exist so the control on command execution has been removed */
    retr = EXTMEM_SFDP_OK;
70008d82:	2300      	movs	r3, #0
70008d84:	73fb      	strb	r3, [r7, #15]
  }

  return retr;
70008d86:	7bfb      	ldrb	r3, [r7, #15]
}
70008d88:	4618      	mov	r0, r3
70008d8a:	3710      	adds	r7, #16
70008d8c:	46bd      	mov	sp, r7
70008d8e:	bd80      	pop	{r7, pc}
70008d90:	2400037c 	.word	0x2400037c

70008d94 <CheckSFDP_Signature>:
  * @param Object Pointer to the NOR SFDP memory instance object descriptor.
  * @param Signature Value of the SFDP signature to check.
  * @return SFDP_StatusTypeDef: EXTMEM_SFDP_OK if valid, error code otherwise.
  */
SFDP_StatusTypeDef CheckSFDP_Signature(EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *Object, uint32_t Signature)
{
70008d94:	b580      	push	{r7, lr}
70008d96:	b084      	sub	sp, #16
70008d98:	af00      	add	r7, sp, #0
70008d9a:	6078      	str	r0, [r7, #4]
70008d9c:	6039      	str	r1, [r7, #0]
  SFDP_StatusTypeDef retr = EXTMEM_SFDP_ERROR_SIGNATURE;
70008d9e:	2304      	movs	r3, #4
70008da0:	73fb      	strb	r3, [r7, #15]

  /* check the magic number */
  switch (Signature)
70008da2:	683b      	ldr	r3, [r7, #0]
70008da4:	4a0e      	ldr	r2, [pc, #56]	@ (70008de0 <CheckSFDP_Signature+0x4c>)
70008da6:	4293      	cmp	r3, r2
70008da8:	d006      	beq.n	70008db8 <CheckSFDP_Signature+0x24>
70008daa:	683b      	ldr	r3, [r7, #0]
70008dac:	4a0d      	ldr	r2, [pc, #52]	@ (70008de4 <CheckSFDP_Signature+0x50>)
70008dae:	4293      	cmp	r3, r2
70008db0:	d10e      	bne.n	70008dd0 <CheckSFDP_Signature+0x3c>
  {
    case SFDP_SIGNATURE :
      SFDP_DEBUG_STR("signature of the header: OK");
      retr = EXTMEM_SFDP_OK;
70008db2:	2300      	movs	r3, #0
70008db4:	73fb      	strb	r3, [r7, #15]
      break;
70008db6:	e00e      	b.n	70008dd6 <CheckSFDP_Signature+0x42>
    case SFDP_SIGNATURE_INVERTED :
      SFDP_DEBUG_STR("signature of the header: KO inverted data order");
      /* Change the memory type settings */
      if (HAL_OK == SAL_XSPI_UpdateMemoryType(&Object->sfdp_private.SALObject, SAL_XSPI_ORDERINVERTED))
70008db8:	687b      	ldr	r3, [r7, #4]
70008dba:	3308      	adds	r3, #8
70008dbc:	2100      	movs	r1, #0
70008dbe:	4618      	mov	r0, r3
70008dc0:	f7fe fa9c 	bl	700072fc <SAL_XSPI_UpdateMemoryType>
70008dc4:	4603      	mov	r3, r0
70008dc6:	2b00      	cmp	r3, #0
70008dc8:	d104      	bne.n	70008dd4 <CheckSFDP_Signature+0x40>
      {
        retr = EXTMEM_SFDP_ERROR_SIGNATUREMTYPE;
70008dca:	2305      	movs	r3, #5
70008dcc:	73fb      	strb	r3, [r7, #15]
      }
      break;
70008dce:	e001      	b.n	70008dd4 <CheckSFDP_Signature+0x40>
    default :
      SFDP_DEBUG_STR("signature of the header: KO");
      break;
70008dd0:	bf00      	nop
70008dd2:	e000      	b.n	70008dd6 <CheckSFDP_Signature+0x42>
      break;
70008dd4:	bf00      	nop
  }
  return retr;
70008dd6:	7bfb      	ldrb	r3, [r7, #15]
}
70008dd8:	4618      	mov	r0, r3
70008dda:	3710      	adds	r7, #16
70008ddc:	46bd      	mov	sp, r7
70008dde:	bd80      	pop	{r7, pc}
70008de0:	44505346 	.word	0x44505346
70008de4:	50444653 	.word	0x50444653

70008de8 <EXTMEM_DRIVER_NOR_SFDP_Init>:
  * @retval EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef Status of the operation.
  */
EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef EXTMEM_DRIVER_NOR_SFDP_Init(void *Peripheral, EXTMEM_LinkConfig_TypeDef Config,
                                                                 uint32_t ClockInput,
                                                                 EXTMEM_DRIVER_NOR_SFDP_ObjectTypeDef *SFDPObject)
{
70008de8:	b580      	push	{r7, lr}
70008dea:	b08a      	sub	sp, #40	@ 0x28
70008dec:	af00      	add	r7, sp, #0
70008dee:	60f8      	str	r0, [r7, #12]
70008df0:	607a      	str	r2, [r7, #4]
70008df2:	603b      	str	r3, [r7, #0]
70008df4:	460b      	mov	r3, r1
70008df6:	72fb      	strb	r3, [r7, #11]
  EXTMEM_DRIVER_NOR_SFDP_StatusTypeDef retr = EXTMEM_DRIVER_NOR_SFDP_OK;
70008df8:	2300      	movs	r3, #0
70008dfa:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
  SFDP_HeaderTypeDef JEDEC_SFDP_Header;
  uint8_t FreqUpdate = 0u;
70008dfe:	2300      	movs	r3, #0
70008e00:	76fb      	strb	r3, [r7, #27]
  uint8_t DataID[6];
  uint32_t ClockOut;

  /* Reset data of SFDPObject to zero */
  SFDP_DEBUG_STR("1 - reset data SFDPObject to zero")
  (void)memset((void *)&SFDPObject->sfdp_private, 0x0, sizeof(SFDPObject->sfdp_private));
70008e02:	683b      	ldr	r3, [r7, #0]
70008e04:	3308      	adds	r3, #8
70008e06:	2298      	movs	r2, #152	@ 0x98
70008e08:	2100      	movs	r1, #0
70008e0a:	4618      	mov	r0, r3
70008e0c:	f000 f9b7 	bl	7000917e <memset>

  /* Initialize the SFDPObject */
  SFDP_DEBUG_STR("2 - initialize the SFDPObject")
  SFDPObject->sfdp_private.Config = Config;
70008e10:	683b      	ldr	r3, [r7, #0]
70008e12:	7afa      	ldrb	r2, [r7, #11]
70008e14:	f883 205c 	strb.w	r2, [r3, #92]	@ 0x5c
  SFDPObject->sfdp_private.DriverInfo.SpiPhyLink = PHY_LINK_1S1S1S;
70008e18:	683b      	ldr	r3, [r7, #0]
70008e1a:	2200      	movs	r2, #0
70008e1c:	f883 2064 	strb.w	r2, [r3, #100]	@ 0x64
  SFDPObject->sfdp_private.DriverInfo.ClockIn = ClockInput;
70008e20:	683b      	ldr	r3, [r7, #0]
70008e22:	687a      	ldr	r2, [r7, #4]
70008e24:	669a      	str	r2, [r3, #104]	@ 0x68
  SAL_XSPI_SET_SFDPDUMMYCYLE(SFDPObject->sfdp_private.SALObject, EXTMEM_READ_SFDP_NB_DUMMY_CYCLES_DEFAULT);
70008e26:	683b      	ldr	r3, [r7, #0]
70008e28:	2208      	movs	r2, #8
70008e2a:	f883 2059 	strb.w	r2, [r3, #89]	@ 0x59

  /* Set memory speed to 50Mhz maximum */
  SFDP_DEBUG_STR("3 - set memory link and speed to 50Mhz maximum")
  (void)SAL_XSPI_Init(&SFDPObject->sfdp_private.SALObject, Peripheral);
70008e2e:	683b      	ldr	r3, [r7, #0]
70008e30:	3308      	adds	r3, #8
70008e32:	68f9      	ldr	r1, [r7, #12]
70008e34:	4618      	mov	r0, r3
70008e36:	f7fd fe1c 	bl	70006a72 <SAL_XSPI_Init>
  (void)SAL_XSPI_SetClock(&SFDPObject->sfdp_private.SALObject, ClockInput, DRIVER_SFDP_DEFAULT_CLOCK, &ClockOut);
70008e3a:	683b      	ldr	r3, [r7, #0]
70008e3c:	f103 0008 	add.w	r0, r3, #8
70008e40:	f107 0310 	add.w	r3, r7, #16
70008e44:	4a41      	ldr	r2, [pc, #260]	@ (70008f4c <EXTMEM_DRIVER_NOR_SFDP_Init+0x164>)
70008e46:	6879      	ldr	r1, [r7, #4]
70008e48:	f7fd fdd4 	bl	700069f4 <SAL_XSPI_SetClock>

  /* Abort any ongoing XSPI action */
  (void)SAL_XSPI_DisableMapMode(&SFDPObject->sfdp_private.SALObject);
70008e4c:	683b      	ldr	r3, [r7, #0]
70008e4e:	3308      	adds	r3, #8
70008e50:	4618      	mov	r0, r3
70008e52:	f7fe fa42 	bl	700072da <SAL_XSPI_DisableMapMode>

  /* Analyze the SFDP structure to get driver information */
  SFDP_DEBUG_STR("4 - analyze the SFDP structure to get driver information")
  if (EXTMEM_SFDP_OK != SFDP_GetHeader(SFDPObject, &JEDEC_SFDP_Header))
70008e56:	f107 031c 	add.w	r3, r7, #28
70008e5a:	4619      	mov	r1, r3
70008e5c:	6838      	ldr	r0, [r7, #0]
70008e5e:	f7fe fb0d 	bl	7000747c <SFDP_GetHeader>
70008e62:	4603      	mov	r3, r0
70008e64:	2b00      	cmp	r3, #0
70008e66:	d003      	beq.n	70008e70 <EXTMEM_DRIVER_NOR_SFDP_Init+0x88>
  {
    /* Perform SFDP Header reading (several modes are tried) */
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
70008e68:	23ff      	movs	r3, #255	@ 0xff
70008e6a:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
70008e6e:	e067      	b.n	70008f40 <EXTMEM_DRIVER_NOR_SFDP_Init+0x158>
  }

  /* Reset the memory */
  SFDP_DEBUG_STR("5 - reset the memory")
  if (EXTMEM_SFDP_OK != SFDP_MemoryReset(SFDPObject))
70008e70:	6838      	ldr	r0, [r7, #0]
70008e72:	f7fe fc3d 	bl	700076f0 <SFDP_MemoryReset>
       Try to continue Initialisation procedure anyway. */
    SFDP_DEBUG_STR("ERROR::on the call of SFDP_MemoryReset but no error returned")
  }

  /* Wait few ms after the reset operation, this is done to avoid issue on SFDP read */
  HAL_Delay(10);
70008e76:	200a      	movs	r0, #10
70008e78:	f7f8 fc70 	bl	7000175c <HAL_Delay>

  /* Analyze the SFDP structure to get driver information after the reset */
  SFDP_DEBUG_STR("6 - analyze the SFDP structure to get driver information")
  if (EXTMEM_SFDP_OK != SFDP_GetHeader(SFDPObject, &JEDEC_SFDP_Header))
70008e7c:	f107 031c 	add.w	r3, r7, #28
70008e80:	4619      	mov	r1, r3
70008e82:	6838      	ldr	r0, [r7, #0]
70008e84:	f7fe fafa 	bl	7000747c <SFDP_GetHeader>
70008e88:	4603      	mov	r3, r0
70008e8a:	2b00      	cmp	r3, #0
70008e8c:	d003      	beq.n	70008e96 <EXTMEM_DRIVER_NOR_SFDP_Init+0xae>
  {
    /* SFDP header reading is considered unsuccessful.
       Abort Initialisation procedure. */
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
70008e8e:	23ff      	movs	r3, #255	@ 0xff
70008e90:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
70008e94:	e054      	b.n	70008f40 <EXTMEM_DRIVER_NOR_SFDP_Init+0x158>
  }

  /* Save information from the SFDP table
     Nb of parameters starts at 0 (0 means 1 parameter) */
  if (JEDEC_SFDP_Header.param_number >= SFDP_MAX_NB_OF_PARAM)
70008e96:	f897 3022 	ldrb.w	r3, [r7, #34]	@ 0x22
70008e9a:	2b09      	cmp	r3, #9
70008e9c:	d904      	bls.n	70008ea8 <EXTMEM_DRIVER_NOR_SFDP_Init+0xc0>
  {
    SFDPObject->sfdp_private.Sfdp_param_number = SFDP_MAX_NB_OF_PARAM - 1;
70008e9e:	683b      	ldr	r3, [r7, #0]
70008ea0:	2209      	movs	r2, #9
70008ea2:	f883 209c 	strb.w	r2, [r3, #156]	@ 0x9c
70008ea6:	e004      	b.n	70008eb2 <EXTMEM_DRIVER_NOR_SFDP_Init+0xca>
  }
  else
  {
    SFDPObject->sfdp_private.Sfdp_param_number = JEDEC_SFDP_Header.param_number;
70008ea8:	f897 2022 	ldrb.w	r2, [r7, #34]	@ 0x22
70008eac:	683b      	ldr	r3, [r7, #0]
70008eae:	f883 209c 	strb.w	r2, [r3, #156]	@ 0x9c
  }
  SFDPObject->sfdp_private.Sfdp_AccessProtocol = JEDEC_SFDP_Header.AccessProtocol;
70008eb2:	f897 2023 	ldrb.w	r2, [r7, #35]	@ 0x23
70008eb6:	683b      	ldr	r3, [r7, #0]
70008eb8:	f883 209d 	strb.w	r2, [r3, #157]	@ 0x9d

  /* Read the flash ID.
     This Flash ID could later be used to perform specific operations for some identified references. */
  SFDP_DEBUG_STR("7 - read the flash ID")
  (void)SAL_XSPI_GetId(&SFDPObject->sfdp_private.SALObject, DataID, EXTMEM_READ_JEDEC_ID_SIZE);
70008ebc:	683b      	ldr	r3, [r7, #0]
70008ebe:	3308      	adds	r3, #8
70008ec0:	f107 0114 	add.w	r1, r7, #20
70008ec4:	2204      	movs	r2, #4
70008ec6:	4618      	mov	r0, r3
70008ec8:	f7fd ffb8 	bl	70006e3c <SAL_XSPI_GetId>
  DEBUG_ID(DataID);

  /* Keep manufacturer information, it could be used to help in
     building of consistent driver */
  SFDPObject->sfdp_private.ManuID = DataID[0];
70008ecc:	7d3a      	ldrb	r2, [r7, #20]
70008ece:	683b      	ldr	r3, [r7, #0]
70008ed0:	f883 205d 	strb.w	r2, [r3, #93]	@ 0x5d

  /* Get the complete SFDP data */
  SFDP_DEBUG_STR("8 - collect the SFDP data")
  if (EXTMEM_SFDP_OK != SFDP_CollectData(SFDPObject))
70008ed4:	6838      	ldr	r0, [r7, #0]
70008ed6:	f7fe fb2f 	bl	70007538 <SFDP_CollectData>
70008eda:	4603      	mov	r3, r0
70008edc:	2b00      	cmp	r3, #0
70008ede:	d003      	beq.n	70008ee8 <EXTMEM_DRIVER_NOR_SFDP_Init+0x100>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_SFDP;
70008ee0:	23ff      	movs	r3, #255	@ 0xff
70008ee2:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
70008ee6:	e02b      	b.n	70008f40 <EXTMEM_DRIVER_NOR_SFDP_Init+0x158>
  }

  /* Setup the generic driver information and prepare the physical layer */
  SFDP_DEBUG_STR("9 - build the generic driver information and prepare the physical layer")
  if (EXTMEM_SFDP_OK != SFDP_BuildGenericDriver(SFDPObject, &FreqUpdate))
70008ee8:	f107 031b 	add.w	r3, r7, #27
70008eec:	4619      	mov	r1, r3
70008eee:	6838      	ldr	r0, [r7, #0]
70008ef0:	f7fe fcda 	bl	700078a8 <SFDP_BuildGenericDriver>
70008ef4:	4603      	mov	r3, r0
70008ef6:	2b00      	cmp	r3, #0
70008ef8:	d003      	beq.n	70008f02 <EXTMEM_DRIVER_NOR_SFDP_Init+0x11a>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_ERROR_BUILD")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_BUILD;
70008efa:	23fd      	movs	r3, #253	@ 0xfd
70008efc:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
70008f00:	e01e      	b.n	70008f40 <EXTMEM_DRIVER_NOR_SFDP_Init+0x158>
  }

  /* Adjust frequency supplied to memory, if required */
  SFDP_DEBUG_STR("10 - adjust the frequency if required")
  if ((FreqUpdate == 0u) && (SFDPObject->sfdp_public.MaxFreq != 0u))
70008f02:	7efb      	ldrb	r3, [r7, #27]
70008f04:	2b00      	cmp	r3, #0
70008f06:	d10d      	bne.n	70008f24 <EXTMEM_DRIVER_NOR_SFDP_Init+0x13c>
70008f08:	683b      	ldr	r3, [r7, #0]
70008f0a:	681b      	ldr	r3, [r3, #0]
70008f0c:	2b00      	cmp	r3, #0
70008f0e:	d009      	beq.n	70008f24 <EXTMEM_DRIVER_NOR_SFDP_Init+0x13c>
  {
    (void)SAL_XSPI_SetClock(&SFDPObject->sfdp_private.SALObject, ClockInput,
70008f10:	683b      	ldr	r3, [r7, #0]
70008f12:	f103 0008 	add.w	r0, r3, #8
70008f16:	683b      	ldr	r3, [r7, #0]
70008f18:	681a      	ldr	r2, [r3, #0]
70008f1a:	f107 0310 	add.w	r3, r7, #16
70008f1e:	6879      	ldr	r1, [r7, #4]
70008f20:	f7fd fd68 	bl	700069f4 <SAL_XSPI_SetClock>
    SFDP_DEBUG_STR("--> new freq configured");
  }

  /* Read again SFDP header to confirm memory access is properly setup */
  SFDP_DEBUG_STR("11 - read again the SFDP header to adjust memory type if necessary")
  if (EXTMEM_SFDP_OK != SFDP_ReadHeader(SFDPObject, &JEDEC_SFDP_Header))
70008f24:	f107 031c 	add.w	r3, r7, #28
70008f28:	4619      	mov	r1, r3
70008f2a:	6838      	ldr	r0, [r7, #0]
70008f2c:	f7fe fa68 	bl	70007400 <SFDP_ReadHeader>
70008f30:	4603      	mov	r3, r0
70008f32:	2b00      	cmp	r3, #0
70008f34:	d003      	beq.n	70008f3e <EXTMEM_DRIVER_NOR_SFDP_Init+0x156>
  {
    SFDP_DEBUG_STR("ERROR::EXTMEM_DRIVER_NOR_SFDP_MEMTYPE_CHECK")
    retr = EXTMEM_DRIVER_NOR_SFDP_ERROR_MEMTYPE_CHECK;
70008f36:	23f2      	movs	r3, #242	@ 0xf2
70008f38:	f887 3027 	strb.w	r3, [r7, #39]	@ 0x27
    goto error;
70008f3c:	e000      	b.n	70008f40 <EXTMEM_DRIVER_NOR_SFDP_Init+0x158>
  }

error:
70008f3e:	bf00      	nop
  return retr;
70008f40:	f997 3027 	ldrsb.w	r3, [r7, #39]	@ 0x27
}
70008f44:	4618      	mov	r0, r3
70008f46:	3728      	adds	r7, #40	@ 0x28
70008f48:	46bd      	mov	sp, r7
70008f4a:	bd80      	pop	{r7, pc}
70008f4c:	02faf080 	.word	0x02faf080

70008f50 <std>:
70008f50:	2300      	movs	r3, #0
70008f52:	b510      	push	{r4, lr}
70008f54:	4604      	mov	r4, r0
70008f56:	e9c0 3300 	strd	r3, r3, [r0]
70008f5a:	e9c0 3304 	strd	r3, r3, [r0, #16]
70008f5e:	6083      	str	r3, [r0, #8]
70008f60:	8181      	strh	r1, [r0, #12]
70008f62:	6643      	str	r3, [r0, #100]	@ 0x64
70008f64:	81c2      	strh	r2, [r0, #14]
70008f66:	6183      	str	r3, [r0, #24]
70008f68:	4619      	mov	r1, r3
70008f6a:	2208      	movs	r2, #8
70008f6c:	305c      	adds	r0, #92	@ 0x5c
70008f6e:	f000 f906 	bl	7000917e <memset>
70008f72:	4b0d      	ldr	r3, [pc, #52]	@ (70008fa8 <std+0x58>)
70008f74:	6263      	str	r3, [r4, #36]	@ 0x24
70008f76:	4b0d      	ldr	r3, [pc, #52]	@ (70008fac <std+0x5c>)
70008f78:	62a3      	str	r3, [r4, #40]	@ 0x28
70008f7a:	4b0d      	ldr	r3, [pc, #52]	@ (70008fb0 <std+0x60>)
70008f7c:	62e3      	str	r3, [r4, #44]	@ 0x2c
70008f7e:	4b0d      	ldr	r3, [pc, #52]	@ (70008fb4 <std+0x64>)
70008f80:	6323      	str	r3, [r4, #48]	@ 0x30
70008f82:	4b0d      	ldr	r3, [pc, #52]	@ (70008fb8 <std+0x68>)
70008f84:	6224      	str	r4, [r4, #32]
70008f86:	429c      	cmp	r4, r3
70008f88:	d006      	beq.n	70008f98 <std+0x48>
70008f8a:	f103 0268 	add.w	r2, r3, #104	@ 0x68
70008f8e:	4294      	cmp	r4, r2
70008f90:	d002      	beq.n	70008f98 <std+0x48>
70008f92:	33d0      	adds	r3, #208	@ 0xd0
70008f94:	429c      	cmp	r4, r3
70008f96:	d105      	bne.n	70008fa4 <std+0x54>
70008f98:	f104 0058 	add.w	r0, r4, #88	@ 0x58
70008f9c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
70008fa0:	f000 b966 	b.w	70009270 <__retarget_lock_init_recursive>
70008fa4:	bd10      	pop	{r4, pc}
70008fa6:	bf00      	nop
70008fa8:	700090f9 	.word	0x700090f9
70008fac:	7000911b 	.word	0x7000911b
70008fb0:	70009153 	.word	0x70009153
70008fb4:	70009177 	.word	0x70009177
70008fb8:	2400048c 	.word	0x2400048c

70008fbc <stdio_exit_handler>:
70008fbc:	4a02      	ldr	r2, [pc, #8]	@ (70008fc8 <stdio_exit_handler+0xc>)
70008fbe:	4903      	ldr	r1, [pc, #12]	@ (70008fcc <stdio_exit_handler+0x10>)
70008fc0:	4803      	ldr	r0, [pc, #12]	@ (70008fd0 <stdio_exit_handler+0x14>)
70008fc2:	f000 b869 	b.w	70009098 <_fwalk_sglue>
70008fc6:	bf00      	nop
70008fc8:	24000034 	.word	0x24000034
70008fcc:	70009b29 	.word	0x70009b29
70008fd0:	24000044 	.word	0x24000044

70008fd4 <cleanup_stdio>:
70008fd4:	6841      	ldr	r1, [r0, #4]
70008fd6:	4b0c      	ldr	r3, [pc, #48]	@ (70009008 <cleanup_stdio+0x34>)
70008fd8:	4299      	cmp	r1, r3
70008fda:	b510      	push	{r4, lr}
70008fdc:	4604      	mov	r4, r0
70008fde:	d001      	beq.n	70008fe4 <cleanup_stdio+0x10>
70008fe0:	f000 fda2 	bl	70009b28 <_fflush_r>
70008fe4:	68a1      	ldr	r1, [r4, #8]
70008fe6:	4b09      	ldr	r3, [pc, #36]	@ (7000900c <cleanup_stdio+0x38>)
70008fe8:	4299      	cmp	r1, r3
70008fea:	d002      	beq.n	70008ff2 <cleanup_stdio+0x1e>
70008fec:	4620      	mov	r0, r4
70008fee:	f000 fd9b 	bl	70009b28 <_fflush_r>
70008ff2:	68e1      	ldr	r1, [r4, #12]
70008ff4:	4b06      	ldr	r3, [pc, #24]	@ (70009010 <cleanup_stdio+0x3c>)
70008ff6:	4299      	cmp	r1, r3
70008ff8:	d004      	beq.n	70009004 <cleanup_stdio+0x30>
70008ffa:	4620      	mov	r0, r4
70008ffc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
70009000:	f000 bd92 	b.w	70009b28 <_fflush_r>
70009004:	bd10      	pop	{r4, pc}
70009006:	bf00      	nop
70009008:	2400048c 	.word	0x2400048c
7000900c:	240004f4 	.word	0x240004f4
70009010:	2400055c 	.word	0x2400055c

70009014 <global_stdio_init.part.0>:
70009014:	b510      	push	{r4, lr}
70009016:	4b0b      	ldr	r3, [pc, #44]	@ (70009044 <global_stdio_init.part.0+0x30>)
70009018:	4c0b      	ldr	r4, [pc, #44]	@ (70009048 <global_stdio_init.part.0+0x34>)
7000901a:	4a0c      	ldr	r2, [pc, #48]	@ (7000904c <global_stdio_init.part.0+0x38>)
7000901c:	601a      	str	r2, [r3, #0]
7000901e:	4620      	mov	r0, r4
70009020:	2200      	movs	r2, #0
70009022:	2104      	movs	r1, #4
70009024:	f7ff ff94 	bl	70008f50 <std>
70009028:	f104 0068 	add.w	r0, r4, #104	@ 0x68
7000902c:	2201      	movs	r2, #1
7000902e:	2109      	movs	r1, #9
70009030:	f7ff ff8e 	bl	70008f50 <std>
70009034:	f104 00d0 	add.w	r0, r4, #208	@ 0xd0
70009038:	2202      	movs	r2, #2
7000903a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
7000903e:	2112      	movs	r1, #18
70009040:	f7ff bf86 	b.w	70008f50 <std>
70009044:	240005c4 	.word	0x240005c4
70009048:	2400048c 	.word	0x2400048c
7000904c:	70008fbd 	.word	0x70008fbd

70009050 <__sfp_lock_acquire>:
70009050:	4801      	ldr	r0, [pc, #4]	@ (70009058 <__sfp_lock_acquire+0x8>)
70009052:	f000 b90e 	b.w	70009272 <__retarget_lock_acquire_recursive>
70009056:	bf00      	nop
70009058:	240005cd 	.word	0x240005cd

7000905c <__sfp_lock_release>:
7000905c:	4801      	ldr	r0, [pc, #4]	@ (70009064 <__sfp_lock_release+0x8>)
7000905e:	f000 b909 	b.w	70009274 <__retarget_lock_release_recursive>
70009062:	bf00      	nop
70009064:	240005cd 	.word	0x240005cd

70009068 <__sinit>:
70009068:	b510      	push	{r4, lr}
7000906a:	4604      	mov	r4, r0
7000906c:	f7ff fff0 	bl	70009050 <__sfp_lock_acquire>
70009070:	6a23      	ldr	r3, [r4, #32]
70009072:	b11b      	cbz	r3, 7000907c <__sinit+0x14>
70009074:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
70009078:	f7ff bff0 	b.w	7000905c <__sfp_lock_release>
7000907c:	4b04      	ldr	r3, [pc, #16]	@ (70009090 <__sinit+0x28>)
7000907e:	6223      	str	r3, [r4, #32]
70009080:	4b04      	ldr	r3, [pc, #16]	@ (70009094 <__sinit+0x2c>)
70009082:	681b      	ldr	r3, [r3, #0]
70009084:	2b00      	cmp	r3, #0
70009086:	d1f5      	bne.n	70009074 <__sinit+0xc>
70009088:	f7ff ffc4 	bl	70009014 <global_stdio_init.part.0>
7000908c:	e7f2      	b.n	70009074 <__sinit+0xc>
7000908e:	bf00      	nop
70009090:	70008fd5 	.word	0x70008fd5
70009094:	240005c4 	.word	0x240005c4

70009098 <_fwalk_sglue>:
70009098:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
7000909c:	4607      	mov	r7, r0
7000909e:	4688      	mov	r8, r1
700090a0:	4614      	mov	r4, r2
700090a2:	2600      	movs	r6, #0
700090a4:	e9d4 9501 	ldrd	r9, r5, [r4, #4]
700090a8:	f1b9 0901 	subs.w	r9, r9, #1
700090ac:	d505      	bpl.n	700090ba <_fwalk_sglue+0x22>
700090ae:	6824      	ldr	r4, [r4, #0]
700090b0:	2c00      	cmp	r4, #0
700090b2:	d1f7      	bne.n	700090a4 <_fwalk_sglue+0xc>
700090b4:	4630      	mov	r0, r6
700090b6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
700090ba:	89ab      	ldrh	r3, [r5, #12]
700090bc:	2b01      	cmp	r3, #1
700090be:	d907      	bls.n	700090d0 <_fwalk_sglue+0x38>
700090c0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
700090c4:	3301      	adds	r3, #1
700090c6:	d003      	beq.n	700090d0 <_fwalk_sglue+0x38>
700090c8:	4629      	mov	r1, r5
700090ca:	4638      	mov	r0, r7
700090cc:	47c0      	blx	r8
700090ce:	4306      	orrs	r6, r0
700090d0:	3568      	adds	r5, #104	@ 0x68
700090d2:	e7e9      	b.n	700090a8 <_fwalk_sglue+0x10>

700090d4 <iprintf>:
700090d4:	b40f      	push	{r0, r1, r2, r3}
700090d6:	b507      	push	{r0, r1, r2, lr}
700090d8:	4906      	ldr	r1, [pc, #24]	@ (700090f4 <iprintf+0x20>)
700090da:	ab04      	add	r3, sp, #16
700090dc:	6808      	ldr	r0, [r1, #0]
700090de:	f853 2b04 	ldr.w	r2, [r3], #4
700090e2:	6881      	ldr	r1, [r0, #8]
700090e4:	9301      	str	r3, [sp, #4]
700090e6:	f000 f9f7 	bl	700094d8 <_vfiprintf_r>
700090ea:	b003      	add	sp, #12
700090ec:	f85d eb04 	ldr.w	lr, [sp], #4
700090f0:	b004      	add	sp, #16
700090f2:	4770      	bx	lr
700090f4:	24000040 	.word	0x24000040

700090f8 <__sread>:
700090f8:	b510      	push	{r4, lr}
700090fa:	460c      	mov	r4, r1
700090fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
70009100:	f000 f868 	bl	700091d4 <_read_r>
70009104:	2800      	cmp	r0, #0
70009106:	bfab      	itete	ge
70009108:	6d63      	ldrge	r3, [r4, #84]	@ 0x54
7000910a:	89a3      	ldrhlt	r3, [r4, #12]
7000910c:	181b      	addge	r3, r3, r0
7000910e:	f423 5380 	biclt.w	r3, r3, #4096	@ 0x1000
70009112:	bfac      	ite	ge
70009114:	6563      	strge	r3, [r4, #84]	@ 0x54
70009116:	81a3      	strhlt	r3, [r4, #12]
70009118:	bd10      	pop	{r4, pc}

7000911a <__swrite>:
7000911a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
7000911e:	461f      	mov	r7, r3
70009120:	898b      	ldrh	r3, [r1, #12]
70009122:	05db      	lsls	r3, r3, #23
70009124:	4605      	mov	r5, r0
70009126:	460c      	mov	r4, r1
70009128:	4616      	mov	r6, r2
7000912a:	d505      	bpl.n	70009138 <__swrite+0x1e>
7000912c:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
70009130:	2302      	movs	r3, #2
70009132:	2200      	movs	r2, #0
70009134:	f000 f83c 	bl	700091b0 <_lseek_r>
70009138:	89a3      	ldrh	r3, [r4, #12]
7000913a:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
7000913e:	f423 5380 	bic.w	r3, r3, #4096	@ 0x1000
70009142:	81a3      	strh	r3, [r4, #12]
70009144:	4632      	mov	r2, r6
70009146:	463b      	mov	r3, r7
70009148:	4628      	mov	r0, r5
7000914a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
7000914e:	f000 b853 	b.w	700091f8 <_write_r>

70009152 <__sseek>:
70009152:	b510      	push	{r4, lr}
70009154:	460c      	mov	r4, r1
70009156:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
7000915a:	f000 f829 	bl	700091b0 <_lseek_r>
7000915e:	1c43      	adds	r3, r0, #1
70009160:	89a3      	ldrh	r3, [r4, #12]
70009162:	bf15      	itete	ne
70009164:	6560      	strne	r0, [r4, #84]	@ 0x54
70009166:	f423 5380 	biceq.w	r3, r3, #4096	@ 0x1000
7000916a:	f443 5380 	orrne.w	r3, r3, #4096	@ 0x1000
7000916e:	81a3      	strheq	r3, [r4, #12]
70009170:	bf18      	it	ne
70009172:	81a3      	strhne	r3, [r4, #12]
70009174:	bd10      	pop	{r4, pc}

70009176 <__sclose>:
70009176:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
7000917a:	f000 b809 	b.w	70009190 <_close_r>

7000917e <memset>:
7000917e:	4402      	add	r2, r0
70009180:	4603      	mov	r3, r0
70009182:	4293      	cmp	r3, r2
70009184:	d100      	bne.n	70009188 <memset+0xa>
70009186:	4770      	bx	lr
70009188:	f803 1b01 	strb.w	r1, [r3], #1
7000918c:	e7f9      	b.n	70009182 <memset+0x4>
	...

70009190 <_close_r>:
70009190:	b538      	push	{r3, r4, r5, lr}
70009192:	4d06      	ldr	r5, [pc, #24]	@ (700091ac <_close_r+0x1c>)
70009194:	2300      	movs	r3, #0
70009196:	4604      	mov	r4, r0
70009198:	4608      	mov	r0, r1
7000919a:	602b      	str	r3, [r5, #0]
7000919c:	f7f7 fddd 	bl	70000d5a <_close>
700091a0:	1c43      	adds	r3, r0, #1
700091a2:	d102      	bne.n	700091aa <_close_r+0x1a>
700091a4:	682b      	ldr	r3, [r5, #0]
700091a6:	b103      	cbz	r3, 700091aa <_close_r+0x1a>
700091a8:	6023      	str	r3, [r4, #0]
700091aa:	bd38      	pop	{r3, r4, r5, pc}
700091ac:	240005c8 	.word	0x240005c8

700091b0 <_lseek_r>:
700091b0:	b538      	push	{r3, r4, r5, lr}
700091b2:	4d07      	ldr	r5, [pc, #28]	@ (700091d0 <_lseek_r+0x20>)
700091b4:	4604      	mov	r4, r0
700091b6:	4608      	mov	r0, r1
700091b8:	4611      	mov	r1, r2
700091ba:	2200      	movs	r2, #0
700091bc:	602a      	str	r2, [r5, #0]
700091be:	461a      	mov	r2, r3
700091c0:	f7f7 fdf2 	bl	70000da8 <_lseek>
700091c4:	1c43      	adds	r3, r0, #1
700091c6:	d102      	bne.n	700091ce <_lseek_r+0x1e>
700091c8:	682b      	ldr	r3, [r5, #0]
700091ca:	b103      	cbz	r3, 700091ce <_lseek_r+0x1e>
700091cc:	6023      	str	r3, [r4, #0]
700091ce:	bd38      	pop	{r3, r4, r5, pc}
700091d0:	240005c8 	.word	0x240005c8

700091d4 <_read_r>:
700091d4:	b538      	push	{r3, r4, r5, lr}
700091d6:	4d07      	ldr	r5, [pc, #28]	@ (700091f4 <_read_r+0x20>)
700091d8:	4604      	mov	r4, r0
700091da:	4608      	mov	r0, r1
700091dc:	4611      	mov	r1, r2
700091de:	2200      	movs	r2, #0
700091e0:	602a      	str	r2, [r5, #0]
700091e2:	461a      	mov	r2, r3
700091e4:	f7f7 fd80 	bl	70000ce8 <_read>
700091e8:	1c43      	adds	r3, r0, #1
700091ea:	d102      	bne.n	700091f2 <_read_r+0x1e>
700091ec:	682b      	ldr	r3, [r5, #0]
700091ee:	b103      	cbz	r3, 700091f2 <_read_r+0x1e>
700091f0:	6023      	str	r3, [r4, #0]
700091f2:	bd38      	pop	{r3, r4, r5, pc}
700091f4:	240005c8 	.word	0x240005c8

700091f8 <_write_r>:
700091f8:	b538      	push	{r3, r4, r5, lr}
700091fa:	4d07      	ldr	r5, [pc, #28]	@ (70009218 <_write_r+0x20>)
700091fc:	4604      	mov	r4, r0
700091fe:	4608      	mov	r0, r1
70009200:	4611      	mov	r1, r2
70009202:	2200      	movs	r2, #0
70009204:	602a      	str	r2, [r5, #0]
70009206:	461a      	mov	r2, r3
70009208:	f7f7 fd8b 	bl	70000d22 <_write>
7000920c:	1c43      	adds	r3, r0, #1
7000920e:	d102      	bne.n	70009216 <_write_r+0x1e>
70009210:	682b      	ldr	r3, [r5, #0]
70009212:	b103      	cbz	r3, 70009216 <_write_r+0x1e>
70009214:	6023      	str	r3, [r4, #0]
70009216:	bd38      	pop	{r3, r4, r5, pc}
70009218:	240005c8 	.word	0x240005c8

7000921c <__errno>:
7000921c:	4b01      	ldr	r3, [pc, #4]	@ (70009224 <__errno+0x8>)
7000921e:	6818      	ldr	r0, [r3, #0]
70009220:	4770      	bx	lr
70009222:	bf00      	nop
70009224:	24000040 	.word	0x24000040

70009228 <__libc_init_array>:
70009228:	b570      	push	{r4, r5, r6, lr}
7000922a:	4d0d      	ldr	r5, [pc, #52]	@ (70009260 <__libc_init_array+0x38>)
7000922c:	4c0d      	ldr	r4, [pc, #52]	@ (70009264 <__libc_init_array+0x3c>)
7000922e:	1b64      	subs	r4, r4, r5
70009230:	10a4      	asrs	r4, r4, #2
70009232:	2600      	movs	r6, #0
70009234:	42a6      	cmp	r6, r4
70009236:	d109      	bne.n	7000924c <__libc_init_array+0x24>
70009238:	4d0b      	ldr	r5, [pc, #44]	@ (70009268 <__libc_init_array+0x40>)
7000923a:	4c0c      	ldr	r4, [pc, #48]	@ (7000926c <__libc_init_array+0x44>)
7000923c:	f000 fdc4 	bl	70009dc8 <_init>
70009240:	1b64      	subs	r4, r4, r5
70009242:	10a4      	asrs	r4, r4, #2
70009244:	2600      	movs	r6, #0
70009246:	42a6      	cmp	r6, r4
70009248:	d105      	bne.n	70009256 <__libc_init_array+0x2e>
7000924a:	bd70      	pop	{r4, r5, r6, pc}
7000924c:	f855 3b04 	ldr.w	r3, [r5], #4
70009250:	4798      	blx	r3
70009252:	3601      	adds	r6, #1
70009254:	e7ee      	b.n	70009234 <__libc_init_array+0xc>
70009256:	f855 3b04 	ldr.w	r3, [r5], #4
7000925a:	4798      	blx	r3
7000925c:	3601      	adds	r6, #1
7000925e:	e7f2      	b.n	70009246 <__libc_init_array+0x1e>
70009260:	70009ed0 	.word	0x70009ed0
70009264:	70009ed0 	.word	0x70009ed0
70009268:	70009ed0 	.word	0x70009ed0
7000926c:	70009ed4 	.word	0x70009ed4

70009270 <__retarget_lock_init_recursive>:
70009270:	4770      	bx	lr

70009272 <__retarget_lock_acquire_recursive>:
70009272:	4770      	bx	lr

70009274 <__retarget_lock_release_recursive>:
70009274:	4770      	bx	lr

70009276 <memcpy>:
70009276:	440a      	add	r2, r1
70009278:	4291      	cmp	r1, r2
7000927a:	f100 33ff 	add.w	r3, r0, #4294967295	@ 0xffffffff
7000927e:	d100      	bne.n	70009282 <memcpy+0xc>
70009280:	4770      	bx	lr
70009282:	b510      	push	{r4, lr}
70009284:	f811 4b01 	ldrb.w	r4, [r1], #1
70009288:	f803 4f01 	strb.w	r4, [r3, #1]!
7000928c:	4291      	cmp	r1, r2
7000928e:	d1f9      	bne.n	70009284 <memcpy+0xe>
70009290:	bd10      	pop	{r4, pc}
	...

70009294 <_free_r>:
70009294:	b538      	push	{r3, r4, r5, lr}
70009296:	4605      	mov	r5, r0
70009298:	2900      	cmp	r1, #0
7000929a:	d041      	beq.n	70009320 <_free_r+0x8c>
7000929c:	f851 3c04 	ldr.w	r3, [r1, #-4]
700092a0:	1f0c      	subs	r4, r1, #4
700092a2:	2b00      	cmp	r3, #0
700092a4:	bfb8      	it	lt
700092a6:	18e4      	addlt	r4, r4, r3
700092a8:	f000 f8e0 	bl	7000946c <__malloc_lock>
700092ac:	4a1d      	ldr	r2, [pc, #116]	@ (70009324 <_free_r+0x90>)
700092ae:	6813      	ldr	r3, [r2, #0]
700092b0:	b933      	cbnz	r3, 700092c0 <_free_r+0x2c>
700092b2:	6063      	str	r3, [r4, #4]
700092b4:	6014      	str	r4, [r2, #0]
700092b6:	4628      	mov	r0, r5
700092b8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
700092bc:	f000 b8dc 	b.w	70009478 <__malloc_unlock>
700092c0:	42a3      	cmp	r3, r4
700092c2:	d908      	bls.n	700092d6 <_free_r+0x42>
700092c4:	6820      	ldr	r0, [r4, #0]
700092c6:	1821      	adds	r1, r4, r0
700092c8:	428b      	cmp	r3, r1
700092ca:	bf01      	itttt	eq
700092cc:	6819      	ldreq	r1, [r3, #0]
700092ce:	685b      	ldreq	r3, [r3, #4]
700092d0:	1809      	addeq	r1, r1, r0
700092d2:	6021      	streq	r1, [r4, #0]
700092d4:	e7ed      	b.n	700092b2 <_free_r+0x1e>
700092d6:	461a      	mov	r2, r3
700092d8:	685b      	ldr	r3, [r3, #4]
700092da:	b10b      	cbz	r3, 700092e0 <_free_r+0x4c>
700092dc:	42a3      	cmp	r3, r4
700092de:	d9fa      	bls.n	700092d6 <_free_r+0x42>
700092e0:	6811      	ldr	r1, [r2, #0]
700092e2:	1850      	adds	r0, r2, r1
700092e4:	42a0      	cmp	r0, r4
700092e6:	d10b      	bne.n	70009300 <_free_r+0x6c>
700092e8:	6820      	ldr	r0, [r4, #0]
700092ea:	4401      	add	r1, r0
700092ec:	1850      	adds	r0, r2, r1
700092ee:	4283      	cmp	r3, r0
700092f0:	6011      	str	r1, [r2, #0]
700092f2:	d1e0      	bne.n	700092b6 <_free_r+0x22>
700092f4:	6818      	ldr	r0, [r3, #0]
700092f6:	685b      	ldr	r3, [r3, #4]
700092f8:	6053      	str	r3, [r2, #4]
700092fa:	4408      	add	r0, r1
700092fc:	6010      	str	r0, [r2, #0]
700092fe:	e7da      	b.n	700092b6 <_free_r+0x22>
70009300:	d902      	bls.n	70009308 <_free_r+0x74>
70009302:	230c      	movs	r3, #12
70009304:	602b      	str	r3, [r5, #0]
70009306:	e7d6      	b.n	700092b6 <_free_r+0x22>
70009308:	6820      	ldr	r0, [r4, #0]
7000930a:	1821      	adds	r1, r4, r0
7000930c:	428b      	cmp	r3, r1
7000930e:	bf04      	itt	eq
70009310:	6819      	ldreq	r1, [r3, #0]
70009312:	685b      	ldreq	r3, [r3, #4]
70009314:	6063      	str	r3, [r4, #4]
70009316:	bf04      	itt	eq
70009318:	1809      	addeq	r1, r1, r0
7000931a:	6021      	streq	r1, [r4, #0]
7000931c:	6054      	str	r4, [r2, #4]
7000931e:	e7ca      	b.n	700092b6 <_free_r+0x22>
70009320:	bd38      	pop	{r3, r4, r5, pc}
70009322:	bf00      	nop
70009324:	240005d4 	.word	0x240005d4

70009328 <sbrk_aligned>:
70009328:	b570      	push	{r4, r5, r6, lr}
7000932a:	4e0f      	ldr	r6, [pc, #60]	@ (70009368 <sbrk_aligned+0x40>)
7000932c:	460c      	mov	r4, r1
7000932e:	6831      	ldr	r1, [r6, #0]
70009330:	4605      	mov	r5, r0
70009332:	b911      	cbnz	r1, 7000933a <sbrk_aligned+0x12>
70009334:	f000 fcb4 	bl	70009ca0 <_sbrk_r>
70009338:	6030      	str	r0, [r6, #0]
7000933a:	4621      	mov	r1, r4
7000933c:	4628      	mov	r0, r5
7000933e:	f000 fcaf 	bl	70009ca0 <_sbrk_r>
70009342:	1c43      	adds	r3, r0, #1
70009344:	d103      	bne.n	7000934e <sbrk_aligned+0x26>
70009346:	f04f 34ff 	mov.w	r4, #4294967295	@ 0xffffffff
7000934a:	4620      	mov	r0, r4
7000934c:	bd70      	pop	{r4, r5, r6, pc}
7000934e:	1cc4      	adds	r4, r0, #3
70009350:	f024 0403 	bic.w	r4, r4, #3
70009354:	42a0      	cmp	r0, r4
70009356:	d0f8      	beq.n	7000934a <sbrk_aligned+0x22>
70009358:	1a21      	subs	r1, r4, r0
7000935a:	4628      	mov	r0, r5
7000935c:	f000 fca0 	bl	70009ca0 <_sbrk_r>
70009360:	3001      	adds	r0, #1
70009362:	d1f2      	bne.n	7000934a <sbrk_aligned+0x22>
70009364:	e7ef      	b.n	70009346 <sbrk_aligned+0x1e>
70009366:	bf00      	nop
70009368:	240005d0 	.word	0x240005d0

7000936c <_malloc_r>:
7000936c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
70009370:	1ccd      	adds	r5, r1, #3
70009372:	f025 0503 	bic.w	r5, r5, #3
70009376:	3508      	adds	r5, #8
70009378:	2d0c      	cmp	r5, #12
7000937a:	bf38      	it	cc
7000937c:	250c      	movcc	r5, #12
7000937e:	2d00      	cmp	r5, #0
70009380:	4606      	mov	r6, r0
70009382:	db01      	blt.n	70009388 <_malloc_r+0x1c>
70009384:	42a9      	cmp	r1, r5
70009386:	d904      	bls.n	70009392 <_malloc_r+0x26>
70009388:	230c      	movs	r3, #12
7000938a:	6033      	str	r3, [r6, #0]
7000938c:	2000      	movs	r0, #0
7000938e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
70009392:	f8df 80d4 	ldr.w	r8, [pc, #212]	@ 70009468 <_malloc_r+0xfc>
70009396:	f000 f869 	bl	7000946c <__malloc_lock>
7000939a:	f8d8 3000 	ldr.w	r3, [r8]
7000939e:	461c      	mov	r4, r3
700093a0:	bb44      	cbnz	r4, 700093f4 <_malloc_r+0x88>
700093a2:	4629      	mov	r1, r5
700093a4:	4630      	mov	r0, r6
700093a6:	f7ff ffbf 	bl	70009328 <sbrk_aligned>
700093aa:	1c43      	adds	r3, r0, #1
700093ac:	4604      	mov	r4, r0
700093ae:	d158      	bne.n	70009462 <_malloc_r+0xf6>
700093b0:	f8d8 4000 	ldr.w	r4, [r8]
700093b4:	4627      	mov	r7, r4
700093b6:	2f00      	cmp	r7, #0
700093b8:	d143      	bne.n	70009442 <_malloc_r+0xd6>
700093ba:	2c00      	cmp	r4, #0
700093bc:	d04b      	beq.n	70009456 <_malloc_r+0xea>
700093be:	6823      	ldr	r3, [r4, #0]
700093c0:	4639      	mov	r1, r7
700093c2:	4630      	mov	r0, r6
700093c4:	eb04 0903 	add.w	r9, r4, r3
700093c8:	f000 fc6a 	bl	70009ca0 <_sbrk_r>
700093cc:	4581      	cmp	r9, r0
700093ce:	d142      	bne.n	70009456 <_malloc_r+0xea>
700093d0:	6821      	ldr	r1, [r4, #0]
700093d2:	1a6d      	subs	r5, r5, r1
700093d4:	4629      	mov	r1, r5
700093d6:	4630      	mov	r0, r6
700093d8:	f7ff ffa6 	bl	70009328 <sbrk_aligned>
700093dc:	3001      	adds	r0, #1
700093de:	d03a      	beq.n	70009456 <_malloc_r+0xea>
700093e0:	6823      	ldr	r3, [r4, #0]
700093e2:	442b      	add	r3, r5
700093e4:	6023      	str	r3, [r4, #0]
700093e6:	f8d8 3000 	ldr.w	r3, [r8]
700093ea:	685a      	ldr	r2, [r3, #4]
700093ec:	bb62      	cbnz	r2, 70009448 <_malloc_r+0xdc>
700093ee:	f8c8 7000 	str.w	r7, [r8]
700093f2:	e00f      	b.n	70009414 <_malloc_r+0xa8>
700093f4:	6822      	ldr	r2, [r4, #0]
700093f6:	1b52      	subs	r2, r2, r5
700093f8:	d420      	bmi.n	7000943c <_malloc_r+0xd0>
700093fa:	2a0b      	cmp	r2, #11
700093fc:	d917      	bls.n	7000942e <_malloc_r+0xc2>
700093fe:	1961      	adds	r1, r4, r5
70009400:	42a3      	cmp	r3, r4
70009402:	6025      	str	r5, [r4, #0]
70009404:	bf18      	it	ne
70009406:	6059      	strne	r1, [r3, #4]
70009408:	6863      	ldr	r3, [r4, #4]
7000940a:	bf08      	it	eq
7000940c:	f8c8 1000 	streq.w	r1, [r8]
70009410:	5162      	str	r2, [r4, r5]
70009412:	604b      	str	r3, [r1, #4]
70009414:	4630      	mov	r0, r6
70009416:	f000 f82f 	bl	70009478 <__malloc_unlock>
7000941a:	f104 000b 	add.w	r0, r4, #11
7000941e:	1d23      	adds	r3, r4, #4
70009420:	f020 0007 	bic.w	r0, r0, #7
70009424:	1ac2      	subs	r2, r0, r3
70009426:	bf1c      	itt	ne
70009428:	1a1b      	subne	r3, r3, r0
7000942a:	50a3      	strne	r3, [r4, r2]
7000942c:	e7af      	b.n	7000938e <_malloc_r+0x22>
7000942e:	6862      	ldr	r2, [r4, #4]
70009430:	42a3      	cmp	r3, r4
70009432:	bf0c      	ite	eq
70009434:	f8c8 2000 	streq.w	r2, [r8]
70009438:	605a      	strne	r2, [r3, #4]
7000943a:	e7eb      	b.n	70009414 <_malloc_r+0xa8>
7000943c:	4623      	mov	r3, r4
7000943e:	6864      	ldr	r4, [r4, #4]
70009440:	e7ae      	b.n	700093a0 <_malloc_r+0x34>
70009442:	463c      	mov	r4, r7
70009444:	687f      	ldr	r7, [r7, #4]
70009446:	e7b6      	b.n	700093b6 <_malloc_r+0x4a>
70009448:	461a      	mov	r2, r3
7000944a:	685b      	ldr	r3, [r3, #4]
7000944c:	42a3      	cmp	r3, r4
7000944e:	d1fb      	bne.n	70009448 <_malloc_r+0xdc>
70009450:	2300      	movs	r3, #0
70009452:	6053      	str	r3, [r2, #4]
70009454:	e7de      	b.n	70009414 <_malloc_r+0xa8>
70009456:	230c      	movs	r3, #12
70009458:	6033      	str	r3, [r6, #0]
7000945a:	4630      	mov	r0, r6
7000945c:	f000 f80c 	bl	70009478 <__malloc_unlock>
70009460:	e794      	b.n	7000938c <_malloc_r+0x20>
70009462:	6005      	str	r5, [r0, #0]
70009464:	e7d6      	b.n	70009414 <_malloc_r+0xa8>
70009466:	bf00      	nop
70009468:	240005d4 	.word	0x240005d4

7000946c <__malloc_lock>:
7000946c:	4801      	ldr	r0, [pc, #4]	@ (70009474 <__malloc_lock+0x8>)
7000946e:	f7ff bf00 	b.w	70009272 <__retarget_lock_acquire_recursive>
70009472:	bf00      	nop
70009474:	240005cc 	.word	0x240005cc

70009478 <__malloc_unlock>:
70009478:	4801      	ldr	r0, [pc, #4]	@ (70009480 <__malloc_unlock+0x8>)
7000947a:	f7ff befb 	b.w	70009274 <__retarget_lock_release_recursive>
7000947e:	bf00      	nop
70009480:	240005cc 	.word	0x240005cc

70009484 <__sfputc_r>:
70009484:	6893      	ldr	r3, [r2, #8]
70009486:	3b01      	subs	r3, #1
70009488:	2b00      	cmp	r3, #0
7000948a:	b410      	push	{r4}
7000948c:	6093      	str	r3, [r2, #8]
7000948e:	da08      	bge.n	700094a2 <__sfputc_r+0x1e>
70009490:	6994      	ldr	r4, [r2, #24]
70009492:	42a3      	cmp	r3, r4
70009494:	db01      	blt.n	7000949a <__sfputc_r+0x16>
70009496:	290a      	cmp	r1, #10
70009498:	d103      	bne.n	700094a2 <__sfputc_r+0x1e>
7000949a:	f85d 4b04 	ldr.w	r4, [sp], #4
7000949e:	f000 bb6b 	b.w	70009b78 <__swbuf_r>
700094a2:	6813      	ldr	r3, [r2, #0]
700094a4:	1c58      	adds	r0, r3, #1
700094a6:	6010      	str	r0, [r2, #0]
700094a8:	7019      	strb	r1, [r3, #0]
700094aa:	4608      	mov	r0, r1
700094ac:	f85d 4b04 	ldr.w	r4, [sp], #4
700094b0:	4770      	bx	lr

700094b2 <__sfputs_r>:
700094b2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
700094b4:	4606      	mov	r6, r0
700094b6:	460f      	mov	r7, r1
700094b8:	4614      	mov	r4, r2
700094ba:	18d5      	adds	r5, r2, r3
700094bc:	42ac      	cmp	r4, r5
700094be:	d101      	bne.n	700094c4 <__sfputs_r+0x12>
700094c0:	2000      	movs	r0, #0
700094c2:	e007      	b.n	700094d4 <__sfputs_r+0x22>
700094c4:	f814 1b01 	ldrb.w	r1, [r4], #1
700094c8:	463a      	mov	r2, r7
700094ca:	4630      	mov	r0, r6
700094cc:	f7ff ffda 	bl	70009484 <__sfputc_r>
700094d0:	1c43      	adds	r3, r0, #1
700094d2:	d1f3      	bne.n	700094bc <__sfputs_r+0xa>
700094d4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

700094d8 <_vfiprintf_r>:
700094d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
700094dc:	460d      	mov	r5, r1
700094de:	b09d      	sub	sp, #116	@ 0x74
700094e0:	4614      	mov	r4, r2
700094e2:	4698      	mov	r8, r3
700094e4:	4606      	mov	r6, r0
700094e6:	b118      	cbz	r0, 700094f0 <_vfiprintf_r+0x18>
700094e8:	6a03      	ldr	r3, [r0, #32]
700094ea:	b90b      	cbnz	r3, 700094f0 <_vfiprintf_r+0x18>
700094ec:	f7ff fdbc 	bl	70009068 <__sinit>
700094f0:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
700094f2:	07d9      	lsls	r1, r3, #31
700094f4:	d405      	bmi.n	70009502 <_vfiprintf_r+0x2a>
700094f6:	89ab      	ldrh	r3, [r5, #12]
700094f8:	059a      	lsls	r2, r3, #22
700094fa:	d402      	bmi.n	70009502 <_vfiprintf_r+0x2a>
700094fc:	6da8      	ldr	r0, [r5, #88]	@ 0x58
700094fe:	f7ff feb8 	bl	70009272 <__retarget_lock_acquire_recursive>
70009502:	89ab      	ldrh	r3, [r5, #12]
70009504:	071b      	lsls	r3, r3, #28
70009506:	d501      	bpl.n	7000950c <_vfiprintf_r+0x34>
70009508:	692b      	ldr	r3, [r5, #16]
7000950a:	b99b      	cbnz	r3, 70009534 <_vfiprintf_r+0x5c>
7000950c:	4629      	mov	r1, r5
7000950e:	4630      	mov	r0, r6
70009510:	f000 fb70 	bl	70009bf4 <__swsetup_r>
70009514:	b170      	cbz	r0, 70009534 <_vfiprintf_r+0x5c>
70009516:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
70009518:	07dc      	lsls	r4, r3, #31
7000951a:	d504      	bpl.n	70009526 <_vfiprintf_r+0x4e>
7000951c:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
70009520:	b01d      	add	sp, #116	@ 0x74
70009522:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
70009526:	89ab      	ldrh	r3, [r5, #12]
70009528:	0598      	lsls	r0, r3, #22
7000952a:	d4f7      	bmi.n	7000951c <_vfiprintf_r+0x44>
7000952c:	6da8      	ldr	r0, [r5, #88]	@ 0x58
7000952e:	f7ff fea1 	bl	70009274 <__retarget_lock_release_recursive>
70009532:	e7f3      	b.n	7000951c <_vfiprintf_r+0x44>
70009534:	2300      	movs	r3, #0
70009536:	9309      	str	r3, [sp, #36]	@ 0x24
70009538:	2320      	movs	r3, #32
7000953a:	f88d 3029 	strb.w	r3, [sp, #41]	@ 0x29
7000953e:	f8cd 800c 	str.w	r8, [sp, #12]
70009542:	2330      	movs	r3, #48	@ 0x30
70009544:	f8df 81ac 	ldr.w	r8, [pc, #428]	@ 700096f4 <_vfiprintf_r+0x21c>
70009548:	f88d 302a 	strb.w	r3, [sp, #42]	@ 0x2a
7000954c:	f04f 0901 	mov.w	r9, #1
70009550:	4623      	mov	r3, r4
70009552:	469a      	mov	sl, r3
70009554:	f813 2b01 	ldrb.w	r2, [r3], #1
70009558:	b10a      	cbz	r2, 7000955e <_vfiprintf_r+0x86>
7000955a:	2a25      	cmp	r2, #37	@ 0x25
7000955c:	d1f9      	bne.n	70009552 <_vfiprintf_r+0x7a>
7000955e:	ebba 0b04 	subs.w	fp, sl, r4
70009562:	d00b      	beq.n	7000957c <_vfiprintf_r+0xa4>
70009564:	465b      	mov	r3, fp
70009566:	4622      	mov	r2, r4
70009568:	4629      	mov	r1, r5
7000956a:	4630      	mov	r0, r6
7000956c:	f7ff ffa1 	bl	700094b2 <__sfputs_r>
70009570:	3001      	adds	r0, #1
70009572:	f000 80a7 	beq.w	700096c4 <_vfiprintf_r+0x1ec>
70009576:	9a09      	ldr	r2, [sp, #36]	@ 0x24
70009578:	445a      	add	r2, fp
7000957a:	9209      	str	r2, [sp, #36]	@ 0x24
7000957c:	f89a 3000 	ldrb.w	r3, [sl]
70009580:	2b00      	cmp	r3, #0
70009582:	f000 809f 	beq.w	700096c4 <_vfiprintf_r+0x1ec>
70009586:	2300      	movs	r3, #0
70009588:	f04f 32ff 	mov.w	r2, #4294967295	@ 0xffffffff
7000958c:	e9cd 2305 	strd	r2, r3, [sp, #20]
70009590:	f10a 0a01 	add.w	sl, sl, #1
70009594:	9304      	str	r3, [sp, #16]
70009596:	9307      	str	r3, [sp, #28]
70009598:	f88d 3053 	strb.w	r3, [sp, #83]	@ 0x53
7000959c:	931a      	str	r3, [sp, #104]	@ 0x68
7000959e:	4654      	mov	r4, sl
700095a0:	2205      	movs	r2, #5
700095a2:	f814 1b01 	ldrb.w	r1, [r4], #1
700095a6:	4853      	ldr	r0, [pc, #332]	@ (700096f4 <_vfiprintf_r+0x21c>)
700095a8:	f7f6 feba 	bl	70000320 <memchr>
700095ac:	9a04      	ldr	r2, [sp, #16]
700095ae:	b9d8      	cbnz	r0, 700095e8 <_vfiprintf_r+0x110>
700095b0:	06d1      	lsls	r1, r2, #27
700095b2:	bf44      	itt	mi
700095b4:	2320      	movmi	r3, #32
700095b6:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
700095ba:	0713      	lsls	r3, r2, #28
700095bc:	bf44      	itt	mi
700095be:	232b      	movmi	r3, #43	@ 0x2b
700095c0:	f88d 3053 	strbmi.w	r3, [sp, #83]	@ 0x53
700095c4:	f89a 3000 	ldrb.w	r3, [sl]
700095c8:	2b2a      	cmp	r3, #42	@ 0x2a
700095ca:	d015      	beq.n	700095f8 <_vfiprintf_r+0x120>
700095cc:	9a07      	ldr	r2, [sp, #28]
700095ce:	4654      	mov	r4, sl
700095d0:	2000      	movs	r0, #0
700095d2:	f04f 0c0a 	mov.w	ip, #10
700095d6:	4621      	mov	r1, r4
700095d8:	f811 3b01 	ldrb.w	r3, [r1], #1
700095dc:	3b30      	subs	r3, #48	@ 0x30
700095de:	2b09      	cmp	r3, #9
700095e0:	d94b      	bls.n	7000967a <_vfiprintf_r+0x1a2>
700095e2:	b1b0      	cbz	r0, 70009612 <_vfiprintf_r+0x13a>
700095e4:	9207      	str	r2, [sp, #28]
700095e6:	e014      	b.n	70009612 <_vfiprintf_r+0x13a>
700095e8:	eba0 0308 	sub.w	r3, r0, r8
700095ec:	fa09 f303 	lsl.w	r3, r9, r3
700095f0:	4313      	orrs	r3, r2
700095f2:	9304      	str	r3, [sp, #16]
700095f4:	46a2      	mov	sl, r4
700095f6:	e7d2      	b.n	7000959e <_vfiprintf_r+0xc6>
700095f8:	9b03      	ldr	r3, [sp, #12]
700095fa:	1d19      	adds	r1, r3, #4
700095fc:	681b      	ldr	r3, [r3, #0]
700095fe:	9103      	str	r1, [sp, #12]
70009600:	2b00      	cmp	r3, #0
70009602:	bfbb      	ittet	lt
70009604:	425b      	neglt	r3, r3
70009606:	f042 0202 	orrlt.w	r2, r2, #2
7000960a:	9307      	strge	r3, [sp, #28]
7000960c:	9307      	strlt	r3, [sp, #28]
7000960e:	bfb8      	it	lt
70009610:	9204      	strlt	r2, [sp, #16]
70009612:	7823      	ldrb	r3, [r4, #0]
70009614:	2b2e      	cmp	r3, #46	@ 0x2e
70009616:	d10a      	bne.n	7000962e <_vfiprintf_r+0x156>
70009618:	7863      	ldrb	r3, [r4, #1]
7000961a:	2b2a      	cmp	r3, #42	@ 0x2a
7000961c:	d132      	bne.n	70009684 <_vfiprintf_r+0x1ac>
7000961e:	9b03      	ldr	r3, [sp, #12]
70009620:	1d1a      	adds	r2, r3, #4
70009622:	681b      	ldr	r3, [r3, #0]
70009624:	9203      	str	r2, [sp, #12]
70009626:	ea43 73e3 	orr.w	r3, r3, r3, asr #31
7000962a:	3402      	adds	r4, #2
7000962c:	9305      	str	r3, [sp, #20]
7000962e:	f8df a0d4 	ldr.w	sl, [pc, #212]	@ 70009704 <_vfiprintf_r+0x22c>
70009632:	7821      	ldrb	r1, [r4, #0]
70009634:	2203      	movs	r2, #3
70009636:	4650      	mov	r0, sl
70009638:	f7f6 fe72 	bl	70000320 <memchr>
7000963c:	b138      	cbz	r0, 7000964e <_vfiprintf_r+0x176>
7000963e:	9b04      	ldr	r3, [sp, #16]
70009640:	eba0 000a 	sub.w	r0, r0, sl
70009644:	2240      	movs	r2, #64	@ 0x40
70009646:	4082      	lsls	r2, r0
70009648:	4313      	orrs	r3, r2
7000964a:	3401      	adds	r4, #1
7000964c:	9304      	str	r3, [sp, #16]
7000964e:	f814 1b01 	ldrb.w	r1, [r4], #1
70009652:	4829      	ldr	r0, [pc, #164]	@ (700096f8 <_vfiprintf_r+0x220>)
70009654:	f88d 1028 	strb.w	r1, [sp, #40]	@ 0x28
70009658:	2206      	movs	r2, #6
7000965a:	f7f6 fe61 	bl	70000320 <memchr>
7000965e:	2800      	cmp	r0, #0
70009660:	d03f      	beq.n	700096e2 <_vfiprintf_r+0x20a>
70009662:	4b26      	ldr	r3, [pc, #152]	@ (700096fc <_vfiprintf_r+0x224>)
70009664:	bb1b      	cbnz	r3, 700096ae <_vfiprintf_r+0x1d6>
70009666:	9b03      	ldr	r3, [sp, #12]
70009668:	3307      	adds	r3, #7
7000966a:	f023 0307 	bic.w	r3, r3, #7
7000966e:	3308      	adds	r3, #8
70009670:	9303      	str	r3, [sp, #12]
70009672:	9b09      	ldr	r3, [sp, #36]	@ 0x24
70009674:	443b      	add	r3, r7
70009676:	9309      	str	r3, [sp, #36]	@ 0x24
70009678:	e76a      	b.n	70009550 <_vfiprintf_r+0x78>
7000967a:	fb0c 3202 	mla	r2, ip, r2, r3
7000967e:	460c      	mov	r4, r1
70009680:	2001      	movs	r0, #1
70009682:	e7a8      	b.n	700095d6 <_vfiprintf_r+0xfe>
70009684:	2300      	movs	r3, #0
70009686:	3401      	adds	r4, #1
70009688:	9305      	str	r3, [sp, #20]
7000968a:	4619      	mov	r1, r3
7000968c:	f04f 0c0a 	mov.w	ip, #10
70009690:	4620      	mov	r0, r4
70009692:	f810 2b01 	ldrb.w	r2, [r0], #1
70009696:	3a30      	subs	r2, #48	@ 0x30
70009698:	2a09      	cmp	r2, #9
7000969a:	d903      	bls.n	700096a4 <_vfiprintf_r+0x1cc>
7000969c:	2b00      	cmp	r3, #0
7000969e:	d0c6      	beq.n	7000962e <_vfiprintf_r+0x156>
700096a0:	9105      	str	r1, [sp, #20]
700096a2:	e7c4      	b.n	7000962e <_vfiprintf_r+0x156>
700096a4:	fb0c 2101 	mla	r1, ip, r1, r2
700096a8:	4604      	mov	r4, r0
700096aa:	2301      	movs	r3, #1
700096ac:	e7f0      	b.n	70009690 <_vfiprintf_r+0x1b8>
700096ae:	ab03      	add	r3, sp, #12
700096b0:	9300      	str	r3, [sp, #0]
700096b2:	462a      	mov	r2, r5
700096b4:	4b12      	ldr	r3, [pc, #72]	@ (70009700 <_vfiprintf_r+0x228>)
700096b6:	a904      	add	r1, sp, #16
700096b8:	4630      	mov	r0, r6
700096ba:	f3af 8000 	nop.w
700096be:	4607      	mov	r7, r0
700096c0:	1c78      	adds	r0, r7, #1
700096c2:	d1d6      	bne.n	70009672 <_vfiprintf_r+0x19a>
700096c4:	6e6b      	ldr	r3, [r5, #100]	@ 0x64
700096c6:	07d9      	lsls	r1, r3, #31
700096c8:	d405      	bmi.n	700096d6 <_vfiprintf_r+0x1fe>
700096ca:	89ab      	ldrh	r3, [r5, #12]
700096cc:	059a      	lsls	r2, r3, #22
700096ce:	d402      	bmi.n	700096d6 <_vfiprintf_r+0x1fe>
700096d0:	6da8      	ldr	r0, [r5, #88]	@ 0x58
700096d2:	f7ff fdcf 	bl	70009274 <__retarget_lock_release_recursive>
700096d6:	89ab      	ldrh	r3, [r5, #12]
700096d8:	065b      	lsls	r3, r3, #25
700096da:	f53f af1f 	bmi.w	7000951c <_vfiprintf_r+0x44>
700096de:	9809      	ldr	r0, [sp, #36]	@ 0x24
700096e0:	e71e      	b.n	70009520 <_vfiprintf_r+0x48>
700096e2:	ab03      	add	r3, sp, #12
700096e4:	9300      	str	r3, [sp, #0]
700096e6:	462a      	mov	r2, r5
700096e8:	4b05      	ldr	r3, [pc, #20]	@ (70009700 <_vfiprintf_r+0x228>)
700096ea:	a904      	add	r1, sp, #16
700096ec:	4630      	mov	r0, r6
700096ee:	f000 f879 	bl	700097e4 <_printf_i>
700096f2:	e7e4      	b.n	700096be <_vfiprintf_r+0x1e6>
700096f4:	70009e94 	.word	0x70009e94
700096f8:	70009e9e 	.word	0x70009e9e
700096fc:	00000000 	.word	0x00000000
70009700:	700094b3 	.word	0x700094b3
70009704:	70009e9a 	.word	0x70009e9a

70009708 <_printf_common>:
70009708:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
7000970c:	4616      	mov	r6, r2
7000970e:	4698      	mov	r8, r3
70009710:	688a      	ldr	r2, [r1, #8]
70009712:	690b      	ldr	r3, [r1, #16]
70009714:	f8dd 9020 	ldr.w	r9, [sp, #32]
70009718:	4293      	cmp	r3, r2
7000971a:	bfb8      	it	lt
7000971c:	4613      	movlt	r3, r2
7000971e:	6033      	str	r3, [r6, #0]
70009720:	f891 2043 	ldrb.w	r2, [r1, #67]	@ 0x43
70009724:	4607      	mov	r7, r0
70009726:	460c      	mov	r4, r1
70009728:	b10a      	cbz	r2, 7000972e <_printf_common+0x26>
7000972a:	3301      	adds	r3, #1
7000972c:	6033      	str	r3, [r6, #0]
7000972e:	6823      	ldr	r3, [r4, #0]
70009730:	0699      	lsls	r1, r3, #26
70009732:	bf42      	ittt	mi
70009734:	6833      	ldrmi	r3, [r6, #0]
70009736:	3302      	addmi	r3, #2
70009738:	6033      	strmi	r3, [r6, #0]
7000973a:	6825      	ldr	r5, [r4, #0]
7000973c:	f015 0506 	ands.w	r5, r5, #6
70009740:	d106      	bne.n	70009750 <_printf_common+0x48>
70009742:	f104 0a19 	add.w	sl, r4, #25
70009746:	68e3      	ldr	r3, [r4, #12]
70009748:	6832      	ldr	r2, [r6, #0]
7000974a:	1a9b      	subs	r3, r3, r2
7000974c:	42ab      	cmp	r3, r5
7000974e:	dc26      	bgt.n	7000979e <_printf_common+0x96>
70009750:	f894 3043 	ldrb.w	r3, [r4, #67]	@ 0x43
70009754:	6822      	ldr	r2, [r4, #0]
70009756:	3b00      	subs	r3, #0
70009758:	bf18      	it	ne
7000975a:	2301      	movne	r3, #1
7000975c:	0692      	lsls	r2, r2, #26
7000975e:	d42b      	bmi.n	700097b8 <_printf_common+0xb0>
70009760:	f104 0243 	add.w	r2, r4, #67	@ 0x43
70009764:	4641      	mov	r1, r8
70009766:	4638      	mov	r0, r7
70009768:	47c8      	blx	r9
7000976a:	3001      	adds	r0, #1
7000976c:	d01e      	beq.n	700097ac <_printf_common+0xa4>
7000976e:	6823      	ldr	r3, [r4, #0]
70009770:	6922      	ldr	r2, [r4, #16]
70009772:	f003 0306 	and.w	r3, r3, #6
70009776:	2b04      	cmp	r3, #4
70009778:	bf02      	ittt	eq
7000977a:	68e5      	ldreq	r5, [r4, #12]
7000977c:	6833      	ldreq	r3, [r6, #0]
7000977e:	1aed      	subeq	r5, r5, r3
70009780:	68a3      	ldr	r3, [r4, #8]
70009782:	bf0c      	ite	eq
70009784:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
70009788:	2500      	movne	r5, #0
7000978a:	4293      	cmp	r3, r2
7000978c:	bfc4      	itt	gt
7000978e:	1a9b      	subgt	r3, r3, r2
70009790:	18ed      	addgt	r5, r5, r3
70009792:	2600      	movs	r6, #0
70009794:	341a      	adds	r4, #26
70009796:	42b5      	cmp	r5, r6
70009798:	d11a      	bne.n	700097d0 <_printf_common+0xc8>
7000979a:	2000      	movs	r0, #0
7000979c:	e008      	b.n	700097b0 <_printf_common+0xa8>
7000979e:	2301      	movs	r3, #1
700097a0:	4652      	mov	r2, sl
700097a2:	4641      	mov	r1, r8
700097a4:	4638      	mov	r0, r7
700097a6:	47c8      	blx	r9
700097a8:	3001      	adds	r0, #1
700097aa:	d103      	bne.n	700097b4 <_printf_common+0xac>
700097ac:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
700097b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
700097b4:	3501      	adds	r5, #1
700097b6:	e7c6      	b.n	70009746 <_printf_common+0x3e>
700097b8:	18e1      	adds	r1, r4, r3
700097ba:	1c5a      	adds	r2, r3, #1
700097bc:	2030      	movs	r0, #48	@ 0x30
700097be:	f881 0043 	strb.w	r0, [r1, #67]	@ 0x43
700097c2:	4422      	add	r2, r4
700097c4:	f894 1045 	ldrb.w	r1, [r4, #69]	@ 0x45
700097c8:	f882 1043 	strb.w	r1, [r2, #67]	@ 0x43
700097cc:	3302      	adds	r3, #2
700097ce:	e7c7      	b.n	70009760 <_printf_common+0x58>
700097d0:	2301      	movs	r3, #1
700097d2:	4622      	mov	r2, r4
700097d4:	4641      	mov	r1, r8
700097d6:	4638      	mov	r0, r7
700097d8:	47c8      	blx	r9
700097da:	3001      	adds	r0, #1
700097dc:	d0e6      	beq.n	700097ac <_printf_common+0xa4>
700097de:	3601      	adds	r6, #1
700097e0:	e7d9      	b.n	70009796 <_printf_common+0x8e>
	...

700097e4 <_printf_i>:
700097e4:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
700097e8:	7e0f      	ldrb	r7, [r1, #24]
700097ea:	9e0c      	ldr	r6, [sp, #48]	@ 0x30
700097ec:	2f78      	cmp	r7, #120	@ 0x78
700097ee:	4691      	mov	r9, r2
700097f0:	4680      	mov	r8, r0
700097f2:	460c      	mov	r4, r1
700097f4:	469a      	mov	sl, r3
700097f6:	f101 0243 	add.w	r2, r1, #67	@ 0x43
700097fa:	d807      	bhi.n	7000980c <_printf_i+0x28>
700097fc:	2f62      	cmp	r7, #98	@ 0x62
700097fe:	d80a      	bhi.n	70009816 <_printf_i+0x32>
70009800:	2f00      	cmp	r7, #0
70009802:	f000 80d1 	beq.w	700099a8 <_printf_i+0x1c4>
70009806:	2f58      	cmp	r7, #88	@ 0x58
70009808:	f000 80b8 	beq.w	7000997c <_printf_i+0x198>
7000980c:	f104 0642 	add.w	r6, r4, #66	@ 0x42
70009810:	f884 7042 	strb.w	r7, [r4, #66]	@ 0x42
70009814:	e03a      	b.n	7000988c <_printf_i+0xa8>
70009816:	f1a7 0363 	sub.w	r3, r7, #99	@ 0x63
7000981a:	2b15      	cmp	r3, #21
7000981c:	d8f6      	bhi.n	7000980c <_printf_i+0x28>
7000981e:	a101      	add	r1, pc, #4	@ (adr r1, 70009824 <_printf_i+0x40>)
70009820:	f851 f023 	ldr.w	pc, [r1, r3, lsl #2]
70009824:	7000987d 	.word	0x7000987d
70009828:	70009891 	.word	0x70009891
7000982c:	7000980d 	.word	0x7000980d
70009830:	7000980d 	.word	0x7000980d
70009834:	7000980d 	.word	0x7000980d
70009838:	7000980d 	.word	0x7000980d
7000983c:	70009891 	.word	0x70009891
70009840:	7000980d 	.word	0x7000980d
70009844:	7000980d 	.word	0x7000980d
70009848:	7000980d 	.word	0x7000980d
7000984c:	7000980d 	.word	0x7000980d
70009850:	7000998f 	.word	0x7000998f
70009854:	700098bb 	.word	0x700098bb
70009858:	70009949 	.word	0x70009949
7000985c:	7000980d 	.word	0x7000980d
70009860:	7000980d 	.word	0x7000980d
70009864:	700099b1 	.word	0x700099b1
70009868:	7000980d 	.word	0x7000980d
7000986c:	700098bb 	.word	0x700098bb
70009870:	7000980d 	.word	0x7000980d
70009874:	7000980d 	.word	0x7000980d
70009878:	70009951 	.word	0x70009951
7000987c:	6833      	ldr	r3, [r6, #0]
7000987e:	1d1a      	adds	r2, r3, #4
70009880:	681b      	ldr	r3, [r3, #0]
70009882:	6032      	str	r2, [r6, #0]
70009884:	f104 0642 	add.w	r6, r4, #66	@ 0x42
70009888:	f884 3042 	strb.w	r3, [r4, #66]	@ 0x42
7000988c:	2301      	movs	r3, #1
7000988e:	e09c      	b.n	700099ca <_printf_i+0x1e6>
70009890:	6833      	ldr	r3, [r6, #0]
70009892:	6820      	ldr	r0, [r4, #0]
70009894:	1d19      	adds	r1, r3, #4
70009896:	6031      	str	r1, [r6, #0]
70009898:	0606      	lsls	r6, r0, #24
7000989a:	d501      	bpl.n	700098a0 <_printf_i+0xbc>
7000989c:	681d      	ldr	r5, [r3, #0]
7000989e:	e003      	b.n	700098a8 <_printf_i+0xc4>
700098a0:	0645      	lsls	r5, r0, #25
700098a2:	d5fb      	bpl.n	7000989c <_printf_i+0xb8>
700098a4:	f9b3 5000 	ldrsh.w	r5, [r3]
700098a8:	2d00      	cmp	r5, #0
700098aa:	da03      	bge.n	700098b4 <_printf_i+0xd0>
700098ac:	232d      	movs	r3, #45	@ 0x2d
700098ae:	426d      	negs	r5, r5
700098b0:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
700098b4:	4858      	ldr	r0, [pc, #352]	@ (70009a18 <_printf_i+0x234>)
700098b6:	230a      	movs	r3, #10
700098b8:	e011      	b.n	700098de <_printf_i+0xfa>
700098ba:	6821      	ldr	r1, [r4, #0]
700098bc:	6833      	ldr	r3, [r6, #0]
700098be:	0608      	lsls	r0, r1, #24
700098c0:	f853 5b04 	ldr.w	r5, [r3], #4
700098c4:	d402      	bmi.n	700098cc <_printf_i+0xe8>
700098c6:	0649      	lsls	r1, r1, #25
700098c8:	bf48      	it	mi
700098ca:	b2ad      	uxthmi	r5, r5
700098cc:	2f6f      	cmp	r7, #111	@ 0x6f
700098ce:	4852      	ldr	r0, [pc, #328]	@ (70009a18 <_printf_i+0x234>)
700098d0:	6033      	str	r3, [r6, #0]
700098d2:	bf14      	ite	ne
700098d4:	230a      	movne	r3, #10
700098d6:	2308      	moveq	r3, #8
700098d8:	2100      	movs	r1, #0
700098da:	f884 1043 	strb.w	r1, [r4, #67]	@ 0x43
700098de:	6866      	ldr	r6, [r4, #4]
700098e0:	60a6      	str	r6, [r4, #8]
700098e2:	2e00      	cmp	r6, #0
700098e4:	db05      	blt.n	700098f2 <_printf_i+0x10e>
700098e6:	6821      	ldr	r1, [r4, #0]
700098e8:	432e      	orrs	r6, r5
700098ea:	f021 0104 	bic.w	r1, r1, #4
700098ee:	6021      	str	r1, [r4, #0]
700098f0:	d04b      	beq.n	7000998a <_printf_i+0x1a6>
700098f2:	4616      	mov	r6, r2
700098f4:	fbb5 f1f3 	udiv	r1, r5, r3
700098f8:	fb03 5711 	mls	r7, r3, r1, r5
700098fc:	5dc7      	ldrb	r7, [r0, r7]
700098fe:	f806 7d01 	strb.w	r7, [r6, #-1]!
70009902:	462f      	mov	r7, r5
70009904:	42bb      	cmp	r3, r7
70009906:	460d      	mov	r5, r1
70009908:	d9f4      	bls.n	700098f4 <_printf_i+0x110>
7000990a:	2b08      	cmp	r3, #8
7000990c:	d10b      	bne.n	70009926 <_printf_i+0x142>
7000990e:	6823      	ldr	r3, [r4, #0]
70009910:	07df      	lsls	r7, r3, #31
70009912:	d508      	bpl.n	70009926 <_printf_i+0x142>
70009914:	6923      	ldr	r3, [r4, #16]
70009916:	6861      	ldr	r1, [r4, #4]
70009918:	4299      	cmp	r1, r3
7000991a:	bfde      	ittt	le
7000991c:	2330      	movle	r3, #48	@ 0x30
7000991e:	f806 3c01 	strble.w	r3, [r6, #-1]
70009922:	f106 36ff 	addle.w	r6, r6, #4294967295	@ 0xffffffff
70009926:	1b92      	subs	r2, r2, r6
70009928:	6122      	str	r2, [r4, #16]
7000992a:	f8cd a000 	str.w	sl, [sp]
7000992e:	464b      	mov	r3, r9
70009930:	aa03      	add	r2, sp, #12
70009932:	4621      	mov	r1, r4
70009934:	4640      	mov	r0, r8
70009936:	f7ff fee7 	bl	70009708 <_printf_common>
7000993a:	3001      	adds	r0, #1
7000993c:	d14a      	bne.n	700099d4 <_printf_i+0x1f0>
7000993e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
70009942:	b004      	add	sp, #16
70009944:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
70009948:	6823      	ldr	r3, [r4, #0]
7000994a:	f043 0320 	orr.w	r3, r3, #32
7000994e:	6023      	str	r3, [r4, #0]
70009950:	4832      	ldr	r0, [pc, #200]	@ (70009a1c <_printf_i+0x238>)
70009952:	2778      	movs	r7, #120	@ 0x78
70009954:	f884 7045 	strb.w	r7, [r4, #69]	@ 0x45
70009958:	6823      	ldr	r3, [r4, #0]
7000995a:	6831      	ldr	r1, [r6, #0]
7000995c:	061f      	lsls	r7, r3, #24
7000995e:	f851 5b04 	ldr.w	r5, [r1], #4
70009962:	d402      	bmi.n	7000996a <_printf_i+0x186>
70009964:	065f      	lsls	r7, r3, #25
70009966:	bf48      	it	mi
70009968:	b2ad      	uxthmi	r5, r5
7000996a:	6031      	str	r1, [r6, #0]
7000996c:	07d9      	lsls	r1, r3, #31
7000996e:	bf44      	itt	mi
70009970:	f043 0320 	orrmi.w	r3, r3, #32
70009974:	6023      	strmi	r3, [r4, #0]
70009976:	b11d      	cbz	r5, 70009980 <_printf_i+0x19c>
70009978:	2310      	movs	r3, #16
7000997a:	e7ad      	b.n	700098d8 <_printf_i+0xf4>
7000997c:	4826      	ldr	r0, [pc, #152]	@ (70009a18 <_printf_i+0x234>)
7000997e:	e7e9      	b.n	70009954 <_printf_i+0x170>
70009980:	6823      	ldr	r3, [r4, #0]
70009982:	f023 0320 	bic.w	r3, r3, #32
70009986:	6023      	str	r3, [r4, #0]
70009988:	e7f6      	b.n	70009978 <_printf_i+0x194>
7000998a:	4616      	mov	r6, r2
7000998c:	e7bd      	b.n	7000990a <_printf_i+0x126>
7000998e:	6833      	ldr	r3, [r6, #0]
70009990:	6825      	ldr	r5, [r4, #0]
70009992:	6961      	ldr	r1, [r4, #20]
70009994:	1d18      	adds	r0, r3, #4
70009996:	6030      	str	r0, [r6, #0]
70009998:	062e      	lsls	r6, r5, #24
7000999a:	681b      	ldr	r3, [r3, #0]
7000999c:	d501      	bpl.n	700099a2 <_printf_i+0x1be>
7000999e:	6019      	str	r1, [r3, #0]
700099a0:	e002      	b.n	700099a8 <_printf_i+0x1c4>
700099a2:	0668      	lsls	r0, r5, #25
700099a4:	d5fb      	bpl.n	7000999e <_printf_i+0x1ba>
700099a6:	8019      	strh	r1, [r3, #0]
700099a8:	2300      	movs	r3, #0
700099aa:	6123      	str	r3, [r4, #16]
700099ac:	4616      	mov	r6, r2
700099ae:	e7bc      	b.n	7000992a <_printf_i+0x146>
700099b0:	6833      	ldr	r3, [r6, #0]
700099b2:	1d1a      	adds	r2, r3, #4
700099b4:	6032      	str	r2, [r6, #0]
700099b6:	681e      	ldr	r6, [r3, #0]
700099b8:	6862      	ldr	r2, [r4, #4]
700099ba:	2100      	movs	r1, #0
700099bc:	4630      	mov	r0, r6
700099be:	f7f6 fcaf 	bl	70000320 <memchr>
700099c2:	b108      	cbz	r0, 700099c8 <_printf_i+0x1e4>
700099c4:	1b80      	subs	r0, r0, r6
700099c6:	6060      	str	r0, [r4, #4]
700099c8:	6863      	ldr	r3, [r4, #4]
700099ca:	6123      	str	r3, [r4, #16]
700099cc:	2300      	movs	r3, #0
700099ce:	f884 3043 	strb.w	r3, [r4, #67]	@ 0x43
700099d2:	e7aa      	b.n	7000992a <_printf_i+0x146>
700099d4:	6923      	ldr	r3, [r4, #16]
700099d6:	4632      	mov	r2, r6
700099d8:	4649      	mov	r1, r9
700099da:	4640      	mov	r0, r8
700099dc:	47d0      	blx	sl
700099de:	3001      	adds	r0, #1
700099e0:	d0ad      	beq.n	7000993e <_printf_i+0x15a>
700099e2:	6823      	ldr	r3, [r4, #0]
700099e4:	079b      	lsls	r3, r3, #30
700099e6:	d413      	bmi.n	70009a10 <_printf_i+0x22c>
700099e8:	68e0      	ldr	r0, [r4, #12]
700099ea:	9b03      	ldr	r3, [sp, #12]
700099ec:	4298      	cmp	r0, r3
700099ee:	bfb8      	it	lt
700099f0:	4618      	movlt	r0, r3
700099f2:	e7a6      	b.n	70009942 <_printf_i+0x15e>
700099f4:	2301      	movs	r3, #1
700099f6:	4632      	mov	r2, r6
700099f8:	4649      	mov	r1, r9
700099fa:	4640      	mov	r0, r8
700099fc:	47d0      	blx	sl
700099fe:	3001      	adds	r0, #1
70009a00:	d09d      	beq.n	7000993e <_printf_i+0x15a>
70009a02:	3501      	adds	r5, #1
70009a04:	68e3      	ldr	r3, [r4, #12]
70009a06:	9903      	ldr	r1, [sp, #12]
70009a08:	1a5b      	subs	r3, r3, r1
70009a0a:	42ab      	cmp	r3, r5
70009a0c:	dcf2      	bgt.n	700099f4 <_printf_i+0x210>
70009a0e:	e7eb      	b.n	700099e8 <_printf_i+0x204>
70009a10:	2500      	movs	r5, #0
70009a12:	f104 0619 	add.w	r6, r4, #25
70009a16:	e7f5      	b.n	70009a04 <_printf_i+0x220>
70009a18:	70009ea5 	.word	0x70009ea5
70009a1c:	70009eb6 	.word	0x70009eb6

70009a20 <__sflush_r>:
70009a20:	f9b1 200c 	ldrsh.w	r2, [r1, #12]
70009a24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
70009a28:	0716      	lsls	r6, r2, #28
70009a2a:	4605      	mov	r5, r0
70009a2c:	460c      	mov	r4, r1
70009a2e:	d454      	bmi.n	70009ada <__sflush_r+0xba>
70009a30:	684b      	ldr	r3, [r1, #4]
70009a32:	2b00      	cmp	r3, #0
70009a34:	dc02      	bgt.n	70009a3c <__sflush_r+0x1c>
70009a36:	6c0b      	ldr	r3, [r1, #64]	@ 0x40
70009a38:	2b00      	cmp	r3, #0
70009a3a:	dd48      	ble.n	70009ace <__sflush_r+0xae>
70009a3c:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
70009a3e:	2e00      	cmp	r6, #0
70009a40:	d045      	beq.n	70009ace <__sflush_r+0xae>
70009a42:	2300      	movs	r3, #0
70009a44:	f412 5280 	ands.w	r2, r2, #4096	@ 0x1000
70009a48:	682f      	ldr	r7, [r5, #0]
70009a4a:	6a21      	ldr	r1, [r4, #32]
70009a4c:	602b      	str	r3, [r5, #0]
70009a4e:	d030      	beq.n	70009ab2 <__sflush_r+0x92>
70009a50:	6d62      	ldr	r2, [r4, #84]	@ 0x54
70009a52:	89a3      	ldrh	r3, [r4, #12]
70009a54:	0759      	lsls	r1, r3, #29
70009a56:	d505      	bpl.n	70009a64 <__sflush_r+0x44>
70009a58:	6863      	ldr	r3, [r4, #4]
70009a5a:	1ad2      	subs	r2, r2, r3
70009a5c:	6b63      	ldr	r3, [r4, #52]	@ 0x34
70009a5e:	b10b      	cbz	r3, 70009a64 <__sflush_r+0x44>
70009a60:	6c23      	ldr	r3, [r4, #64]	@ 0x40
70009a62:	1ad2      	subs	r2, r2, r3
70009a64:	2300      	movs	r3, #0
70009a66:	6ae6      	ldr	r6, [r4, #44]	@ 0x2c
70009a68:	6a21      	ldr	r1, [r4, #32]
70009a6a:	4628      	mov	r0, r5
70009a6c:	47b0      	blx	r6
70009a6e:	1c43      	adds	r3, r0, #1
70009a70:	89a3      	ldrh	r3, [r4, #12]
70009a72:	d106      	bne.n	70009a82 <__sflush_r+0x62>
70009a74:	6829      	ldr	r1, [r5, #0]
70009a76:	291d      	cmp	r1, #29
70009a78:	d82b      	bhi.n	70009ad2 <__sflush_r+0xb2>
70009a7a:	4a2a      	ldr	r2, [pc, #168]	@ (70009b24 <__sflush_r+0x104>)
70009a7c:	40ca      	lsrs	r2, r1
70009a7e:	07d6      	lsls	r6, r2, #31
70009a80:	d527      	bpl.n	70009ad2 <__sflush_r+0xb2>
70009a82:	2200      	movs	r2, #0
70009a84:	6062      	str	r2, [r4, #4]
70009a86:	04d9      	lsls	r1, r3, #19
70009a88:	6922      	ldr	r2, [r4, #16]
70009a8a:	6022      	str	r2, [r4, #0]
70009a8c:	d504      	bpl.n	70009a98 <__sflush_r+0x78>
70009a8e:	1c42      	adds	r2, r0, #1
70009a90:	d101      	bne.n	70009a96 <__sflush_r+0x76>
70009a92:	682b      	ldr	r3, [r5, #0]
70009a94:	b903      	cbnz	r3, 70009a98 <__sflush_r+0x78>
70009a96:	6560      	str	r0, [r4, #84]	@ 0x54
70009a98:	6b61      	ldr	r1, [r4, #52]	@ 0x34
70009a9a:	602f      	str	r7, [r5, #0]
70009a9c:	b1b9      	cbz	r1, 70009ace <__sflush_r+0xae>
70009a9e:	f104 0344 	add.w	r3, r4, #68	@ 0x44
70009aa2:	4299      	cmp	r1, r3
70009aa4:	d002      	beq.n	70009aac <__sflush_r+0x8c>
70009aa6:	4628      	mov	r0, r5
70009aa8:	f7ff fbf4 	bl	70009294 <_free_r>
70009aac:	2300      	movs	r3, #0
70009aae:	6363      	str	r3, [r4, #52]	@ 0x34
70009ab0:	e00d      	b.n	70009ace <__sflush_r+0xae>
70009ab2:	2301      	movs	r3, #1
70009ab4:	4628      	mov	r0, r5
70009ab6:	47b0      	blx	r6
70009ab8:	4602      	mov	r2, r0
70009aba:	1c50      	adds	r0, r2, #1
70009abc:	d1c9      	bne.n	70009a52 <__sflush_r+0x32>
70009abe:	682b      	ldr	r3, [r5, #0]
70009ac0:	2b00      	cmp	r3, #0
70009ac2:	d0c6      	beq.n	70009a52 <__sflush_r+0x32>
70009ac4:	2b1d      	cmp	r3, #29
70009ac6:	d001      	beq.n	70009acc <__sflush_r+0xac>
70009ac8:	2b16      	cmp	r3, #22
70009aca:	d11e      	bne.n	70009b0a <__sflush_r+0xea>
70009acc:	602f      	str	r7, [r5, #0]
70009ace:	2000      	movs	r0, #0
70009ad0:	e022      	b.n	70009b18 <__sflush_r+0xf8>
70009ad2:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70009ad6:	b21b      	sxth	r3, r3
70009ad8:	e01b      	b.n	70009b12 <__sflush_r+0xf2>
70009ada:	690f      	ldr	r7, [r1, #16]
70009adc:	2f00      	cmp	r7, #0
70009ade:	d0f6      	beq.n	70009ace <__sflush_r+0xae>
70009ae0:	0793      	lsls	r3, r2, #30
70009ae2:	680e      	ldr	r6, [r1, #0]
70009ae4:	bf08      	it	eq
70009ae6:	694b      	ldreq	r3, [r1, #20]
70009ae8:	600f      	str	r7, [r1, #0]
70009aea:	bf18      	it	ne
70009aec:	2300      	movne	r3, #0
70009aee:	eba6 0807 	sub.w	r8, r6, r7
70009af2:	608b      	str	r3, [r1, #8]
70009af4:	f1b8 0f00 	cmp.w	r8, #0
70009af8:	dde9      	ble.n	70009ace <__sflush_r+0xae>
70009afa:	6a21      	ldr	r1, [r4, #32]
70009afc:	6aa6      	ldr	r6, [r4, #40]	@ 0x28
70009afe:	4643      	mov	r3, r8
70009b00:	463a      	mov	r2, r7
70009b02:	4628      	mov	r0, r5
70009b04:	47b0      	blx	r6
70009b06:	2800      	cmp	r0, #0
70009b08:	dc08      	bgt.n	70009b1c <__sflush_r+0xfc>
70009b0a:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
70009b0e:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70009b12:	81a3      	strh	r3, [r4, #12]
70009b14:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
70009b18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
70009b1c:	4407      	add	r7, r0
70009b1e:	eba8 0800 	sub.w	r8, r8, r0
70009b22:	e7e7      	b.n	70009af4 <__sflush_r+0xd4>
70009b24:	20400001 	.word	0x20400001

70009b28 <_fflush_r>:
70009b28:	b538      	push	{r3, r4, r5, lr}
70009b2a:	690b      	ldr	r3, [r1, #16]
70009b2c:	4605      	mov	r5, r0
70009b2e:	460c      	mov	r4, r1
70009b30:	b913      	cbnz	r3, 70009b38 <_fflush_r+0x10>
70009b32:	2500      	movs	r5, #0
70009b34:	4628      	mov	r0, r5
70009b36:	bd38      	pop	{r3, r4, r5, pc}
70009b38:	b118      	cbz	r0, 70009b42 <_fflush_r+0x1a>
70009b3a:	6a03      	ldr	r3, [r0, #32]
70009b3c:	b90b      	cbnz	r3, 70009b42 <_fflush_r+0x1a>
70009b3e:	f7ff fa93 	bl	70009068 <__sinit>
70009b42:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
70009b46:	2b00      	cmp	r3, #0
70009b48:	d0f3      	beq.n	70009b32 <_fflush_r+0xa>
70009b4a:	6e62      	ldr	r2, [r4, #100]	@ 0x64
70009b4c:	07d0      	lsls	r0, r2, #31
70009b4e:	d404      	bmi.n	70009b5a <_fflush_r+0x32>
70009b50:	0599      	lsls	r1, r3, #22
70009b52:	d402      	bmi.n	70009b5a <_fflush_r+0x32>
70009b54:	6da0      	ldr	r0, [r4, #88]	@ 0x58
70009b56:	f7ff fb8c 	bl	70009272 <__retarget_lock_acquire_recursive>
70009b5a:	4628      	mov	r0, r5
70009b5c:	4621      	mov	r1, r4
70009b5e:	f7ff ff5f 	bl	70009a20 <__sflush_r>
70009b62:	6e63      	ldr	r3, [r4, #100]	@ 0x64
70009b64:	07da      	lsls	r2, r3, #31
70009b66:	4605      	mov	r5, r0
70009b68:	d4e4      	bmi.n	70009b34 <_fflush_r+0xc>
70009b6a:	89a3      	ldrh	r3, [r4, #12]
70009b6c:	059b      	lsls	r3, r3, #22
70009b6e:	d4e1      	bmi.n	70009b34 <_fflush_r+0xc>
70009b70:	6da0      	ldr	r0, [r4, #88]	@ 0x58
70009b72:	f7ff fb7f 	bl	70009274 <__retarget_lock_release_recursive>
70009b76:	e7dd      	b.n	70009b34 <_fflush_r+0xc>

70009b78 <__swbuf_r>:
70009b78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
70009b7a:	460e      	mov	r6, r1
70009b7c:	4614      	mov	r4, r2
70009b7e:	4605      	mov	r5, r0
70009b80:	b118      	cbz	r0, 70009b8a <__swbuf_r+0x12>
70009b82:	6a03      	ldr	r3, [r0, #32]
70009b84:	b90b      	cbnz	r3, 70009b8a <__swbuf_r+0x12>
70009b86:	f7ff fa6f 	bl	70009068 <__sinit>
70009b8a:	69a3      	ldr	r3, [r4, #24]
70009b8c:	60a3      	str	r3, [r4, #8]
70009b8e:	89a3      	ldrh	r3, [r4, #12]
70009b90:	071a      	lsls	r2, r3, #28
70009b92:	d501      	bpl.n	70009b98 <__swbuf_r+0x20>
70009b94:	6923      	ldr	r3, [r4, #16]
70009b96:	b943      	cbnz	r3, 70009baa <__swbuf_r+0x32>
70009b98:	4621      	mov	r1, r4
70009b9a:	4628      	mov	r0, r5
70009b9c:	f000 f82a 	bl	70009bf4 <__swsetup_r>
70009ba0:	b118      	cbz	r0, 70009baa <__swbuf_r+0x32>
70009ba2:	f04f 37ff 	mov.w	r7, #4294967295	@ 0xffffffff
70009ba6:	4638      	mov	r0, r7
70009ba8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
70009baa:	6823      	ldr	r3, [r4, #0]
70009bac:	6922      	ldr	r2, [r4, #16]
70009bae:	1a98      	subs	r0, r3, r2
70009bb0:	6963      	ldr	r3, [r4, #20]
70009bb2:	b2f6      	uxtb	r6, r6
70009bb4:	4283      	cmp	r3, r0
70009bb6:	4637      	mov	r7, r6
70009bb8:	dc05      	bgt.n	70009bc6 <__swbuf_r+0x4e>
70009bba:	4621      	mov	r1, r4
70009bbc:	4628      	mov	r0, r5
70009bbe:	f7ff ffb3 	bl	70009b28 <_fflush_r>
70009bc2:	2800      	cmp	r0, #0
70009bc4:	d1ed      	bne.n	70009ba2 <__swbuf_r+0x2a>
70009bc6:	68a3      	ldr	r3, [r4, #8]
70009bc8:	3b01      	subs	r3, #1
70009bca:	60a3      	str	r3, [r4, #8]
70009bcc:	6823      	ldr	r3, [r4, #0]
70009bce:	1c5a      	adds	r2, r3, #1
70009bd0:	6022      	str	r2, [r4, #0]
70009bd2:	701e      	strb	r6, [r3, #0]
70009bd4:	6962      	ldr	r2, [r4, #20]
70009bd6:	1c43      	adds	r3, r0, #1
70009bd8:	429a      	cmp	r2, r3
70009bda:	d004      	beq.n	70009be6 <__swbuf_r+0x6e>
70009bdc:	89a3      	ldrh	r3, [r4, #12]
70009bde:	07db      	lsls	r3, r3, #31
70009be0:	d5e1      	bpl.n	70009ba6 <__swbuf_r+0x2e>
70009be2:	2e0a      	cmp	r6, #10
70009be4:	d1df      	bne.n	70009ba6 <__swbuf_r+0x2e>
70009be6:	4621      	mov	r1, r4
70009be8:	4628      	mov	r0, r5
70009bea:	f7ff ff9d 	bl	70009b28 <_fflush_r>
70009bee:	2800      	cmp	r0, #0
70009bf0:	d0d9      	beq.n	70009ba6 <__swbuf_r+0x2e>
70009bf2:	e7d6      	b.n	70009ba2 <__swbuf_r+0x2a>

70009bf4 <__swsetup_r>:
70009bf4:	b538      	push	{r3, r4, r5, lr}
70009bf6:	4b29      	ldr	r3, [pc, #164]	@ (70009c9c <__swsetup_r+0xa8>)
70009bf8:	4605      	mov	r5, r0
70009bfa:	6818      	ldr	r0, [r3, #0]
70009bfc:	460c      	mov	r4, r1
70009bfe:	b118      	cbz	r0, 70009c08 <__swsetup_r+0x14>
70009c00:	6a03      	ldr	r3, [r0, #32]
70009c02:	b90b      	cbnz	r3, 70009c08 <__swsetup_r+0x14>
70009c04:	f7ff fa30 	bl	70009068 <__sinit>
70009c08:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
70009c0c:	0719      	lsls	r1, r3, #28
70009c0e:	d422      	bmi.n	70009c56 <__swsetup_r+0x62>
70009c10:	06da      	lsls	r2, r3, #27
70009c12:	d407      	bmi.n	70009c24 <__swsetup_r+0x30>
70009c14:	2209      	movs	r2, #9
70009c16:	602a      	str	r2, [r5, #0]
70009c18:	f043 0340 	orr.w	r3, r3, #64	@ 0x40
70009c1c:	81a3      	strh	r3, [r4, #12]
70009c1e:	f04f 30ff 	mov.w	r0, #4294967295	@ 0xffffffff
70009c22:	e033      	b.n	70009c8c <__swsetup_r+0x98>
70009c24:	0758      	lsls	r0, r3, #29
70009c26:	d512      	bpl.n	70009c4e <__swsetup_r+0x5a>
70009c28:	6b61      	ldr	r1, [r4, #52]	@ 0x34
70009c2a:	b141      	cbz	r1, 70009c3e <__swsetup_r+0x4a>
70009c2c:	f104 0344 	add.w	r3, r4, #68	@ 0x44
70009c30:	4299      	cmp	r1, r3
70009c32:	d002      	beq.n	70009c3a <__swsetup_r+0x46>
70009c34:	4628      	mov	r0, r5
70009c36:	f7ff fb2d 	bl	70009294 <_free_r>
70009c3a:	2300      	movs	r3, #0
70009c3c:	6363      	str	r3, [r4, #52]	@ 0x34
70009c3e:	89a3      	ldrh	r3, [r4, #12]
70009c40:	f023 0324 	bic.w	r3, r3, #36	@ 0x24
70009c44:	81a3      	strh	r3, [r4, #12]
70009c46:	2300      	movs	r3, #0
70009c48:	6063      	str	r3, [r4, #4]
70009c4a:	6923      	ldr	r3, [r4, #16]
70009c4c:	6023      	str	r3, [r4, #0]
70009c4e:	89a3      	ldrh	r3, [r4, #12]
70009c50:	f043 0308 	orr.w	r3, r3, #8
70009c54:	81a3      	strh	r3, [r4, #12]
70009c56:	6923      	ldr	r3, [r4, #16]
70009c58:	b94b      	cbnz	r3, 70009c6e <__swsetup_r+0x7a>
70009c5a:	89a3      	ldrh	r3, [r4, #12]
70009c5c:	f403 7320 	and.w	r3, r3, #640	@ 0x280
70009c60:	f5b3 7f00 	cmp.w	r3, #512	@ 0x200
70009c64:	d003      	beq.n	70009c6e <__swsetup_r+0x7a>
70009c66:	4621      	mov	r1, r4
70009c68:	4628      	mov	r0, r5
70009c6a:	f000 f84f 	bl	70009d0c <__smakebuf_r>
70009c6e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
70009c72:	f013 0201 	ands.w	r2, r3, #1
70009c76:	d00a      	beq.n	70009c8e <__swsetup_r+0x9a>
70009c78:	2200      	movs	r2, #0
70009c7a:	60a2      	str	r2, [r4, #8]
70009c7c:	6962      	ldr	r2, [r4, #20]
70009c7e:	4252      	negs	r2, r2
70009c80:	61a2      	str	r2, [r4, #24]
70009c82:	6922      	ldr	r2, [r4, #16]
70009c84:	b942      	cbnz	r2, 70009c98 <__swsetup_r+0xa4>
70009c86:	f013 0080 	ands.w	r0, r3, #128	@ 0x80
70009c8a:	d1c5      	bne.n	70009c18 <__swsetup_r+0x24>
70009c8c:	bd38      	pop	{r3, r4, r5, pc}
70009c8e:	0799      	lsls	r1, r3, #30
70009c90:	bf58      	it	pl
70009c92:	6962      	ldrpl	r2, [r4, #20]
70009c94:	60a2      	str	r2, [r4, #8]
70009c96:	e7f4      	b.n	70009c82 <__swsetup_r+0x8e>
70009c98:	2000      	movs	r0, #0
70009c9a:	e7f7      	b.n	70009c8c <__swsetup_r+0x98>
70009c9c:	24000040 	.word	0x24000040

70009ca0 <_sbrk_r>:
70009ca0:	b538      	push	{r3, r4, r5, lr}
70009ca2:	4d06      	ldr	r5, [pc, #24]	@ (70009cbc <_sbrk_r+0x1c>)
70009ca4:	2300      	movs	r3, #0
70009ca6:	4604      	mov	r4, r0
70009ca8:	4608      	mov	r0, r1
70009caa:	602b      	str	r3, [r5, #0]
70009cac:	f7f7 f88a 	bl	70000dc4 <_sbrk>
70009cb0:	1c43      	adds	r3, r0, #1
70009cb2:	d102      	bne.n	70009cba <_sbrk_r+0x1a>
70009cb4:	682b      	ldr	r3, [r5, #0]
70009cb6:	b103      	cbz	r3, 70009cba <_sbrk_r+0x1a>
70009cb8:	6023      	str	r3, [r4, #0]
70009cba:	bd38      	pop	{r3, r4, r5, pc}
70009cbc:	240005c8 	.word	0x240005c8

70009cc0 <__swhatbuf_r>:
70009cc0:	b570      	push	{r4, r5, r6, lr}
70009cc2:	460c      	mov	r4, r1
70009cc4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
70009cc8:	2900      	cmp	r1, #0
70009cca:	b096      	sub	sp, #88	@ 0x58
70009ccc:	4615      	mov	r5, r2
70009cce:	461e      	mov	r6, r3
70009cd0:	da0d      	bge.n	70009cee <__swhatbuf_r+0x2e>
70009cd2:	89a3      	ldrh	r3, [r4, #12]
70009cd4:	f013 0f80 	tst.w	r3, #128	@ 0x80
70009cd8:	f04f 0100 	mov.w	r1, #0
70009cdc:	bf14      	ite	ne
70009cde:	2340      	movne	r3, #64	@ 0x40
70009ce0:	f44f 6380 	moveq.w	r3, #1024	@ 0x400
70009ce4:	2000      	movs	r0, #0
70009ce6:	6031      	str	r1, [r6, #0]
70009ce8:	602b      	str	r3, [r5, #0]
70009cea:	b016      	add	sp, #88	@ 0x58
70009cec:	bd70      	pop	{r4, r5, r6, pc}
70009cee:	466a      	mov	r2, sp
70009cf0:	f000 f848 	bl	70009d84 <_fstat_r>
70009cf4:	2800      	cmp	r0, #0
70009cf6:	dbec      	blt.n	70009cd2 <__swhatbuf_r+0x12>
70009cf8:	9901      	ldr	r1, [sp, #4]
70009cfa:	f401 4170 	and.w	r1, r1, #61440	@ 0xf000
70009cfe:	f5a1 5300 	sub.w	r3, r1, #8192	@ 0x2000
70009d02:	4259      	negs	r1, r3
70009d04:	4159      	adcs	r1, r3
70009d06:	f44f 6380 	mov.w	r3, #1024	@ 0x400
70009d0a:	e7eb      	b.n	70009ce4 <__swhatbuf_r+0x24>

70009d0c <__smakebuf_r>:
70009d0c:	898b      	ldrh	r3, [r1, #12]
70009d0e:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
70009d10:	079d      	lsls	r5, r3, #30
70009d12:	4606      	mov	r6, r0
70009d14:	460c      	mov	r4, r1
70009d16:	d507      	bpl.n	70009d28 <__smakebuf_r+0x1c>
70009d18:	f104 0347 	add.w	r3, r4, #71	@ 0x47
70009d1c:	6023      	str	r3, [r4, #0]
70009d1e:	6123      	str	r3, [r4, #16]
70009d20:	2301      	movs	r3, #1
70009d22:	6163      	str	r3, [r4, #20]
70009d24:	b003      	add	sp, #12
70009d26:	bdf0      	pop	{r4, r5, r6, r7, pc}
70009d28:	ab01      	add	r3, sp, #4
70009d2a:	466a      	mov	r2, sp
70009d2c:	f7ff ffc8 	bl	70009cc0 <__swhatbuf_r>
70009d30:	9f00      	ldr	r7, [sp, #0]
70009d32:	4605      	mov	r5, r0
70009d34:	4639      	mov	r1, r7
70009d36:	4630      	mov	r0, r6
70009d38:	f7ff fb18 	bl	7000936c <_malloc_r>
70009d3c:	b948      	cbnz	r0, 70009d52 <__smakebuf_r+0x46>
70009d3e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
70009d42:	059a      	lsls	r2, r3, #22
70009d44:	d4ee      	bmi.n	70009d24 <__smakebuf_r+0x18>
70009d46:	f023 0303 	bic.w	r3, r3, #3
70009d4a:	f043 0302 	orr.w	r3, r3, #2
70009d4e:	81a3      	strh	r3, [r4, #12]
70009d50:	e7e2      	b.n	70009d18 <__smakebuf_r+0xc>
70009d52:	89a3      	ldrh	r3, [r4, #12]
70009d54:	6020      	str	r0, [r4, #0]
70009d56:	f043 0380 	orr.w	r3, r3, #128	@ 0x80
70009d5a:	81a3      	strh	r3, [r4, #12]
70009d5c:	9b01      	ldr	r3, [sp, #4]
70009d5e:	e9c4 0704 	strd	r0, r7, [r4, #16]
70009d62:	b15b      	cbz	r3, 70009d7c <__smakebuf_r+0x70>
70009d64:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
70009d68:	4630      	mov	r0, r6
70009d6a:	f000 f81d 	bl	70009da8 <_isatty_r>
70009d6e:	b128      	cbz	r0, 70009d7c <__smakebuf_r+0x70>
70009d70:	89a3      	ldrh	r3, [r4, #12]
70009d72:	f023 0303 	bic.w	r3, r3, #3
70009d76:	f043 0301 	orr.w	r3, r3, #1
70009d7a:	81a3      	strh	r3, [r4, #12]
70009d7c:	89a3      	ldrh	r3, [r4, #12]
70009d7e:	431d      	orrs	r5, r3
70009d80:	81a5      	strh	r5, [r4, #12]
70009d82:	e7cf      	b.n	70009d24 <__smakebuf_r+0x18>

70009d84 <_fstat_r>:
70009d84:	b538      	push	{r3, r4, r5, lr}
70009d86:	4d07      	ldr	r5, [pc, #28]	@ (70009da4 <_fstat_r+0x20>)
70009d88:	2300      	movs	r3, #0
70009d8a:	4604      	mov	r4, r0
70009d8c:	4608      	mov	r0, r1
70009d8e:	4611      	mov	r1, r2
70009d90:	602b      	str	r3, [r5, #0]
70009d92:	f7f6 ffee 	bl	70000d72 <_fstat>
70009d96:	1c43      	adds	r3, r0, #1
70009d98:	d102      	bne.n	70009da0 <_fstat_r+0x1c>
70009d9a:	682b      	ldr	r3, [r5, #0]
70009d9c:	b103      	cbz	r3, 70009da0 <_fstat_r+0x1c>
70009d9e:	6023      	str	r3, [r4, #0]
70009da0:	bd38      	pop	{r3, r4, r5, pc}
70009da2:	bf00      	nop
70009da4:	240005c8 	.word	0x240005c8

70009da8 <_isatty_r>:
70009da8:	b538      	push	{r3, r4, r5, lr}
70009daa:	4d06      	ldr	r5, [pc, #24]	@ (70009dc4 <_isatty_r+0x1c>)
70009dac:	2300      	movs	r3, #0
70009dae:	4604      	mov	r4, r0
70009db0:	4608      	mov	r0, r1
70009db2:	602b      	str	r3, [r5, #0]
70009db4:	f7f6 ffed 	bl	70000d92 <_isatty>
70009db8:	1c43      	adds	r3, r0, #1
70009dba:	d102      	bne.n	70009dc2 <_isatty_r+0x1a>
70009dbc:	682b      	ldr	r3, [r5, #0]
70009dbe:	b103      	cbz	r3, 70009dc2 <_isatty_r+0x1a>
70009dc0:	6023      	str	r3, [r4, #0]
70009dc2:	bd38      	pop	{r3, r4, r5, pc}
70009dc4:	240005c8 	.word	0x240005c8

70009dc8 <_init>:
70009dc8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
70009dca:	bf00      	nop
70009dcc:	bcf8      	pop	{r3, r4, r5, r6, r7}
70009dce:	bc08      	pop	{r3}
70009dd0:	469e      	mov	lr, r3
70009dd2:	4770      	bx	lr

70009dd4 <_fini>:
70009dd4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
70009dd6:	bf00      	nop
70009dd8:	bcf8      	pop	{r3, r4, r5, r6, r7}
70009dda:	bc08      	pop	{r3}
70009ddc:	469e      	mov	lr, r3
70009dde:	4770      	bx	lr
